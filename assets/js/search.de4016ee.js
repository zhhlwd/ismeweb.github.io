(window.webpackJsonp=window.webpackJsonp||[]).push([[3],{288:function(e,t,o){"use strict";o.r(t),t.default=[{title:"转载-从基础到实战手摸手带你掌握新版Webpack4.0详解",path:"/posts/%E8%BD%AC%E8%BD%BD-%E4%BB%8E%E5%9F%BA%E7%A1%80%E5%88%B0%E5%AE%9E%E6%88%98%20%E6%89%8B%E6%91%B8%E6%89%8B%E5%B8%A6%E4%BD%A0%E6%8E%8C%E6%8F%A1%E6%96%B0%E7%89%88Webpack4.0%E8%AF%A6%E8%A7%A3.html",strippedContent:"最近看了慕课网的webpack4视频，对于webpack这种配置的应用，我知道具体的功能配置和概念，要用时知道怎么查找就行了，不想花费过多时间去做笔记，因为做了也记不住，自己的水平不会因此有明显提升，所以我转载了一篇别人的笔记，方便以后查找。 文章转载自https://github.com/wudiufo/WebPack4-study \x3c!-- more --\x3e # 从基础到实战 手摸手带你掌握新版Webpack4.0详解  知识点概览：  > Loader，HMR ,Create React App, Caching, > Plugin, SourceMap,Vue Cli 3.0 ,Shimming, > WebpackDevServer,TreeShaking, CodeSplitting, > Babel, React , Library, Eslint ,PWA, > Vue, Mode,性能优化,多页应用,原理, > PreLoading, PreFetching ,环境变量,TypeScript  收获：  > 彻底学会Webpack的配置 > 理解 Webpack的作用及原理 > 上手项目的打包过程配置 > 拥有工程化的前端思维 > 步入高级前端工程师行列  ## 一：初识Webpack  ### 1. 1 什么是WebPack   **webpack** 是一个现代 JavaScript 应用程序的*静态模块打包工具*：它做的事情是，分析你的项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（Scss，TypeScript等），并生成一个或多个 *bundle*，将其打包为合适的格式以供浏览器使用。  **webpack构建：**  > 构建就是把源代码转换成发布到线上的可执行 JavaScrip、CSS、HTML 代码，包括如下内容。  1.代码转换：TypeScript 编译成 JavaScript、SCSS或Less 编译成 CSS 等。  2.文件优化：压缩 JavaScript、CSS、HTML 代码，压缩合并图片等。  3.代码分割：提取多个页面的公共代码、提取首屏不需要执行部分的代码让其异步加载。  4.模块合并：在采用模块化的项目里会有很多个模块和文件，需要构建功能把模块分类合并成一个文件。  5.自动刷新：监听本地源代码的变化，自动重新构建、刷新浏览器,nodemon。  6.代码校验：在代码被提交到仓库前需要校验代码是否符合规范，以及单元测试是否通过。  7.自动发布：更新完代码后，自动构建出线上发布代码并传输给发布系统。  构建其实是工程化、自动化思想在前端开发中的体现，把一系列流程用代码去实现，让代码自动化地执行这一系列复杂的流程。 构建给前端开发注入了更大的活力，解放了我们的生产力,更加方便了我们的开发。  ### 1.2  什么是 webpack 模块  - [ES2015 `import`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import) 语句  - [CommonJS](http://www.commonjs.org/specs/modules/1.0/) `require()` 语句  - [AMD](https://github.com/amdjs/amdjs-api/blob/master/AMD.md) `define` 和 `require` 语句  - css/sass/less 文件中的 [`@import` 语句](https://developer.mozilla.org/en-US/docs/Web/CSS/@import)。  - 样式(`url(...)`)或 HTML 文件(`<img src=...>`)中的图片链接    **详细请看官网文档**：[Modules](https://webpack.js.org/concepts/modules)       [MODULES](https://webpack.js.org/api)   ### 1.3 搭建Webpack环境  - 去官网下载[node](https://nodejs.org/en/)    ```bash   // 查看node版本号   node -v   // 查看npm版本号   npm -v   ```  ### 1.4 初始化项目  ```bash mkdir webpack-productname cd webpack-productname  //初始化webpack配置清单package.json npm init -y    ```  ### 1.5 安装webpack  ```bash //全局安装（不推荐），因为如果有两个项目用了webpack不同版本，就会出现版本不统一运行不起来的情况。只有卸了当前版本安装对应版本非常麻烦。 npm install webpack webpack-cli -g //查看版本 webpack -v //全局卸载 npm uninstall webpack webpack-cli -g ```  ```bash //在项目里安装webpack（推荐使用）。可以在不同项目中使用不同的webpack版本。 cd webpack-productname npm install webpack webpack-cli -D //查看版本 npx webpack -v //查看对用包的详细信息 npm info webpack //安装指定版本包 npm install webpack@4.16.1 webpack-cli -D ```    **注意：**  >由于npm安装走的是国外的网络，比较慢容易出现安装失败的现象。 > >可以用yarn安装，首先得全局安装yarn，`npm install yarn -g` 。 > >或使用nrm快速切换npm源，首先得全局安装nrm, `npm install -g nrm`。 > >#### nrm 使用： > > nrm ls  查看可选源。 > > nrm test npm 测试速度。看哪个快就use哪个。 > > nrm use cnpm  使用cnpm 。  webpack-cli：使我们们可以在命令行里正确的使用webpack  ### 1.6 webpack的配置文件  webpack 开箱即用，可以无需使用任何配置文件。然而，webpack 会假定项目的入口起点为 `src/index`，然后会在 `dist/main.js` 输出结果，并且在生产环境开启压缩和优化。通常，你的项目还需要继续扩展此能力，为此你可以在项目根目录下创建一个 `webpack.config.js` 文件，webpack 会自动使用它。  在项目根目录下创建 `webpack.config.js` 文件，这是webpack默认配置文件  ```js const path = require('path')  module.exports = {     //默认是production，打包的文件默认被压缩。开发时可以设置为development，不被压缩     mode:'production',      //打包项目的入口文件     entry: './index.js',     //打包项目的输出文件     output: {         //自定义打包输出文件名         filename:'bundle.js',         //输出文件的绝对路径         path: path.resolve(__dirname,'bundle')     } } ```  也可以自己指定配置文件来完成webpack的打包：  ```bash npx webpack --config + 自定义配置文件 ```  详细请看官方文档：[概念](https://webpack.js.org/concepts)    [配置](https://webpack.js.org/configuration)  ### 1.7 webpack打包输出内容  ```bash 执行 `npm run build` 后，在控制台输出  Hash:1b245e275a547956bf52 //本次打包对应唯一一个hash值 Version:webpack 4.29.6 //本次打包对应webpack版本 Time:162ms Built at:2019-4-11 23:13:43 //本次打包耗时，及打包的时间 Asset Size Chunks Chunk Names //打包后的文件名，大小，id，入口文件名 bundle.js 1.36 KiB 0 [emitted] main  Entrypoint main=bundle.js [0]./src/index.js 159 bytes {0}[built] [1]./src/header.js 187 bytes {e}[built] [2]./src/sidebar.js 193 bytes {e}[built] [3]./src/content.js 193 bytes {e} [built]  ```    ##  二：Webpack核心概念  ### 2.1 什么是Loader  webpack可以使用 [loader](https://webpack.docschina.org/concepts/loaders) 来预处理文件，就是通过使用不同的Loader，webpack可以把不同的静态文件都编译成js文件，比如css,sass,less,ES6/7,vue,JSX等。  #### 使用Loader打包静态资源  #### **支持加载图片文件**：  需要安装 `file-loader`:解决CSS等文件中的引入图片路径问题  ```bash  npm install file-loader -D ```  在 `webpack.config.js` 里添加 loader 配置  ```js module.exports = {     //配置模块,主要用来配置不同文件的加载器   module: {       //配置模块规则     rules: [       {         test: /\\.(png|jpg|gif)$/, //正则匹配要使用相应loader的文件         use: [           {             loader: 'file-loader', //要用到的loader               options: {                   //palceholder占位符                   name:'[name].[ext]', //打包后的图片名字，后缀和打包的之前的图片一样                   outputPath: 'images/' //图片打包后的地址               },           },         ],       },     ],   }, }; ```  详细请看官方文档：[file-loader](https://webpack.js.org/loaders/file-loader)  #### **将小图片转换成base64格式**  需要安装 `url-loader`:当图片小于limit的时候会把图片BASE64编码，大于limit参数的时候还是使用file-loader 进行拷贝  ```bash npm install url-loader -D ```  在 `webpack.config.js` 里添加 loader 配置  ```js module.exports = {   module: {     rules: [       {         test: /\\.(png|jpg|gif|bmp/)$/i,         use: [           {             loader: 'url-loader',             options: {               name:'[name].[ext]',               outputPath: 'images/',               limit: 8192 //小于8192b,就可以转化成base64格式。大于就会打包成文件格式             }           }         ]       }     ]   } } ```  详细请看官方文档：[url-loader](https://webpack.js.org/loaders/url-loader)  ---  #### **支持加载样式CSS文件**：  需要安装 `css-loader    style-loader`:  ```bash npm install css-loader style-loader -D ```  在 `webpack.config.js` 里添加 loader 配置  ```js module.exports = {   module: {     rules: [       {         test: /\\.css$/, //匹配以css为后缀的文件         use: ['style-loader', 'css-loader'],//loader的执行顺序是从右向左，从下到上。css-loader：分析几个css文件之间的关系，最终合并为一个css。style-loader:在得到css生成的内容时，把其挂载到html的head里，成为内联样式。       },     ],   }, }; ```  #### **支持加载样式SASS文件**：  需要安装 `sass-loader node-sass`:  ```bash npm install sass-loader node-sass -D ```  在 `webpack.config.js` 里添加 loader 配置  ```js module.exports = {     ...     module: {         rules: [{             test: /\\.scss$/,             use: [                 \"style-loader\", // 将 JS 字符串生成为 style 节点                 \"css-loader\", // 将 CSS 转化成 CommonJS 模块                 \"sass-loader\" // 将 Sass 编译成 CSS，默认使用 Node Sass             ]         }]     } }; ```  #### 为 css 样式属性加不同浏览器的前缀  为了浏览器的兼容性，有时候我们必须加入-webkit,-ms,-o,-moz这些前缀  - Trident内核：主要代表为IE浏览器, 前缀为-ms - Gecko内核：主要代表为Firefox, 前缀为-moz - Presto内核：主要代表为Opera, 前缀为-o - Webkit内核：产要代表为Chrome和Safari, 前缀为-webkit  ```bash npm i postcss-loader autoprefixer -D ```  在项目跟目录下创建 **postcss.config.js**  ```js module.exports = {     plugins: [         require('autoprefixer')     ] } ```    **webpack.config.js**  ```js module.exports = {     ...     module: {         rules: [{             test: /\\.scss$/,             use: [                 \"style-loader\", // 将 JS 字符串生成为 style 节点                 \"css-loader\", // 将 CSS 转化成 CommonJS 模块                 'postcss-loader',//注意postcss-loader放置位置，应放在css-loader之后，sass|less|stylus-loader之前。                 \"sass-loader\" // 将 Sass 编译成 CSS，默认使用 Node Sass                              ]         }]     } }; ```  给loader加一些配置项：  **webpack.config.js**  ```js module.exports = {     ...     module: {         rules: [{             test: /\\.scss$/,             use: [                 \"style-loader\",                  {                  \tloader: \"css-loader\",                     options:{                         importLoaders:2 ,//如果sass文件里还引入了另外一个sass文件，另一个文件还会从sass-loader向上解析。如果不加，就直接从css-loader开始解析// 0 => no loaders (default); 1 => postcss-loader; 2 => postcss-loader, sass-loader                         modules: true //开启css的模块打包。css样式不会和其他模块发生耦合和冲突                     }                 },                  'postcss-loader',                 \"sass-loader\",                               ]         }]     } }; ```  ---  #### 为字体图标文件配loader  在 [阿里巴巴矢量图标库中](https://www.iconfont.cn/)，把需要的字体图标下载到本地，解压。将`iconfont.eot iconfont.svg iconfont.ttf iconfont.woff` 文件放入到项目中，在src中新建一个放字体图标的文件夹font。将iconfont.css文件拷贝到项目中，自己改一下引入字体图标的路径。  需要安装 `file-loader`:  ```bash npm i file-loader -D ```    **webpack.config.js**  ```js module.exports = {     ...     module: {         rules: [{             test: /\\.(eot|ttf|svg|woff)$/,             use:{                 loader:'file-loader'             }         },             ]         }]     } }; ```  详细请看官方文档：[asset-management](https://webpack.js.org/guides/asset-management)  ---  ### plugin : 可以在webpack运行到某个时刻的时候，帮你做一些事情  使用plugins让打包更便捷  #### HtmlWebpackPlugin ：htmlWebpackPlugin 会在打包结束后，自动生成一个html文件，并把打包生成的js自动引入到这个html文件中  安装：`npm i html-webpack-plugin -D`  基本用法：在 webpack.config.js 中：  ```js const HtmlWebpackPlugin = require('html-webpack-plugin'); const path = require('path');  module.exports = {   entry: 'index.js',   output: {     path: path.resolve(__dirname, './dist'),     filename: 'index_bundle.js'   },     plugins: [new HtmlWebpackPlugin({         template: 'src/index.html' //以index.html为模板，把打包生成的js自动引入到这个html文件中     })] }; ```  #### CleanWebpackPlugin :自动清除上一次打包的dist文件  安装：`npm i clean-webpack-plugin -D`  基本用法：在 webpack.config.js 中：  ```js const HtmlWebpackPlugin = require('html-webpack-plugin'); const CleanWebpackPlugin = require('clean-webpack-plugin'); const path = require('path');  module.exports = {   entry: 'index.js',   output: {     path: path.resolve(__dirname, './dist'),     filename: 'index_bundle.js'   },     plugins: [         new HtmlWebpackPlugin({         template: 'src/index.html' //在打包之后，以.html为模板，把打包生成的js自动引入到这个html文件中     }),         new CleanWebpackPlugin(['dist']), // 在打包之前，可以删除dist文件夹下的所有内容          ] }; ```  ---  ### Entry与Output的基础配置  在打包多入口文件时的配置  基本用法：在 webpack.config.js 中：  ```js const HtmlWebpackPlugin = require('html-webpack-plugin'); const CleanWebpackPlugin = require('clean-webpack-plugin'); const path = require('path');  module.exports = {   entry: {    \tmain: './src/index.js',     sub: './src/index.js'   },   output: {     publicPath: 'http://cdn.com.cn', //将注入到html中的js文件前面加上地址     path: path.resolve(__dirname, 'dist'),     filename: '[name].js'   },     plugins: [         new HtmlWebpackPlugin({         template: 'src/index.html' //在打包之后，以.html为模板，把打包生成的js自动引入到这个html文件中     }),         new CleanWebpackPlugin(['dist']), // 在打包之前，可以删除dist文件夹下的所有内容          ] }; ```  详细请看官网：[Output](https://webpack.js.org/configuration/output)  [output-management](https://webpack.js.org/guides/output-management)  ---  ### SourceMap 的配置  sourcemap：打包编译后的文件和源文件的映射关系，用于开发者调试用。  - source-map 把映射文件生成到单独的文件，最完整但最慢  - cheap-module-source-map 在一个单独的文件中产生一个不带列映射的Map  - eval-source-map 使用eval打包源文件模块,在同一个文件中生成完整sourcemap  - cheap-module-eval-source-map sourcemap和打包后的JS同行显示，没有映射列     development环境推荐使用： devtool: 'cheap-module-eval-source-map',    production环境推荐使用： devtool: 'cheap-module-source-map',  webpack.config.js  ```js const path = require('path'); const HtmlWebpackPlugin = require('html-webpack-plugin'); const CleanWebpackPlugin = require('clean-webpack-plugin');  module.exports = { \tmode: 'development',     devtool: 'cheap-module-eval-source-map', \t//devtool:'none',//在开发者模式下，默认开启sourcemap,将其关闭     //devtool:'source-map'//开启映射打包会变慢     //devtool:'inline-source-map'//不单独生成.map文件，会将生成的映射文件以base64的形式插入到打包后的js文件的底部     //devtool:'cheap-inline-source-map'//代码出错提示不用精确显示第几行的第几个字符出错，只显示第几行出错，会提高一些性能     //devtool:'cheap-module-inline-source-map'//不仅管自己的业务代码出错，也管第三方模块和loader的一些报错     //devtool:'eval'//执行效率最快，性能最好，但是针对比较复杂的代码的情况下，提示内容不全面 \t//devtool: 'cheap-module-eval-source-map',//在开发环境推荐使用，提示比较全，打包速度比较快     //devtool: 'cheap-module-source-map',//在生产环境中推荐使用，提示效果会好一些 \t \t \tentry: { \t\tmain: './src/index.js' \t}, \tmodule: { \t\trules: [{ \t\t\ttest: /\\.(jpg|png|gif)$/, \t\t\tuse: { \t\t\t\tloader: 'url-loader', \t\t\t\toptions: { \t\t\t\t\tname: '[name]_[hash].[ext]', \t\t\t\t\toutputPath: 'images/', \t\t\t\t\tlimit: 10240 \t\t\t\t} \t\t\t}  \t\t}, { \t\t\ttest: /\\.(eot|ttf|svg)$/, \t\t\tuse: { \t\t\t\tloader: 'file-loader' \t\t\t}  \t\t}, { \t\t\ttest: /\\.scss$/, \t\t\tuse: [ \t\t\t\t'style-loader',  \t\t\t\t{ \t\t\t\t\tloader: 'css-loader', \t\t\t\t\toptions: { \t\t\t\t\t\timportLoaders: 2 \t\t\t\t\t} \t\t\t\t},         'postcss-loader', \t\t\t\t'sass-loader', \t\t\t\t \t\t\t] \t\t}] \t}, \tplugins: [new HtmlWebpackPlugin({ \t\ttemplate: 'src/index.html' \t}), new CleanWebpackPlugin(['dist'])], \toutput: { \t\tfilename: '[name].js', \t\tpath: path.resolve(__dirname, 'dist') \t} } ```  详细请看官网：[devtool](https://webpack.js.org/configuration/devtool)  ---  ### 使用WebpackDevServer 提升开发效率  解决每次在src里编写完代码都需要手动重新运行 npm run dev  1.在 package.json 中配置  ```json {   \"name\": \"haiyang\",   \"version\": \"1.0.0\",   \"description\": \"\",   \"main\": \"index.js\",   \"scripts\": {     \"bundle\": \"webpack\",     \"watch\": \"webpack --watch\",// 加--watch自动监听代码的变化        },    }  ```    2.在 webpack.config.js 中，加 devServer  安装 `npm i webpack-dev-server –D`  - contentBase :配置开发服务运行时的文件根目录 - open :自动打开浏览器 - host：开发服务器监听的主机地址 - compress :开发服务器是否启动gzip等压缩 - port：开发服务器监听的端口  ```js const path = require('path'); const HtmlWebpackPlugin = require('html-webpack-plugin'); const CleanWebpackPlugin = require('clean-webpack-plugin');  module.exports = { \tmode: 'development', \tdevtool: 'cheap-module-eval-source-map', \tentry: { \t\tmain: './src/index.js' \t}, +\tdevServer: { \t\tcontentBase: './dist', \t\topen: true, \t\tport: 8080,     \tproxy: {//配置跨域，访问的域名会被代理到本地的3000端口       \t\t'/api': 'http://localhost:3000'     \t} \t}, \tmodule: { \t\trules: [] \t}, \tplugins: [], \toutput: { \t\tfilename: '[name].js', \t\tpath: path.resolve(__dirname, 'dist') \t} } ```  在 package.json 中：  ```json {   \"name\": \"haiyang\",   \"version\": \"1.0.0\",   \"description\": \"\",   \"main\": \"index.js\",   \"scripts\": {     \"bundle\": \"webpack\",     \"watch\": \"webpack --watch\",// 加--watch自动监听代码的变化     \"start\": \"webpack-dev-server\",//配置热更新 \t   },   }  ```  详细请看官网 ：[dev-server](https://webpack.js.org/configuration/dev-server)  **扩充知识：自己写一个类似webpackdevserver的工具**   了解即可，功能不全，自行扩展。  在 package.json 中：  ```json {   \"name\": \"haiyang\",   \"version\": \"1.0.0\",   \"description\": \"\",   \"main\": \"index.js\",   \"scripts\": {     \"bundle\": \"webpack\",     \"watch\": \"webpack --watch\",// 加--watch自动监听代码的变化     \"start\": \"webpack-dev-server\",//配置热更新 +\t\"server\" : \"node server.js\" //自己写一个类似webpackdevserver的工具   },   }  ```    安装 ：`npm i express webpack-dev-middleware -D`  在 项目根目录下创建 server.js 文件  在 server.js 中  ```js const express = require('express'); const webpack = require('webpack'); const webpackDevMiddleware = require('webpack-dev-middleware'); const config = require('./webpack.config.js'); const complier = webpack(config);  const app = express();  app.use(webpackDevMiddleware(complier, {}));  app.listen(3000, () => { \tconsole.log('server is running'); }); ```  ---  ### 模块热替换(hot module replacement)  在 package.json 中：  ```json {   \"name\": \"haiyang\",   \"version\": \"1.0.0\",   \"description\": \"\",   \"main\": \"index.js\",   \"scripts\": {     \"start\": \"webpack-dev-server\" //将文件打包到内存中，有助于开发   }, }  ```  在 webpack.config.js 中  ```js const path = require('path'); const HtmlWebpackPlugin = require('html-webpack-plugin'); const CleanWebpackPlugin = require('clean-webpack-plugin'); const webpack = require('webpack');  module.exports = { \tmode: 'development', \tdevtool: 'cheap-module-eval-source-map', \tentry: { \t\tmain: './src/index.js' \t}, \tdevServer: { \t\tcontentBase: './dist', \t\topen: true, \t\tport: 8080, +\t\thot: true,//开启热更新 +\t\thotOnly: true//尽管html功能没有实现，也不让浏览器刷新 \t}, \tmodule: { \t\trules: [{ \t\t\ttest: /\\.(jpg|png|gif)$/, \t\t\tuse: { \t\t\t\tloader: 'url-loader', \t\t\t\toptions: { \t\t\t\t\tname: '[name]_[hash].[ext]', \t\t\t\t\toutputPath: 'images/', \t\t\t\t\tlimit: 10240 \t\t\t\t} \t\t\t}  \t\t}, { \t\t\ttest: /\\.(eot|ttf|svg)$/, \t\t\tuse: { \t\t\t\tloader: 'file-loader' \t\t\t}  \t\t}, { \t\t\ttest: /\\.scss$/, \t\t\tuse: [ \t\t\t\t'style-loader',  \t\t\t\t{ \t\t\t\t\tloader: 'css-loader', \t\t\t\t\toptions: { \t\t\t\t\t\timportLoaders: 2 \t\t\t\t\t} \t\t\t\t},         'postcss-loader', \t\t\t\t'sass-loader', \t\t\t\t \t\t\t] \t\t}, { \t\t\ttest: /\\.css$/, \t\t\tuse: [ \t\t\t\t'style-loader', \t\t\t\t'css-loader', \t\t\t\t'postcss-loader' \t\t\t] \t\t}] \t}, \tplugins: [ \t\tnew HtmlWebpackPlugin({ \t\t\ttemplate: 'src/index.html' \t\t}),  \t\tnew CleanWebpackPlugin(['dist']), +\t\tnew webpack.HotModuleReplacementPlugin() //使用模块热更新插件 \t], \toutput: { \t\tfilename: '[name].js', \t\tpath: path.resolve(__dirname, 'dist') \t} } ```  index.js  ```js //如果模块启用了HMR，就可以用 module.hot.accept(),监听模块的更新。 if (module.hot) {   module.hot.accept('./library.js', function() {     // 使用更新过的 library 模块执行某些操作...   }) } ```  注意点：  > 引入css,用框架Vue，React 时，不需要写 module.hot.accept()，因为在使用css-loader，vue-loader，babel-preset时，就已经配置好了HMR，不需要自己写  详细请看官方文档：[hot-module-replacement](https://webpack.js.org/guides/hot-module-replacement)   [api/hot-module-replacement](https://webpack.js.org/api/hot-module-replacement)  [concepts/hot-module-replacement](https://webpack.js.org/concepts/hot-module-replacement)    ---  ### 使用 Babel 处理 ES6/7 语法  转义为ES5  BABEL官网：https://babeljs.io/setup  安装依赖包：  ```bash npm i babel-loader @babel/core @babel/preset-env -D //生产依赖，兼容低版本浏览器 npm install --save @babel/polyfill ```  在 webpack.config.js 中  ```js module: {   rules: [     {         test: /\\.js$/,      \texclude: /node_modules/,//不需要对第三方模块进行转换，耗费性能      \tloader: \"babel-loader\" ,         options:{             \"presets\": [[\"@babel/preset-env\",{                 targets: {//这个项目运行在大于什么版本的浏览器上，已经支持es6的语法的高版本浏览器就不需要转义成es5了                     edge: \"17\",                     firefox: \"60\",                     chrome: \"67\",                     safari: \"11.1\",                   },                 useBuiltIns:'usage' //按需添加polyfill,把用到的代码都转成低版本浏览器兼容的             }]]         }     }   ] } ```  在 index.js 中：  ```js //在业务代码运行之前最顶部导入 import \"@babel/polyfill\"; ```  ### 注意：在开发类库，第三方模块或组件库时不能用 @babel/polyfill 这种方案，因为会把声明的变量变成全局变量，会污染全局环境。  安装：  ```bash npm install --save-dev @babel/plugin-transform-runtime npm install --save @babel/runtime npm install --save @babel/runtime-corejs2 ```  在 webpack.config.js 中  ```js module: {   rules: [     {         test: /\\.js$/,      \texclude: /node_modules/,//不需要对第三方模块进行转换，耗费性能      \tloader: \"babel-loader\" ,         options:{             \"plugins\": [[\"@babel/plugin-transform-runtime\",{                 \"corejs\": 2,                 \"helpers\": true,                 \"regenerator\": true,                 \"useESModules\": false             }]]         }     }   ] } ```  由于babel需要配置的内容非常多，我们需要在项目根目录下创建一个 `.babelrc` 文件。  就不需要在 webpack.config.js 中写 babel 的配置了。  在  `.babelrc`  中：  ```js {             \"plugins\": [[\"@babel/plugin-transform-runtime\",{                 \"corejs\": 2,                 \"helpers\": true,                 \"regenerator\": true,                 \"useESModules\": false             }]]         } ```  ---  ### 配置 React 代码的打包  业务代码：  在  `.babelrc`  中：  ```js \t{              \"presets\": [                 [\"@babel/preset-env\",{                 targets: {                     edge: \"17\",                     firefox: \"60\",                     chrome: \"67\",                     safari: \"11.1\",                   },                 useBuiltIns:'usage'              \t\t}                 ],                 \"@babel/preset-react\"             ]         } //执行顺序：从下往上，从右向左的顺序 ```  安装：  ```bash npm i react react-dom --save npm install --save-dev @babel/preset-react ```  详细内容请看官网：[babel-loader](https://webpack.js.org/loaders/babel-loader)  ---    ##  三：Webpack进阶  ### Tree Shaking：只支持 ES Module 例如 [`import`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import) 和 `export` 的静态结构特性的引入。当引入一个模块时，不引入所有的代码，只引入需要的代码  在 webpack.config.js 中：  ```js const path = require('path'); const HtmlWebpackPlugin = require('html-webpack-plugin'); const CleanWebpackPlugin = require('clean-webpack-plugin'); const webpack = require('webpack');  module.exports = { \tmode: 'development', \tdevtool: 'cheap-module-eval-source-map', \tentry: { \t\tmain: './src/index.js' \t}, \tdevServer: { \t\tcontentBase: './dist', \t\topen: true, \t\tport: 8080, \t\thot: true, \t\thotOnly: true \t}, \tmodule: { \t\trules: [] \t}, \tplugins: [], +\toptimization: { //在开发环境中加，生产环境不加 \t\tusedExports: true \t}, \toutput: { \t\tfilename: '[name].js', \t\tpath: path.resolve(__dirname, 'dist') \t} } ```  在 package.json 中：  ```json { + \"sideEffects\": [\"*.css\"], //对 所有的css文件 不使用Tree shaking。如果填 false，就是都需要用到Tree shaking } ``` 详细内容请看官网：[tree-shaking](https://webpack.js.org/guides/tree-shaking)  ---   ### Develoment 和Production模式的区分打包  在项目根目录下创建两个文件，webpack.dev.js，webpack.prod.js  webpack.dev.js  ```js const path = require('path'); const HtmlWebpackPlugin = require('html-webpack-plugin'); const CleanWebpackPlugin = require('clean-webpack-plugin'); const webpack = require('webpack');  module.exports = { \tmode: 'development', \tdevtool: 'cheap-module-eval-source-map', \tentry: { \t\tmain: './src/index.js' \t}, \tdevServer: { \t\tcontentBase: './dist', \t\topen: true, \t\tport: 8080, \t\thot: true, \t\thotOnly: true \t}, \tmodule: { \t\trules: [{  \t\t\ttest: /\\.js$/,  \t\t\texclude: /node_modules/,  \t\t\tloader: 'babel-loader', \t\t}, { \t\t\ttest: /\\.(jpg|png|gif)$/, \t\t\tuse: { \t\t\t\tloader: 'url-loader', \t\t\t\toptions: { \t\t\t\t\tname: '[name]_[hash].[ext]', \t\t\t\t\toutputPath: 'images/', \t\t\t\t\tlimit: 10240 \t\t\t\t} \t\t\t}  \t\t}, { \t\t\ttest: /\\.(eot|ttf|svg)$/, \t\t\tuse: { \t\t\t\tloader: 'file-loader' \t\t\t}  \t\t}, { \t\t\ttest: /\\.scss$/, \t\t\tuse: [ \t\t\t\t'style-loader',  \t\t\t\t{ \t\t\t\t\tloader: 'css-loader', \t\t\t\t\toptions: { \t\t\t\t\t\timportLoaders: 2 \t\t\t\t\t} \t\t\t\t},         'postcss-loader', \t\t\t\t'sass-loader', \t\t\t\t \t\t\t] \t\t}, { \t\t\ttest: /\\.css$/, \t\t\tuse: [ \t\t\t\t'style-loader', \t\t\t\t'css-loader', \t\t\t\t'postcss-loader' \t\t\t] \t\t}] \t}, \tplugins: [ \t\tnew HtmlWebpackPlugin({ \t\t\ttemplate: 'src/index.html' \t\t}),  \t\tnew CleanWebpackPlugin(['dist']), \t\tnew webpack.HotModuleReplacementPlugin() \t], \toptimization: { \t\tusedExports: true \t}, \toutput: { \t\tfilename: '[name].js', \t\tpath: path.resolve(__dirname, 'dist') \t} } ```  webpack.prod.js  ```js const path = require('path'); const HtmlWebpackPlugin = require('html-webpack-plugin'); const CleanWebpackPlugin = require('clean-webpack-plugin'); const webpack = require('webpack');  module.exports = { \tmode: 'production', \tdevtool: 'cheap-module-source-map', \tentry: { \t\tmain: './src/index.js' \t}, \t \tmodule: { \t\trules: [{  \t\t\ttest: /\\.js$/,  \t\t\texclude: /node_modules/,  \t\t\tloader: 'babel-loader', \t\t}, { \t\t\ttest: /\\.(jpg|png|gif)$/, \t\t\tuse: { \t\t\t\tloader: 'url-loader', \t\t\t\toptions: { \t\t\t\t\tname: '[name]_[hash].[ext]', \t\t\t\t\toutputPath: 'images/', \t\t\t\t\tlimit: 10240 \t\t\t\t} \t\t\t}  \t\t}, { \t\t\ttest: /\\.(eot|ttf|svg)$/, \t\t\tuse: { \t\t\t\tloader: 'file-loader' \t\t\t}  \t\t}, { \t\t\ttest: /\\.scss$/, \t\t\tuse: [ \t\t\t\t'style-loader',  \t\t\t\t{ \t\t\t\t\tloader: 'css-loader', \t\t\t\t\toptions: { \t\t\t\t\t\timportLoaders: 2 \t\t\t\t\t} \t\t\t\t},         'postcss-loader', \t\t\t\t'sass-loader', \t\t\t\t \t\t\t] \t\t}, { \t\t\ttest: /\\.css$/, \t\t\tuse: [ \t\t\t\t'style-loader', \t\t\t\t'css-loader', \t\t\t\t'postcss-loader' \t\t\t] \t\t}] \t}, \tplugins: [ \t\tnew HtmlWebpackPlugin({ \t\t\ttemplate: 'src/index.html' \t\t}),  \t\tnew CleanWebpackPlugin(['dist']), \t\t \t], \t \toutput: { \t\tfilename: '[name].js', \t\tpath: path.resolve(__dirname, 'dist') \t} } ```  在 package.json 中：  ```json {   \"scripts\": {     \"dev\": \"webpack-dev-server --config webpack.dev.js\",     \"build\": \"webpack --config webpack.prod.js\"   }, }  ```  解决 webpack.dev.js，webpack.prod.js 存在大量重复代码，在项目根目录下创建一个 webpack.common.js 文件，把公共代码提取出来  安装 ：  ```bash npm i webpack-merge -D  ```   webpack.common.js  ```js const path = require('path'); const HtmlWebpackPlugin = require('html-webpack-plugin'); const CleanWebpackPlugin = require('clean-webpack-plugin'); const webpack = require('webpack');  module.exports = {  \tentry: { \t\tmain: './src/index.js' \t}, \t \tmodule: { \t\trules: [{  \t\t\ttest: /\\.js$/,  \t\t\texclude: /node_modules/,  \t\t\tloader: 'babel-loader', \t\t}, { \t\t\ttest: /\\.(jpg|png|gif)$/, \t\t\tuse: { \t\t\t\tloader: 'url-loader', \t\t\t\toptions: { \t\t\t\t\tname: '[name]_[hash].[ext]', \t\t\t\t\toutputPath: 'images/', \t\t\t\t\tlimit: 10240 \t\t\t\t} \t\t\t}  \t\t}, { \t\t\ttest: /\\.(eot|ttf|svg)$/, \t\t\tuse: { \t\t\t\tloader: 'file-loader' \t\t\t}  \t\t}, { \t\t\ttest: /\\.scss$/, \t\t\tuse: [ \t\t\t\t'style-loader',  \t\t\t\t{ \t\t\t\t\tloader: 'css-loader', \t\t\t\t\toptions: { \t\t\t\t\t\timportLoaders: 2 \t\t\t\t\t} \t\t\t\t},         'postcss-loader', \t\t\t\t'sass-loader', \t\t\t\t \t\t\t] \t\t}, { \t\t\ttest: /\\.css$/, \t\t\tuse: [ \t\t\t\t'style-loader', \t\t\t\t'css-loader', \t\t\t\t'postcss-loader' \t\t\t] \t\t}] \t}, \tplugins: [ \t\tnew HtmlWebpackPlugin({ \t\t\ttemplate: 'src/index.html' \t\t}),          new CleanWebpackPlugin(['dist'],{             root:path.resolve(__dirname,'../')         }), \t\t \t], \t \toutput: { \t\tfilename: '[name].js', \t\tpath: path.resolve(__dirname, '../dist') \t} } ```  webpack.dev.js  ```js const webpack = require('webpack'); const merge = require('webpack-merge') const commenConfig = require('./webpack.commin.js')  const devConfig = { \tmode: 'development', \tdevtool: 'cheap-module-eval-source-map', \t \tdevServer: { \t\tcontentBase: './dist', \t\topen: true, \t\tport: 8080, \t\thot: true, \t\thotOnly: true \t}, \t \tplugins: [\t \t\tnew webpack.HotModuleReplacementPlugin() \t], \toptimization: { \t\tusedExports: true \t},\t } //将开发配置和公共配置做结合 module.exports = merge(commenConfig, devConfig) ```  webpack.prod.js  ```js const merge = require('webpack-merge') const commenConfig = require('./webpack.commin.js')  const prodConfig = { \tmode: 'production', \tdevtool: 'cheap-module-source-map', } //将线上配置和公共配置做结合 module.exports = merge(commenConfig, prodConfig) ```  最后在根目录下创建一个build文件夹，将 webpack.common.js ， webpack.dev.js ，webpack.prod.js 放在build文件夹下,统一管理。  在 package.json 中：  ```json {   \"scripts\": {     \"dev\": \"webpack-dev-server --config ./build/webpack.dev.js\",     \"build\": \"webpack --config ./build/webpack.prod.js\"   }, } ``` 详细请看官网文档：[guides/production](https://webpack.js.org/guides/production)  ---  ### Webpack和Code Splitting  安装： `npm i lodash --save`    `npm i babel-plugin-dynamic-import-webpack -D`   代码分割，和webpack无关，为了提升性能  webpack中实现代码分割，两种方式:  第一种方法:同步代码： 只需要在webpack.common.js中做optimization的配置即可  第二种方法:异步代码(import): 异步代码，无需做任何配置，会自动进行代码分割，放置到新的文件中  第一种方法：在 webpack.common.js 中  ```js  module.exports = { \tentry: { \t\tmain: './src/index.js' \t}, \t \tmodule: { \t\trules: [] \t}, \tplugins: [], +    optimization:{ +       splitChunks:{ //启动代码分割，有默认配置项 +            chunks:'all' +        }   +    }, \t \toutput: {} } ```  第二种方法在 `.babelrc` 中：  ```js { \tpresets: [ \t\t[ \t\t\t\"@babel/preset-env\", { \t\t\t\ttargets: { \t\t\t\t\tchrome: \"67\", \t\t\t\t}, \t\t\t\tuseBuiltIns: 'usage' \t\t\t} \t\t], \t\t\"@babel/preset-react\" \t], +\tplugins: [\"dynamic-import-webpack\"] }  ``` 详细内容请看官网：[code-splitting](https://webpack.js.org/guides/code-splitting)  ---  ### SplitChunksPlugin 配置参数详解  安装：`npm install --save-dev @babeL/plugin-syntax-dynamic-import`  在业务 index.js 中：  ```js   function getComponent() {  \treturn import(/* webpackChunkName:\"lodash\" */ 'lodash').then(({ default: _ }) => {  \t\tvar element = document.createElement('div'); \t\telement.innerHTML = _.join(['1', '2'], '-');  \t\treturn element; \t}) }   getComponent().then(element => {  \tdocument.body.appendChild(element);  });  ```    在 `.babelrc` 中：  ```js { \tpresets: [ \t\t[ \t\t\t\"@babel/preset-env\", { \t\t\t\ttargets: { \t\t\t\t\tchrome: \"67\", \t\t\t\t}, \t\t\t\tuseBuiltIns: 'usage' \t\t\t} \t\t], \t\t\"@babel/preset-react\" \t], +\tplugins: [\"@babeL/plugin-syntax-dynamic-import\"] }  ```  在 webpack.common.js 中：  ```js  module.exports = { \tentry: { \t\tmain: './src/index.js' \t}, \t \tmodule: { \t\trules: [] \t}, \tplugins: [], +    optimization:{ +       splitChunks:{ //启动代码分割,不写有默认配置项 +            chunks: 'all',//参数all/initial/async，只对所有/同步/异步进行代码分割               minSize: 30000, //大于30kb才会对代码分割               maxSize: 0,               minChunks: 1,//打包生成的文件，当一个模块至少用多少次时才会进行代码分割               maxAsyncRequests: 5,//同时加载的模块数最多是5个               maxInitialRequests: 3,//入口文件最多3个模块会做代码分割，否则不会               automaticNameDelimiter: '~',//文件自动生成的连接符               name: true,             cacheGroups:{//对同步代码走缓存组              vendors: {                   test: /[\\\\/]node_modules[\\\\/]/,                   priority: -10,//谁优先级大就把打包后的文件放到哪个组     \t\t\tfilename:'vendors.js'                 },             default: {               minChunks: 2,               priority: -20,               reuseExistingChunk: true,//模块已经被打包过了，就不用再打包了，复用之前的就可以               filename:'common.js' //打包之后的文件名                }         } +        }   +    }, \t \toutput: {} } ```  详细请看官方文档：[split-chunks-plugin](https://webpack.js.org/plugins/split-chunks-plugin)   ---  ### Lazy Loading 懒加载，Chunk是什么？  > 用户当前需要用什么功能就只加载这个功能对应的代码，也就是所谓的按需加载 在给单页应用做按需加载优化时，一般采用以下原则： > > - 对网站功能进行划分，每一类一个chunk > - 对于首次打开页面需要的功能直接加载，尽快展示给用户 > - 某些依赖大量代码的功能点可以按需加载 > - 被分割出去的代码需要一个按需加载的时机 > > 每一个文件就是一个 chunk  详细请看官方文档：[lazy-loading](https://webpack.js.org/guides/lazy-loading)  ---  ### 打包分析，Preloading，Prefetching  打开网址：webpack分析工具：`https://github.com/webpack/analyse`  在 package.json 中  ```json {     \"scripts\": {     \"dev-build\": \"webpack --profile --json > stats.json --config ./build/webpack.dev.js\", //把打包过程的描述放在stats.json文件中     \"dev\": \"webpack-dev-server --config ./build/webpack.dev.js\",     \"build\": \"webpack --config ./build/webpack.prod.js\"   }, }  ```  在控制台运行  `npm run dev-build` ,在根目录下生成 stats.json 文件。打开网址 `http://webpack.github.io/analyse/` ,把stats.json文件传上去，会出现分析结果。  详细请看官方文档：[bundle-analysis 打包分析工具](https://webpack.js.org/guides/code-splitting/#bundle-analysis)   #### **介绍 [webpack-bundle-analyzer](https://github.com/webpack-contrib/webpack-bundle-analyzer) 的使用：**  通过使用[webpack-bundle-analyzer](https://www.npmjs.com/package/webpack-bundle-analyzer)可以看到项目各模块的大小，可以按需优化。  官网图镇楼：  ![](https://cloud.githubusercontent.com/assets/302213/20628702/93f72404-b338-11e6-92d4-9a365550a701.gif)  安装：  ```bash # NPM npm install --save-dev webpack-bundle-analyzer # Yarn yarn add -D webpack-bundle-analyzer ```  配置：在 webpack.config.js 中：  ```js const BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin;  module.exports = {   plugins: [     new BundleAnalyzerPlugin(     \t{               analyzerMode: 'server',               analyzerHost: '127.0.0.1',               analyzerPort: 8889,               reportFilename: 'report.html',               defaultSizes: 'parsed',               openAnalyzer: true,               generateStatsFile: false,               statsFilename: 'stats.json',               statsOptions: null,               logLevel: 'info'             }     )   ] } ```  输出：在 package.json 中：  ```bash \"analyz\": \"NODE_ENV=production npm_config_report=true npm run build\" ```  在线分析:在 控制台输入：  ```bash webpack --profile --json > stats.json ```  >- profile：记录下构建过程中的耗时信息； >- json：以 JSON 的格式输出构建结果，最后只输出一个 .json 文件，这个文件中包括所有构建相关的信息。 >- Webpack 官方提供了一个可视化分析工具 [Webpack Analyse](https://webpack.github.io/analyse) >- Modules：展示所有的模块，每个模块对应一个文件。并且还包含所有模块之间的依赖关系图、模块路径、模块ID、模块所属 Chunk、模块大小； >- Chunks：展示所有的代码块，一个代码块中包含多个模块。并且还包含代码块的ID、名称、大小、每个代码块包含的模块数量，以及代码块之间的依赖关系图； >- Assets：展示所有输出的文件资源，包括 .js、.css、图片等。并且还包括文件名称、大小、该文件来自哪个代码块； >- Warnings：展示构建过程中出现的所有警告信息； >- Errors：展示构建过程中出现的所有错误信息； >- Hints：展示处理每个模块的过程中的耗时。  打开谷歌控制台查看代码使用率，按 `ctrl+shift+p`  ，输入 coverage 查看。  ### 预取/预加载模块(prefetch/preload module)  假如有一个HomePage组件，其内部有一个LoginButton.js登陆组件，再点击后按需加载 LoginModel 组件。  LoginButton.js:  ```js import(/* webpackPrefetch: true */ 'LoginModal'); ```  这会生成 `<link rel=\"prefetch\" href=\"login-modal-chunk.js\">` 并追加到页面头部，指示着浏览器在闲置时间预取 `login-modal-chunk.js` 文件。就是说，只要首页加载完成，就会在空闲时间把登录模块也加载了。  总结：  > /* webpackPrefetch: true */：把主加载流程加载完毕，在空闲时在加载其他，等再点击其他时，只需要从缓存中读取即可，性能更好。推荐使用，提高代码利用率。把一些交互后才能用到的代码写到异步组件里，通过懒加载的形式，去把这块的代码逻辑加载进来，性能提升，页面访问速度更快。 > > /* webpackPreload: true */: 和主加载流程一起并行加载。  详细请看官方文档：[prefetchingpreloading-modules](https://webpack.js.org/guides/code-splitting/#prefetchingpreloading-modules)  ---  ### CSS文件的代码分割  在 webpack.config.js 中  ```js module.exports = { \tentry: { \t\tmain: './src/index.js' \t},     module: {             },     plugins: [], \toptimization: { \t\tsplitChunks: {       \t chunks: 'all'     } \t}, \toutput: { \t\tfilename: '[name].js',//入口文件打包后生成的文件名 +         chunkFilename: '[name].chunk.js',//main.js异步加载的间接的js文件。用来打包import('module')方法中引入的模块 \t\tpath: path.resolve(__dirname, '../dist') \t} } ```    因为CSS的下载和JS可以并行,当一个HTML文件很大的时候，我们可以把CSS单独提取出来加载  - [mini-css-extract-plugin](https://github.com/webpack-contrib/mini-css-extract-plugin):一般在线上环境使用这个插件，因为在开发环境中不支持HMR。 - filename 打包入口文件 - chunkFilename 用来打包`import('module')`方法中引入的模块  安装 ：  ```bash //抽离css文件 npm install --save-dev mini-css-extract-plugin //压缩css文件 npm i optimize-css-assets-webpack-plugin -D ```  在 webpack.prod.js 中：  ```js const MiniCssExtractPlugin = require(\"mini-css-extract-plugin\"); const OptimizeCSSAssetsPlugin = require(\"optimize-css-assets-webpack-plugin\"); const merge = require('webpack-merge'); const commonConfig = require('./webpack.common.js');   const prodConfig = { \tmode: 'production', \tdevtool: 'cheap-module-source-map', \tmodule: { \t\trules:[{ \t\t\ttest: /\\.scss$/, \t\t\tuse: [ +\t\t\t\tMiniCssExtractPlugin.loader,  \t\t\t\t{ \t\t\t\t\tloader: 'css-loader', \t\t\t\t\toptions: { \t\t\t\t\t\timportLoaders: 2 \t\t\t\t\t} \t\t\t\t},         'postcss-loader', \t\t\t\t'sass-loader', \t\t\t\t \t\t\t] \t\t}, { \t\t\ttest: /\\.css$/, \t\t\tuse: [ +\t\t\t\tMiniCssExtractPlugin.loader, \t\t\t\t'css-loader', \t\t\t\t'postcss-loader' \t\t\t] \t\t}] \t}, +\toptimization: { \t\tminimizer: [new OptimizeCSSAssetsPlugin({})] \t}, \tplugins: [ +\t\tnew MiniCssExtractPlugin({ \t\t\tfilename: '[name].css',//直接引用的css文件 \t\t\tchunkFilename: '[name].chunk.css'//间接引用的css文件 \t\t}) \t] }  module.exports = merge(commonConfig, prodConfig); ```  在 webpack.dev.js  ```js const webpack = require('webpack'); const merge = require('webpack-merge'); const commonConfig = require('./webpack.common.js');  const devConfig = { \tmode: 'development', \tdevtool: 'cheap-module-eval-source-map', \tdevServer: { \t\tcontentBase: './dist', \t\topen: true, \t\tport: 8080, \t\thot: true \t}, \tmodule: { \t\trules: [{ \t\t\ttest: /\\.scss$/, \t\t\tuse: [ \t\t\t\t'style-loader',  \t\t\t\t{ \t\t\t\t\tloader: 'css-loader', \t\t\t\t\toptions: { \t\t\t\t\t\timportLoaders: 2 \t\t\t\t\t} \t\t\t\t},         'postcss-loader', \t\t\t\t'sass-loader', \t\t\t\t \t\t\t] \t\t}, { \t\t\ttest: /\\.css$/, \t\t\tuse: [ \t\t\t\t'style-loader', \t\t\t\t'css-loader', \t\t\t\t'postcss-loader' \t\t\t] \t\t}] \t}, \tplugins: [ \t\tnew webpack.HotModuleReplacementPlugin() \t], }  module.exports = merge(commonConfig, devConfig); ```  在 webpack.common.js 中：  ```js const path = require('path'); const HtmlWebpackPlugin = require('html-webpack-plugin'); const CleanWebpackPlugin = require('clean-webpack-plugin');  module.exports = { \tentry: { \t\tmain: './src/index.js', \t}, \tmodule: { \t\trules: [{  \t\t\ttest: /\\.js$/,  \t\t\texclude: /node_modules/,  \t\t\tloader: 'babel-loader', \t\t}, { \t\t\ttest: /\\.(jpg|png|gif)$/, \t\t\tuse: { \t\t\t\tloader: 'url-loader', \t\t\t\toptions: { \t\t\t\t\tname: '[name]_[hash].[ext]', \t\t\t\t\toutputPath: 'images/', \t\t\t\t\tlimit: 10240 \t\t\t\t} \t\t\t}  \t\t}, { \t\t\ttest: /\\.(eot|ttf|svg)$/, \t\t\tuse: { \t\t\t\tloader: 'file-loader' \t\t\t}  \t\t}] \t}, \tplugins: [ \t\tnew HtmlWebpackPlugin({ \t\t\ttemplate: 'src/index.html' \t\t}),  \t\tnew CleanWebpackPlugin(['dist'], { \t\t\troot: path.resolve(__dirname, '../') \t\t}) \t], \toptimization: { \t\tusedExports: true,//TreeShaking \t\tsplitChunks: {       chunks: 'all'     } \t}, \toutput: { \t\tfilename: '[name].js', \t\tchunkFilename: '[name].chunk.js', \t\tpath: path.resolve(__dirname, '../dist') \t} } ```  在 package.json 中：  ```json {     \"sideEffects\": [\"*.css\"] //除了css文件，其余的都TreeShaking } ```  详细请看官方文档：[mini-css-extract-plugin](https://webpack.js.org/plugins/mini-css-extract-plugin)  ---  ### Webpack 与浏览器缓存（Caching）  在 webpack.common.js 中：  ```js const path = require('path'); const HtmlWebpackPlugin = require('html-webpack-plugin'); const CleanWebpackPlugin = require('clean-webpack-plugin');  module.exports = { \tentry: { \t\tmain: './src/index.js', \t}, \tmodule: { \t\trules: [{  \t\t\ttest: /\\.js$/,  \t\t\texclude: /node_modules/,  \t\t\tloader: 'babel-loader', \t\t}, { \t\t\ttest: /\\.(jpg|png|gif)$/, \t\t\tuse: { \t\t\t\tloader: 'url-loader', \t\t\t\toptions: { \t\t\t\t\tname: '[name]_[hash].[ext]', \t\t\t\t\toutputPath: 'images/', \t\t\t\t\tlimit: 10240 \t\t\t\t} \t\t\t}  \t\t}, { \t\t\ttest: /\\.(eot|ttf|svg)$/, \t\t\tuse: { \t\t\t\tloader: 'file-loader' \t\t\t}  \t\t}] \t}, \tplugins: [ \t\tnew HtmlWebpackPlugin({ \t\t\ttemplate: 'src/index.html' \t\t}),  \t\tnew CleanWebpackPlugin(['dist'], { \t\t\troot: path.resolve(__dirname, '../') \t\t}) \t], \toptimization: { +\t\truntimeChunk: {//兼容老版本webpack4，把manifest打包到runtime里，不影响业务代码和第三方模块 \t\t\tname: 'runtime' \t\t}, \t\tusedExports: true, \t\tsplitChunks: {       chunks: 'all',       cacheGroups: {       \tvendors: {       \t\ttest: /[\\\\/]node_modules[\\\\/]/,       \t\tpriority: -10,       \t\tname: 'vendors',       \t}       }     } \t}, \tperformance: false,//禁止提示性能上的一些问题 +\toutput: { \t\tpath: path.resolve(__dirname, '../dist') \t} } ```  在 webpack.dev.js 中：  ```js const webpack = require('webpack'); const merge = require('webpack-merge'); const commonConfig = require('./webpack.common.js');  const devConfig = { \tmode: 'development', \tdevtool: 'cheap-module-eval-source-map', \tdevServer: { \t\tcontentBase: './dist', \t\topen: true, \t\tport: 8080, \t\thot: true \t}, \tmodule: { \t\trules: [{ \t\t\ttest: /\\.scss$/, \t\t\tuse: [ \t\t\t\t'style-loader',  \t\t\t\t{ \t\t\t\t\tloader: 'css-loader', \t\t\t\t\toptions: { \t\t\t\t\t\timportLoaders: 2 \t\t\t\t\t} \t\t\t\t},         'postcss-loader', \t\t\t\t'sass-loader', \t\t\t\t \t\t\t] \t\t}, { \t\t\ttest: /\\.css$/, \t\t\tuse: [ \t\t\t\t'style-loader', \t\t\t\t'css-loader', \t\t\t\t'postcss-loader' \t\t\t] \t\t}] \t}, \tplugins: [ \t\tnew webpack.HotModuleReplacementPlugin() \t], +\toutput: { \t\tfilename: '[name].js', \t\tchunkFilename: '[name].js', \t} }  module.exports = merge(commonConfig, devConfig); ```  在 webpack.prod.js 中：  ```js const MiniCssExtractPlugin = require(\"mini-css-extract-plugin\"); const OptimizeCSSAssetsPlugin = require(\"optimize-css-assets-webpack-plugin\"); const merge = require('webpack-merge'); const commonConfig = require('./webpack.common.js');  const prodConfig = { \tmode: 'production', \tdevtool: 'cheap-module-source-map', \tmodule: { \t\trules:[{ \t\t\ttest: /\\.scss$/, \t\t\tuse: [ \t\t\t\tMiniCssExtractPlugin.loader,  \t\t\t\t{ \t\t\t\t\tloader: 'css-loader', \t\t\t\t\toptions: { \t\t\t\t\t\timportLoaders: 2 \t\t\t\t\t} \t\t\t\t},         'postcss-loader', \t\t\t\t'sass-loader', \t\t\t\t \t\t\t] \t\t}, { \t\t\ttest: /\\.css$/, \t\t\tuse: [ \t\t\t\tMiniCssExtractPlugin.loader, \t\t\t\t'css-loader', \t\t\t\t'postcss-loader' \t\t\t] \t\t}] \t}, \toptimization: { \t\tminimizer: [new OptimizeCSSAssetsPlugin({})] \t}, \tplugins: [ \t\tnew MiniCssExtractPlugin({ \t\t\tfilename: '[name].css', \t\t\tchunkFilename: '[name].chunk.css' \t\t}) \t], +\toutput: { \t\tfilename: '[name].[contenthash].js', //源代码不变，hash值就不会变，解决浏览器缓存问题。打包上线时，用户只需要更新有变化的代码，没有变化的从浏览器缓存读取 \t\tchunkFilename: '[name].[contenthash].js' \t} }  module.exports = merge(commonConfig, prodConfig); ```  详细请看官网文档：[manifest](https://webpack.js.org/concepts/manifest/#manifest)  ---  ### Shimming (垫片)  在 webpack.common.js 中：  ```js const path = require('path'); const HtmlWebpackPlugin = require('html-webpack-plugin'); const CleanWebpackPlugin = require('clean-webpack-plugin'); const webpack = require('webpack');  module.exports = { \tentry: { \t\tmain: './src/index.js', \t}, \tmodule: { \t\trules: [{  \t\t\ttest: /\\.js$/,  \t\t\texclude: /node_modules/, \t\t\tuse: [{ \t\t\t\tloader: 'babel-loader' \t\t\t}, { \t\t\t\tloader: 'imports-loader?this=>window' \t\t\t}] \t\t}, { \t\t\ttest: /\\.(jpg|png|gif)$/, \t\t\tuse: { \t\t\t\tloader: 'url-loader', \t\t\t\toptions: { \t\t\t\t\tname: '[name]_[hash].[ext]', \t\t\t\t\toutputPath: 'images/', \t\t\t\t\tlimit: 10240 \t\t\t\t} \t\t\t}  \t\t}, { \t\t\ttest: /\\.(eot|ttf|svg)$/, \t\t\tuse: { \t\t\t\tloader: 'file-loader' \t\t\t}  \t\t}] \t}, \tplugins: [ \t\tnew HtmlWebpackPlugin({ \t\t\ttemplate: 'src/index.html' \t\t}),  \t\tnew CleanWebpackPlugin(['dist'], { \t\t\troot: path.resolve(__dirname, '../') \t\t}), +\t\tnew webpack.ProvidePlugin({ \t\t\t$: 'jquery',//发现模块中有$字符串，就自动引入iquery,就可以用jquery \t\t\t_join: ['lodash', 'join']//_join代表lodash里的join方法 \t\t}), \t], \toptimization: { \t\truntimeChunk: { \t\t\tname: 'runtime' \t\t}, \t\tusedExports: true, \t\tsplitChunks: {       chunks: 'all',       cacheGroups: {       \tvendors: {       \t\ttest: /[\\\\/]node_modules[\\\\/]/,       \t\tpriority: -10,       \t\tname: 'vendors',       \t}       }     } \t}, \tperformance: false, \toutput: { \t\tpath: path.resolve(__dirname, '../dist') \t} } ```  #### `如果想让每个js模块的this都指向window：`  安装： `npm install imports-loader -D`  在 webpack.common.js 中：  ```js const path = require('path'); const HtmlWebpackPlugin = require('html-webpack-plugin'); const CleanWebpackPlugin = require('clean-webpack-plugin'); const webpack = require('webpack');  module.exports = { \tentry: { \t\tmain: './src/index.js', \t}, \tmodule: { \t\trules: [{  \t\t\ttest: /\\.js$/,  \t\t\texclude: /node_modules/, \t\t\tuse: [{ \t\t\t\tloader: 'babel-loader' \t\t\t}, {//每个js模块的this都指向window +\t\t\t\tloader: 'imports-loader?this=>window' \t\t\t}] \t\t}, { \t\t\ttest: /\\.(jpg|png|gif)$/, \t\t\tuse: { \t\t\t\tloader: 'url-loader', \t\t\t\toptions: { \t\t\t\t\tname: '[name]_[hash].[ext]', \t\t\t\t\toutputPath: 'images/', \t\t\t\t\tlimit: 10240 \t\t\t\t} \t\t\t}  \t\t}, { \t\t\ttest: /\\.(eot|ttf|svg)$/, \t\t\tuse: { \t\t\t\tloader: 'file-loader' \t\t\t}  \t\t}] \t}, \tplugins: [ \t\tnew HtmlWebpackPlugin({ \t\t\ttemplate: 'src/index.html' \t\t}),  \t\tnew CleanWebpackPlugin(['dist'], { \t\t\troot: path.resolve(__dirname, '../') \t\t}), +\t\tnew webpack.ProvidePlugin({ \t\t\t$: 'jquery',//发现模块中有$字符串，就自动引入iquery,就可以用jquery \t\t\t_join: ['lodash', 'join']//_join代表lodash里的join方法 \t\t}), \t], \toptimization: { \t\truntimeChunk: { \t\t\tname: 'runtime' \t\t}, \t\tusedExports: true, \t\tsplitChunks: {       chunks: 'all',       cacheGroups: {       \tvendors: {       \t\ttest: /[\\\\/]node_modules[\\\\/]/,       \t\tpriority: -10,       \t\tname: 'vendors',       \t}       }     } \t}, \tperformance: false, \toutput: { \t\tpath: path.resolve(__dirname, '../dist') \t} } ```  详细请看官方文档：[imports-loader](https://webpack.js.org/loaders/imports-loader)   [shimming](https://webpack.js.org/guides/shimming)   ---  ### 环境变量的使用  只需要一个common.js文件通过在package.json中传递不同的参数，区分是开发环境还是生产环境。  在 package.json 中：  ```json {   \"name\": \"haiyang\",   \"sideEffects\": [     \"*.css\"   ],   \"version\": \"1.0.0\",   \"description\": \"\",   \"main\": \"index.js\",   \"scripts\": {     \"dev-build\": \"webpack --config ./build/webpack.common.js\",     \"dev\": \"webpack-dev-server --config ./build/webpack.common.js\",     \"build\": \"webpack --env.production --config ./build/webpack.common.js\" //通过--env.production,把环境变量传进去   },   \"author\": \"\",   \"license\": \"ISC\",   \"devDependencies\": {     \"@babel/core\": \"^7.2.0\",     \"@babel/plugin-syntax-dynamic-import\": \"^7.2.0\",     \"@babel/plugin-transform-runtime\": \"^7.2.0\",     \"@babel/preset-env\": \"^7.2.0\",     \"@babel/preset-react\": \"^7.0.0\",     \"autoprefixer\": \"^9.3.1\",     \"babel-loader\": \"^8.0.4\",     \"clean-webpack-plugin\": \"^1.0.0\",     \"css-loader\": \"^1.0.1\",     \"express\": \"^4.16.4\",     \"file-loader\": \"^2.0.0\",     \"html-webpack-plugin\": \"^3.2.0\",     \"imports-loader\": \"^0.8.0\",     \"mini-css-extract-plugin\": \"^0.5.0\",     \"node-sass\": \"^4.10.0\",     \"optimize-css-assets-webpack-plugin\": \"^5.0.1\",     \"postcss-loader\": \"^3.0.0\",     \"sass-loader\": \"^7.1.0\",     \"style-loader\": \"^0.23.1\",     \"url-loader\": \"^1.1.2\",     \"webpack-cli\": \"^3.1.2\",     \"webpack-dev-middleware\": \"^3.4.0\",     \"webpack-dev-server\": \"^3.1.10\",     \"webpack-merge\": \"^4.1.5\"   },   \"dependencies\": {     \"@babel/polyfill\": \"^7.0.0\",     \"@babel/runtime\": \"^7.2.0\",     \"@babel/runtime-corejs2\": \"^7.2.0\",     \"jquery\": \"^3.3.1\",     \"lodash\": \"^4.17.11\",     \"react\": \"^16.6.3\",     \"react-dom\": \"^16.6.3\",     \"webpack\": \"^4.25.1\"   } }  ```    在 webpack.common.js 中：  ```js const path = require('path'); const HtmlWebpackPlugin = require('html-webpack-plugin'); const CleanWebpackPlugin = require('clean-webpack-plugin'); const webpack = require('webpack'); const merge = require('webpack-merge'); const devConfig = require('./webpack.dev.js'); const prodConfig = require('./webpack.prod.js'); const commonConfig = { \tentry: { \t\tmain: './src/index.js', \t}, \tmodule: { \t\trules: [{  \t\t\ttest: /\\.js$/,  \t\t\texclude: /node_modules/, \t\t\tuse: [{ \t\t\t\tloader: 'babel-loader' \t\t\t}, { \t\t\t\tloader: 'imports-loader?this=>window' \t\t\t}] \t\t}, { \t\t\ttest: /\\.(jpg|png|gif)$/, \t\t\tuse: { \t\t\t\tloader: 'url-loader', \t\t\t\toptions: { \t\t\t\t\tname: '[name]_[hash].[ext]', \t\t\t\t\toutputPath: 'images/', \t\t\t\t\tlimit: 10240 \t\t\t\t} \t\t\t}  \t\t}, { \t\t\ttest: /\\.(eot|ttf|svg)$/, \t\t\tuse: { \t\t\t\tloader: 'file-loader' \t\t\t}  \t\t}] \t}, \tplugins: [ \t\tnew HtmlWebpackPlugin({ \t\t\ttemplate: 'src/index.html' \t\t}),  \t\tnew CleanWebpackPlugin(['dist'], { \t\t\troot: path.resolve(__dirname, '../') \t\t}), \t\tnew webpack.ProvidePlugin({ \t\t\t$: 'jquery', \t\t\t_join: ['lodash', 'join'] \t\t}), \t], \toptimization: { \t\truntimeChunk: { \t\t\tname: 'runtime' \t\t}, \t\tusedExports: true, \t\tsplitChunks: {       chunks: 'all',       cacheGroups: {       \tvendors: {       \t\ttest: /[\\\\/]node_modules[\\\\/]/,       \t\tpriority: -10,       \t\tname: 'vendors',       \t}       }     } \t}, \tperformance: false, \toutput: { \t\tpath: path.resolve(__dirname, '../dist') \t} }  module.exports = (env) => { \tif(env && env.production) {//线上环境 \t\treturn merge(commonConfig, prodConfig); \t}else {//开发环境 \t\treturn merge(commonConfig, devConfig); \t} }   ```  在 webpack.dev.js 中：  ```js const webpack = require('webpack');  const devConfig = { \tmode: 'development', \tdevtool: 'cheap-module-eval-source-map', \tdevServer: { \t\tcontentBase: './dist', \t\topen: true, \t\tport: 8080, \t\thot: true \t}, \tmodule: { \t\trules: [{ \t\t\ttest: /\\.scss$/, \t\t\tuse: [ \t\t\t\t'style-loader',  \t\t\t\t{ \t\t\t\t\tloader: 'css-loader', \t\t\t\t\toptions: { \t\t\t\t\t\timportLoaders: 2 \t\t\t\t\t} \t\t\t\t},         'postcss-loader', \t\t\t\t'sass-loader', \t\t\t\t \t\t\t] \t\t}, { \t\t\ttest: /\\.css$/, \t\t\tuse: [ \t\t\t\t'style-loader', \t\t\t\t'css-loader', \t\t\t\t'postcss-loader' \t\t\t] \t\t}] \t}, \tplugins: [ \t\tnew webpack.HotModuleReplacementPlugin() \t], \toutput: { \t\tfilename: '[name].js', \t\tchunkFilename: '[name].js', \t} }  module.exports = devConfig; ```  在webpack.prod.js 中：  ```js const MiniCssExtractPlugin = require(\"mini-css-extract-plugin\"); const OptimizeCSSAssetsPlugin = require(\"optimize-css-assets-webpack-plugin\");  const prodConfig = { \tmode: 'production', \tdevtool: 'cheap-module-source-map', \tmodule: { \t\trules:[{ \t\t\ttest: /\\.scss$/, \t\t\tuse: [ \t\t\t\tMiniCssExtractPlugin.loader,  \t\t\t\t{ \t\t\t\t\tloader: 'css-loader', \t\t\t\t\toptions: { \t\t\t\t\t\timportLoaders: 2 \t\t\t\t\t} \t\t\t\t},         'postcss-loader', \t\t\t\t'sass-loader', \t\t\t\t \t\t\t] \t\t}, { \t\t\ttest: /\\.css$/, \t\t\tuse: [ \t\t\t\tMiniCssExtractPlugin.loader, \t\t\t\t'css-loader', \t\t\t\t'postcss-loader' \t\t\t] \t\t}] \t}, \toptimization: { \t\tminimizer: [new OptimizeCSSAssetsPlugin({})] \t}, \tplugins: [ \t\tnew MiniCssExtractPlugin({ \t\t\tfilename: '[name].css', \t\t\tchunkFilename: '[name].chunk.css' \t\t}) \t], \toutput: { \t\tfilename: '[name].[contenthash].js', \t\tchunkFilename: '[name].[contenthash].js' \t} }  module.exports = prodConfig; ```  ---    ## 四：Webpack实战配置案例  ### Library的打包：库代码通过webpack进行打包  仓库源码 【[41](https://github.com/wudiufo/WebPack4-study/tree/master/library%2041)】  在 webpack.config.js 中：   ```js  const path = require('path');  module.exports = { \tmode: 'production', \tentry: './src/index.js', \texternals: 'lodash', \toutput: { \t\tpath: path.resolve(__dirname, 'dist'), \t\tfilename: 'library.js', \t\tlibrary: 'root', //支持通过<scritp src=ilibrary. js'><\/script> 标签引入，在全局变量增加一个root变量 \t\tlibraryTarget: 'umd' //别人用的时候，通过任何形式引入库都可以，比如AMD，CMD，ES MODULE，Commonjs                  // library: 'root',//打包生成全局变量root \t\t// libraryTarget: 'this' //把全局变量root挂载到this上，可以填umd，this，window,global                  // externals: {         // \tlodash:{         // \t\troot：'_', //是用script标签引入进来的，必须在全局注入一个 _ 变量，下面的library才能正常执行         // \t\tcommonjs:'lodash',//在用commonjs规范引入是，名字必须是lodash         // \t}          // }  \t} } ```  在 package.json 中：  ```json \"main\": \"./dist/library.js\", //最终要给别人使用的 ```  在 [npm](https://www.npmjs.com/)  官网注册一个账号，在命令行输入 ：  ```bash //添加用户名和密码 npm adduser  //把项目发布到npm官网上 npm publish //但别人用你发布的库时 npm i + 库名  ``` 详细请看官方文档：[externals](https://webpack.js.org/configuration/externals)   [author-libraries](https://webpack.js.org/guides/author-libraries)  ---  ### Progressive Web Application：在webpack中配置pwa  渐进式网络应用程序，PWA 可以用来做很多事。其中最重要的是，在**离线(offline)**时应用程序能够继续运行功能。这是通过使用名为 [Service Workers](https://developers.google.com/web/fundamentals/primers/service-workers/) 的 web 技术来实现的。线上环境时才用到pwa,开发时不需要  仓库源码 【[42](https://github.com/wudiufo/WebPack4-study/tree/master/lesson%2042)】  安装：  ```bash //模拟服务器 npm i http-server -D //添加 workbox-webpack-plugin 插件，然后调整 webpack.config.js 文件 npm install workbox-webpack-plugin --save-dev ```  在 package.json 中：  ```json \"scripts\": {  +   \"start\": \"http-server dist\",//在dist目录下运行http-server服务     \"dev\": \"webpack-dev-server --config ./build/webpack.dev.js\",     \"build\": \"webpack --config ./build/webpack.prod.js\"   }, ```  线上环境时才用到pwa,开发时不需要，只需要改 webpack.prod.js ，  在  webpack.prod.js 中：  ```js const WorkboxPlugin = require('workbox-webpack-plugin'); plugins: [ \t\tnew MiniCssExtractPlugin({ \t\t\tfilename: '[name].css', \t\t\tchunkFilename: '[name].chunk.css' \t\t}), +\t\tnew WorkboxPlugin.GenerateSW({ \t\t\tclientsClaim: true, \t\t\tskipWaiting: true \t\t}) \t], ```  在业务代码 index.js 中使用pwa  ```js console.log('hello, haiyang');  if ('serviceWorker' in navigator) { //如果浏览器支持serviceWorker，就执行以下代码 \twindow.addEventListener('load', () => { \t\tnavigator.serviceWorker.register('/service-worker.js') \t\t\t.then(registration => {//注册成功 \t\t\t\tconsole.log('service-worker registed'); \t\t\t}).catch(error => {//没注册成功 \t\t\t\tconsole.log('service-worker register error'); \t\t\t}) \t}) } ```    详细请看官方文档：[progressive-web-application](https://webpack.js.org/guides/progressive-web-application)   ---  ### TypeScript 的打包配置  [TypeScript](https://www.typescriptlang.org/) 是 JavaScript 的超集，为其增加了类型系统，可以编译为普通 JavaScript 代码。这篇指南里我们将会学习是如何将 webpack 和 TypeScript 进行集成。  仓库源码 【[43](https://github.com/wudiufo/WebPack4-study/tree/master/type-script)】  安装：  ```bash npm install --save-dev typescript ts-loader ```    在 webpack.config.js 中：  ```js const path = require('path');  module.exports = { \tmode: 'production', \tentry: './src/index.tsx', \tmodule: { \t\trules: [{ \t\t\ttest: /\\.tsx?$/, \t\t\tuse: 'ts-loader', \t\t\texclude: /node_modules/ \t\t}] \t}, \toutput: { \t\tfilename: 'bundle.js', \t\tpath: path.resolve(__dirname, 'dist') \t} } ```  在项目根目录下创建 tsconfig.json 文件：  ```json { \t\"compilerOpitons\": { \t\t\"outDir\": \"./dist\", \t\t\"module\": \"es6\",//模块引入的方式 \t\t\"target\": \"es5\",//转换为es5，在大部分浏览器都能运行 \t\t\"allowJs\": true, //在typescript中允许引入js文件 \t} } ```  在从 npm 安装 third party library(第三方库) 时，一定要记得同时安装此 library 的类型声明文件(typing definition)。你可以从 [TypeSearch](http://microsoft.github.io/TypeSearch/) 中找到并安装这些第三方库的类型声明文件。在使用时，哪有错可以有警告提示，方便改错。  安装：  ```bash //在typescript里用loadah npm install --save-dev @types/lodash ```    详细请看官方文档：[typescript](https://webpack.js.org/guides/typescript)  ---  ### 使用 WebpackDevServer 实现请求转发  仓库源码 【[44](https://github.com/wudiufo/WebPack4-study/tree/master/lesson%2044)】  安装：  ```bash //向服务器发送axios请求 npm i axios -D ```  在 index.js 中：  ```js componentDidMount() { \t\taxios.get('/react/api/header.json') \t\t\t.then((res) => { \t\t\t\tconsole.log(res); \t\t\t}) \t} ```    在 webpack.config.js 中：  ```js devServer: { \t\tcontentBase: './dist', \t\topen: true, \t\tport: 8080, \t\thot: true, \t\thotOnly: true, +\t\tproxy: {//开发时方便接口转发，线上不用 \t\t\t'/react/api': {//访问 /react/api 时，代理到 target 上 \t\t\t\ttarget: 'https://www.dell-lee.com', \t\t\t\tsecure: false,//对https协议的网址的请求的转发      //   拦截，请求的是html,不走代理直接返回  /index.html文件           \t//bypass: function(req, res, proxyOptions) {       //    if (req.headers.accept.indexOf('html') !== -1) {       //      console.log('Skipping proxy for browser request.');        //     return '/index.html';        //   }      //   }, \t\t\t\tpathRewrite: { \t\t\t\t\t'header.json': 'demo.json' //最后拿的是demo.json的数据 \t\t\t\t}, \t\t\t\tchangeOrigin: true,//解决网站对接口的限制 \t\t\t\theaders: {//变更请求头 \t\t\t\t\thost: 'www.dell-lee.com', \t\t\t\t} \t\t\t} \t\t} \t}, ```  详细请看官方文档：[devserverproxy](https://webpack.js.org/configuration/dev-server#devserverproxy)   ---  ###  WebpackDevServer 解决单页面应用路由问题  仓库源码 【[45](https://github.com/wudiufo/WebPack4-study/tree/master/lesson%2045)】  安装：  ```bash npm i react-router-dom --save ```  在 webpack.config.js 中：  ```js devServer: {//配置只在开发时有效，上线时后端也需配置 \t\tcontentBase: './dist', \t\topen: true, \t\tport: 8080, \t\thot: true, \t\thotOnly: true, +\t\thistoryApiFallback: true,     \t//historyApiFallback: {          // rewrites: [//访问任何路径都展示index.html页面           //  { from: /\\.*/, to: '/index.html' },           //]         //}, \t\tproxy: { \t\t\t'/react/api': { \t\t\t\ttarget: 'https://www.dell-lee.com', \t\t\t\tsecure: false, \t\t\t\tpathRewrite: { \t\t\t\t\t'header.json': 'demo.json' \t\t\t\t}, \t\t\t\tchangeOrigin: true, \t\t\t\theaders: { \t\t\t\t\thost: 'www.dell-lee.com', \t\t\t\t} \t\t\t} \t\t} \t}, ```  详细请看官方文档：[devserverhistoryapifallback](https://webpack.js.org/configuration/dev-server#devserverhistoryapifallback)   ---  ### EsLint 在 Webpack 中的配置  仓库源码 【[46](https://github.com/wudiufo/WebPack4-study/tree/master/lesson%2046)】  安装：  ```bash //安装eslint工具，规范项目中的代码 npm i eslint -D npm i babel-eslint -D npm i eslint-loader -D ```  ```bash //快速生成eslint配置 npx eslint --init ```  在 .eslintrc.js 中：  ```js module.exports = { \t\"extends\": \"airbnb\",   \"parser\": \"babel-eslint\",   \"rules\": {     \"react/prefer-stateless-function\": 0,     \"react/jsx-filename-extension\": 0   },   globals: {     document: false   } }; ```  详细请看官方文档：[eslint](https://eslint.cn/docs/user-guide/configuring)   在 vscode 编辑器里安装 eslint 插件，自动检测语法错误。（推荐使用）  在 webpack.config.js 中：  ```js devServer: { +\t\toverlay: true,//在浏览器弹出提示有错误 \t},   rules: [{  \t\t\ttest: /\\.js$/,  \t\t\texclude: /node_modules/,  \t+\t\tuse: ['babel-loader', 'eslint-loader'] //先检查代码写的是否规范，在转换成es5 \t\t},         ...], ```  在真实项目中，也可以不在webpack 中配置eslint，在提交git仓库时，git 钩子 eslint src 。但是没有图形交互式的错误提示。  详细请看官方文档：[eslint-loader](https://webpack.js.org/loaders/eslint-loader)  ---  ### 提升 webpack 打包速度的方法  仓库源码 【[47](https://github.com/wudiufo/WebPack4-study/tree/master/lesson%2047)】  #### 1.跟上技术的迭代（Node，Npm，Yarn）  #### 2.在尽可能少的模块上应用 Loader  #### 3.Plugin 尽可能精简并确保可靠  #### 4.resolve 参数合理配置     仓库源码 【[48](https://github.com/wudiufo/WebPack4-study/tree/master/lesson%2048)】  引入资源文件写后缀，像 图片文件（.jpg, .png, .svg），逻辑代码配置在extensions中:extensions: ['.js', '.jsx']  #### 5.使用 DLLPlugin 提高打包速度  详细请看官方文档：[dll-plugin](https://webpack.js.org/plugins/dll-plugin/#root)  仓库源码 【[49](https://github.com/wudiufo/WebPack4-study/tree/master/lesson%2049)】  实现第三方模块只打包一次  安装：  ```js npm i add-asset-html-webpack-plugin --save ```    在 build 文件夹里创建 webpack.dll.js 文件：把第三方模块单独进行打包，生成一个vendors.dll.js 文件，所有的第三方模块都在这个文件里。  ```js const path = require('path'); const webpack = require('webpack');  module.exports = { \tmode: 'production', \tentry: { \t\tvendors: ['lodash'], \t\treact: ['react', 'react-dom'], \t\tjquery: ['jquery'] \t}, \toutput: { \t\tfilename: '[name].dll.js', \t\tpath: path.resolve(__dirname, '../dll'), \t\tlibrary: '[name]'//打包生成的库名，通过全局变量的形式暴露到全局 \t}, \tplugins: [ \t\tnew webpack.DllPlugin({//对暴露到全局的代码进行分析，生成vendors.manifest.json 的映射文件， \t\t\tname: '[name]', \t\t\tpath: path.resolve(__dirname, '../dll/[name].manifest.json'), \t\t}) \t] } ```  在 webpack.common.js 中：  ```js const AddAssetHtmlWebpackPlugin = require('add-asset-html-webpack-plugin'); const files = fs.readdirSync(path.resolve(__dirname, '../dll')); files.forEach(file => { \tif(/.*\\.dll.js/.test(file)) { \t\tplugins.push(new AddAssetHtmlWebpackPlugin({//将打包好的dll文件挂载到html中 \t\t\tfilepath: path.resolve(__dirname, '../dll', file) \t\t})) \t} \tif(/.*\\.manifest.json/.test(file)) { \t\tplugins.push(new webpack.DllReferencePlugin({//分析第三方模块是否已经在dll文件里，如果里面有就不用再node_modules在分析打包了 \t\t\tmanifest: path.resolve(__dirname, '../dll', file) \t\t})) \t} }) ```  在 package.json 中 添加一个脚本： ``` \"scripts\": {     \"dev-build\": \"webpack --config ./build/webpack.dev.js\",     \"dev\": \"webpack-dev-server --config ./build/webpack.dev.js\",     \"build\": \"webpack --config ./build/webpack.prod.js\",  +   \"build:dll\": \"webpack --config ./build/webpack.dll.js\"   } ```  在 控制台 先 执行 npm run build:dll 生成对应的 XXX.dll.js 和 XXX.manifest.json 文件。以后再执行 npm run build 或 npm run dev 时，就不用再node_modules查找对应模块进行分析，直接用打包好的 XXX.dll.js就可以，节省打包速度。   总结：  > 如果不使用使用 DLLPlugin 插件，当引入第三方模块时，每一次打包都要进行分析，是消耗打包的性能的。使用 DLLPlugin 提高打包速度,在第一次打包时，把第三方模块单独打包生成一个文件 vendors.dll.js ，之后在打包时就可以直接从 vendors.dll.js 中引入之前打包好的第三方模块，速度就会变快。 > > 要想实现，就得做一些配置： > > 先配置 webpack.dll.js 文件，在配置 webpack.common.js 文件  ==============================================================  .dll 为后缀的文件称为动态链接库，在一个动态链接库中可以包含给其他模块调用的函数和数据  - 把基础模块独立出来打包到单独的动态连接库里 - 当需要导入的模块在动态连接库里的时候，模块不能再次被打包，而是去动态连接库里获取 [dll-plugin](https://webpack.js.org/plugins/dll-plugin/)  ### 定义Dll  - DllPlugin插件： 用于打包出一个个动态连接库 - DllReferencePlugin: 在配置文件中引入DllPlugin插件打包好的动态连接库  在 webpack.dll.js 中：  ```js module.exports = {     entry: {         react: ['react'] //react模块打包到一个动态连接库     },     output: {         path: path.resolve(__dirname, 'dist'),         filename: '[name].dll.js', //输出动态连接库的文件名称         library: '_dll_[name]' //全局变量名称     },     plugins: [         new webpack.DllPlugin({             name: '_dll_[name]', //和output.library中一致，值就是输出的manifest.json中的 name值             path: path.join(__dirname, 'dist', '[name].manifest.json')         })     ] } ```  ```bash webpack --config webpack.dll.config.js --mode production ```  ### 使用动态链接库文件   在 webpack.common.js 中：  ```js plugins: [ +        new webpack.DllReferencePlugin({ +            manifest: require(path.join(__dirname, 'dist', 'react.manifest.json')), +        })     ], ```  ```bash webpack --config webpack.config.js --mode development ```  ==============================================================  #### 6.控制包文件大小  配置 Tree shaking，把用不到的代码去除掉。配置 SplitChunksPlugin。  #### 7.thread-loader，parallel-webpack，happypack 多进程打包  ##### HappyPack  HappyPack就能让Webpack把任务分解给多个子进程去并发的执行，子进程处理完后再把结果发送给主进程。 [happypack](https://github.com/amireh/happypack)  安装：`npm i happypack@next -D`  配置：  ```js module: {         rules: [{             test: /\\.js$/,             //把对.js文件的处理转交给id为babel的HappyPack实例  +          use: 'happypack/loader?id=babel',             include: path.resolve(__dirname, 'src'),             exclude: /node_modules/         }, {             //把对.css文件的处理转交给id为css的HappyPack实例             test: /\\.css$/, +           use: 'happypack/loader?id=css',             include: path.resolve(__dirname, 'src')         }],         noParse: [/react\\.min\\.js/]     }, ```  ```js plugins: [         //用唯一的标识符id来代表当前的HappyPack是用来处理一类特定文件         new HappyPack({             id: 'babel',             //如何处理.js文件，和rules里的配置相同             loaders: [{                 loader: 'babel-loader',                 query: {                     presets: [                         \"env\", \"react\"                     ]                 }             }]         }),         new HappyPack({             id: 'css',             loaders: ['style-loader', 'css-loader'],             threads: 4, //代表开启几个子进程去处理这一类型的文件             verbose: true //是否允许输出日子         })     ], ```  ##### ParallelUglifyPlugin  `ParallelUglifyPlugin`可以把对JS文件的串行压缩变为开启多个子进程并行执行  安装：`npm i -D webpack-parallel-uglify-plugin`  配置：  ```js new ParallelUglifyPlugin({             workerCount: 3, //开启几个子进程去并发的执行压缩。默认是当前运行电脑的 CPU 核数减去1             uglifyJS: {                 output: {                     beautify: false, //不需要格式化                     comments: false, //不保留注释                 },                 compress: {                     warnings: false, // 在UglifyJs删除没有用到的代码时不输出警告                     drop_console: true, // 删除所有的 `console` 语句，可以兼容ie浏览器                     collapse_vars: true, // 内嵌定义了但是只用到一次的变量                     reduce_vars: true, // 提取出出现多次但是没有定义成变量去引用的静态值                 }             },         }) ```  #### 8.合理使用 sourceMap  #### 9.结合 stats 分析打包结果  #### 10. 开发环境内存编译  #### 11.开发环境无用插件剔除  ---  ### 多页面打包配置  配置多个 entry 里的 html 页面，用HtmlWebpackPlugin 插件，将打包好的j多个js分别插入到对应的html页面中。  仓库源码 【[410](https://github.com/wudiufo/WebPack4-study/tree/master/lesson%20410)】  在 webpack.common.js 中：  ```js const path = require('path'); const fs = require('fs'); const HtmlWebpackPlugin = require('html-webpack-plugin'); const CleanWebpackPlugin = require('clean-webpack-plugin'); const AddAssetHtmlWebpackPlugin = require('add-asset-html-webpack-plugin'); const webpack = require('webpack');   const makePlugins = (configs) => { \tconst plugins = [ \t\tnew CleanWebpackPlugin(['dist'], { \t\t\troot: path.resolve(__dirname, '../') \t\t}) \t]; \tObject.keys(configs.entry).forEach(item => { \t\tplugins.push( +\t\t\tnew HtmlWebpackPlugin({ \t\t\t\ttemplate: 'src/index.html', \t\t\t\tfilename: `${item}.html`, \t\t\t\tchunks: ['runtime', 'vendors', item] \t\t\t}) \t\t) \t}); \tconst files = fs.readdirSync(path.resolve(__dirname, '../dll')); \tfiles.forEach(file => { \t\tif(/.*\\.dll.js/.test(file)) { \t\t\tplugins.push(new AddAssetHtmlWebpackPlugin({ \t\t\t\tfilepath: path.resolve(__dirname, '../dll', file) \t\t\t})) \t\t} \t\tif(/.*\\.manifest.json/.test(file)) { \t\t\tplugins.push(new webpack.DllReferencePlugin({ \t\t\t\tmanifest: path.resolve(__dirname, '../dll', file) \t\t\t})) \t\t} \t}); \treturn plugins; }  const configs = { +\tentry: { \t\tindex: './src/index.js', \t\tlist: './src/list.js', \t\tdetail: './src/detail.js', \t}, \tresolve: { \t\textensions: ['.js', '.jsx'], \t}, \tmodule: { \t\trules: [{  \t\t\ttest: /\\.jsx?$/,  \t\t\tinclude: path.resolve(__dirname, '../src'), \t\t\tuse: [{ \t\t\t\tloader: 'babel-loader' \t\t\t}] \t\t}, { \t\t\ttest: /\\.(jpg|png|gif)$/, \t\t\tuse: { \t\t\t\tloader: 'url-loader', \t\t\t\toptions: { \t\t\t\t\tname: '[name]_[hash].[ext]', \t\t\t\t\toutputPath: 'images/', \t\t\t\t\tlimit: 10240 \t\t\t\t} \t\t\t}  \t\t}, { \t\t\ttest: /\\.(eot|ttf|svg)$/, \t\t\tuse: { \t\t\t\tloader: 'file-loader' \t\t\t}  \t\t}] \t}, \toptimization: { \t\truntimeChunk: { \t\t\tname: 'runtime' \t\t}, \t\tusedExports: true, \t\tsplitChunks: {       chunks: 'all',       cacheGroups: {       \tvendors: {       \t\ttest: /[\\\\/]node_modules[\\\\/]/,       \t\tpriority: -10,       \t\tname: 'vendors',       \t}       }     } \t}, \tperformance: false, \toutput: { \t\tpath: path.resolve(__dirname, '../dist') \t} }  configs.plugins = makePlugins(configs);  module.exports = configs ```      ## 五：Webpack底层原理及脚手架工具分析  ###  如何编写一个 Loader  仓库源码 【[51](https://github.com/wudiufo/WebPack4-study/tree/master/make-loader%2051)】  ```bash mkdir make-loader cd make-loader npm init -y npm i webpack webpack-cli -D npm i loader-utils -D ```  在根目录下创建文件夹loaders，里面创建自己定义的loader.js文件  在 webpack.config.js 中：  ```js const path = require('path');  module.exports = { \tmode: 'development', \tentry: { \t\tmain: './src/index.js' \t}, \tresolveLoader: { //先在 node_modules 中找用到的loader，如果没找到，再在loaders里查找 \t\tmodules: ['node_modules', './loaders'] \t}, \tmodule: { \t\trules: [{ \t\t\ttest: /\\.js/, \t\t\tuse: [//使用自己写的replaceLoader \t\t\t\t{ \t\t\t\t\tloader: 'replaceLoader', \t\t\t\t}, \t\t\t\t{ \t\t\t\t\tloader: 'replaceLoaderAsync', \t\t\t\t\toptions: { \t\t\t\t\t\tname: 'lee' \t\t\t\t\t} \t\t\t\t}, \t\t\t] \t\t}] \t}, \toutput: { \t\tpath: path.resolve(__dirname, 'dist'), \t\tfilename: '[name].js' \t} } ```  详细请看官方文档：[loaders#thisquery](https://webpack.js.org/api/loaders#thisquery)  [hiscallback](https://webpack.js.org/api/loaders#thiscallback)  [thisasync](https://webpack.js.org/api/loaders#thisasync)   ---  ###  如何编写一个 Plugin  仓库源码 【[52](https://github.com/wudiufo/WebPack4-study/tree/master/plugin%2052)】    详细请看官方文档：[compiler-hooks](https://webpack.js.org/api/compiler-hooks)   ---  ### Bundler 源码编写（模块分析）  **应对 webpack 原理面试必备：**  仓库源码 【[53](https://github.com/wudiufo/WebPack4-study/tree/master/bundler%2053)】  安装 ：  ```bash //高亮显示代码的工具 npm i cli-highlight -g //分析源代码 npm install @babel/parser --save npm install @babel/core --save npm install @babel/traverse --save npm install @babel/preset-env --save ```  ---  ### Bundler 源码编写（Dependencies Graph）  仓库源码 【[54](https://github.com/wudiufo/WebPack4-study/tree/master/bundler%2054)】  ---  ### Bundler 源码编写（生成代码）  仓库源码 【[55](https://github.com/wudiufo/WebPack4-study/tree/master/bundler%2055)】    ## 六：Create-React-App 和 Vue-Cli 3.0脚手架工具配置分析  ### 通过CreateReactApp深入学习Webpack配置  仓库源码 【[56](https://github.com/wudiufo/WebPack4-study/tree/master/my-app56)】  详细请看官方文档：[CreateReactApp](https://facebook.github.io/create-react-app/docs/getting-started)   快速开始：  ```bash npx create-react-app my-app cd my-app npm start ```  把隐藏的配置项展现出来：不可逆操作  ```bash npm run eject ```  就会多出来两个文件夹，config，scripts文件夹  ---  ### Vue-Cli 3.0  仓库源码 【[57](https://github.com/wudiufo/WebPack4-study/tree/master/my-project57)】  详细请看官网：[VUE Cli](https://cli.vuejs.org/zh/guide/#cli)  [全局-cli-配置](https://cli.vuejs.org/zh/config/#全局-cli-配置) "},{title:"javascript 设计模式之设计原则",path:"/posts/javascript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99.html",strippedContent:" 设计模式应该是从设计到模式，设计原则是模式的理念，知道设计原则才能更好的掌握设计模式。    ## 设计原则    ### <code>SOLID</code> 五大设计原则    1. <code>S</code>-**单一职责原则**：一个程序只做好一件事，如果功能过于复杂就拆分开，每个部分保持独立  1. <code>O</code>-**开放封闭原则**：对扩展开放，对修改封闭，增加需求时，扩展新代码，而非修改已有代码，这是软件设计的终极目标  1. <code>L</code>-**李氏置换原则**：子类能覆盖父类，父类能出现的地方子类就能出现，JS 中使用较少（弱类型&继承使用较少）  1. <code>I</code>-**接口独立原则**：保持接口的单一独立，避免出现“胖接口”，JS 中没有接口（typescript 例外），使用较少类似于单一职责原则，这里更关注接口  1. <code>D</code>-**依赖导致原则**：面向接口编程，依赖于抽象而不依赖于具体，使用方只关注接口而不关注具体类的实现，JS 中使用较少（没有接口&弱类型）     \x3c!-- more --\x3e    ### 面试题考察    #### 打车    ##### 问题    - 打车时，可以打专车或者快车。任何车都有车牌号和名称。  - 不同车价格不同，快车每公里 1 元，专车每公里 2 元。  - 行程开始时，显示车辆信息  - 行程结束时，显示打车金额（假定行程就 5 公里）    ##### UML 类图    ![打车问题UML类图](https://s2.ax1x.com/2019/05/30/VKqhRA.jpg)    ##### 代码实现    ```js  class Car {    constructor(number, name) {      this.number = number;      this.name = name;    }  }  class Kuaiche extends Car {    constructor(number, name) {      super(number, name);      this.price = 1;    }  }  class Zhuanche extends Car {    constructor(number, name) {      super(number, name);      this.price = 2;    }  }    class Trip {    constructor(car) {      this.car = car;    }    start() {      console.log(`行程开始，名称: ${this.car.name}, 车牌号: ${this.car.price}`);    }    end() {      console.log('行程结束，价格: ' + this.car.price * 5);    }  }    let car = new Kuaiche(100, '桑塔纳');  let trip = new Trip(car);  trip.start();  trip.end();  ```    #### 停车场    ##### 问题    - 某停车场，分 3 层，每层 100 车位  - 每个车位都能监控到车辆的驶入和离开  - 车辆进入前，显示每层的空余车位数量  - 车辆进入时，摄像头可识别车牌号和时间  - 车辆出来时，出口显示器显示车牌号和停车时长    ##### UML 类图    ![停车场UML类图](https://s2.ax1x.com/2019/05/30/VKjdw6.jpg)    ##### 代码实现    ```js  // 车  class Car {    constructor(num) {      this.num = num;    }  }    // 入口摄像头  class Camera {    shot(car) {      return {        num: car.num,        inTime: Date.now(),      };    }  }    // 出口显示器  class Screen {    show(car, inTime) {      console.log('车牌号', car.num);      console.log('停车时间', Date.now() - inTime);    }  }    // 停车场  class Park {    constructor(floors) {      this.floors = floors || [];      this.camera = new Camera();      this.screen = new Screen();      this.carList = {};    }    in(car) {      // 获取摄像头的信息：号码 时间      const info = this.camera.shot(car);      // 停到某个车位      const i = parseInt((Math.random() * 100) % 100);      const place = this.floors[0].places[i];      place.in();      info.place = place;      // 记录信息      this.carList[car.num] = info;    }    out(car) {      // 获取信息      const info = this.carList[car.num];      const place = info.place;      place.out();        // 显示时间      this.screen.show(car, info.inTime);        // 删除信息存储      delete this.carList[car.num];    }    emptyNum() {      return this.floors        .map(floor => {          return `${floor.index} 层还有 ${floor.emptyPlaceNum()} 个车位`;        })        .join('\\n');    }  }    // 层  class Floor {    constructor(index, places) {      this.index = index;      this.places = places || [];    }    emptyPlaceNum() {      let num = 0;      this.places.forEach(p => {        if (p.empty) {          num = num + 1;        }      });      return num;    }  }    // 车位  class Place {    constructor() {      this.empty = true;    }    in() {      this.empty = false;    }    out() {      this.empty = true;    }  }    // 测试代码------------------------------  // 初始化停车场  const floors = [];  for (let i = 0; i < 3; i++) {    const places = [];    for (let j = 0; j < 100; j++) {      places[j] = new Place();    }    floors[i] = new Floor(i + 1, places);  }  const park = new Park(floors);    // 初始化车辆  const car1 = new Car('A1');  const car2 = new Car('A2');  const car3 = new Car('A3');    console.log('第一辆车进入');  console.log(park.emptyNum());  park.in(car1);  console.log('第二辆车进入');  console.log(park.emptyNum());  park.in(car2);  console.log('第一辆车离开');  park.out(car1);  console.log('第二辆车离开');  park.out(car2);    console.log('第三辆车进入');  console.log(park.emptyNum());  park.in(car3);  console.log('第三辆车离开');  park.out(car3);  ```  "},{title:"js固化对象",path:"/posts/js%E5%9B%BA%E5%8C%96%E5%AF%B9%E8%B1%A1.html",strippedContent:" 在框架封装，继承的时候，如果你做好了一个对象给别人使用，为了不让使用者拿过来后任意涂改，比如他把你的对象的一个方法改成了指向另一个函数，或者干脆删除了这个方法，我们需要把这个对象固化。    在 <code>JavaScript</code>里我们可以在三个层级上固化一个对象。从宽到严它们依次是：防止扩展、密封、冻结。    \x3c!-- more --\x3e    ![js固化对象](https://s2.ax1x.com/2019/05/28/VnF0SS.png)  "},{title:"面试题自问自答-JS变量声明和类型",path:"/posts/%E9%9D%A2%E8%AF%95%E9%A2%98%E8%87%AA%E9%97%AE%E8%87%AA%E7%AD%94-JS%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%E5%92%8C%E7%B1%BB%E5%9E%8B.html",strippedContent:" ## 用<code>let</code>，<code>const</code>和用<code>var</code>来声明变量的区别    1. <code>var</code>    - 不区分变量和常量  - 允许重新声明  - 存在变量提升  - 没有块级作用域  - 是顶层对象的属性    2. <code>let</code>，<code>const</code>    - 暂时性死区  - 不允许重复声明  - 块级作用域  - 不是顶层对象的属性  - <code>const</code>变量指向的那个内存地址所保存的数据不得改动    ## 介绍 js 的数据类型    JS 中分为七种内置类型，七种内置类型又分为两大类型：基本类型和引用类型。    基本类型有六种： <code>null</code>，<code>undefined</code>，<code>boolean</code>，<code>number</code>，<code>string</code>，<code>symbol</code>。    javascript 中除了上面的基本类型之外就是引用类型（对象、数组和函数）。    ## 基本数据类型和引⽤类型的区别    原始数据类型直接存储在栈(stack)中，占据空间小、大小固定（不可变）；    引用数据类型存储在堆(heap)中，占据空间大、大小不固定（可变）；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。    它们不同的表现主要体现在判断变量是否相等和变量值引用两方面，比如：    ```js  //判断变量是否相等    //基本数据类型  const a = 'hello';  const b = 'hello';  a === b; //true    //引用数据类型  const c = { a: 'hello' };  const d = { a: 'hello' };  c === d; //false  ```    ```js  //变量值引用    //引用数据类型  let a = { a: { b: 'hello' } };  let b = a;  b.a = 'hi';  a.a; //'hi'  ```    ## 深浅拷贝的方法    1. 浅拷贝    <code>Object.assign</code>，运算符 <code>...</code>    2. 深拷贝    <code>JSON.parse(JSON.stringify(object))</code>    但是该方法也是有局限性的：    - 会忽略 undefined  - 会忽略 symbol  - 不能序列化函数  - 不能解决循环引用的对象    如果你所需拷贝的对象含有内置类型并且不包含函数，可以使用 <code>MessageChannel</code>    ```js  function structuralClone(obj) {    return new Promise(resolve => {      const { port1, port2 } = new MessageChannel();      port2.onmessage = ev => resolve(ev.data);      port1.postMessage(obj);    });  }    var obj = {    a: 1,    b: {      c: 2    }  };    obj.b.d = obj.b;    // 注意该方法是异步的  // 可以处理 undefined 和循环引用对象  const test = async () => {    const clone = await structuralClone(obj);    console.log(clone);  };  test();  ```    最后一个简单的深拷贝函数    ```js  function deepClone(obj) {    function isObject(o) {      return (        (typeof o === 'object' || typeof o === 'function') &&        o !== null      );    }      if (!isObject(obj)) {      throw new Error('非对象');    }      let isArray = Array.isArray(obj);    let newObj = isArray ? [...obj] : { ...obj };    Reflect.ownKeys(newObj).forEach(key => {      newObj[key] = isObject(obj[key])        ? deepClone(obj[key])        : obj[key];    });      return newObj;  }  ```    ## 基本数据类型既然不是对象，为什么它会有属性和方法呢？，比如 <code>'hello'.length</code>,<code>'hi'.slice(0, 1)</code>    除了 <code>null</code> 和 <code>undefined</code>之外，所有基本类型都有其对应的包装对象，例如：    只要引用了字符串 's' 的属性，JavaScript 就会将字符串值通过调用<code> new String('s')</code>的方式转换成对象，这个对象继承了字符串的方法并被用来处理属性的引用。一旦属性引用结束，这个新创建的对象就会销毁（其实在实现上并不一定创建或销毁这个临时对象，然而整个过程看起来是这样）。<code>null</code> 和 <code>undefined</code> 没有包装对象：访问它们的属性会造成一个类型错误。    在读取字符串、数字和布尔值的属性值（或方法）的时候，表现的像对象一样。但如果你试图给其属性赋值，则会表现得不如你所愿：修改只是发生在临时对象身上，而这个临时对象并未继续保留下来。    ```js  const s = 'test'; //创建一个字符串  s.len = 4; //给它设置一个属性  const t = s.len; //查询这个属性undefined  ```    ## <code>null</code> 和 <code>undefined</code> 的区别    <code>undefined</code>是声明了但未赋值，<code>null</code>是声明了并且赋值为空值    ## 如何判断变量的类型    1. <code>typeof</code>    对于基本数据类型来说，<code>typeof</code> 除了 <code>null</code> 都可以显示正确的类型    ```js  typeof 1; // 'number'  typeof '1'; // 'string'  typeof undefined; // 'undefined'  typeof true; // 'boolean'  typeof Symbol(); // 'symbol'  typeof b; //  undefined  ```    对于引用类型来说，<code>typeof</code> 除了函数都会显示 <code>object</code>    ```js  typeof []; // 'object'  typeof {}; // 'object'  typeof console.log; // 'function'  ```    2. <code>instanceof</code>    对于引用类型来说，可以考虑使用<code>instanceof</code>，因为内部机制是通过判断对象的原型链中是不是能找到类型的 <code>prototype</code>。    ```js  const Person = function() {};  const p1 = new Person();  p1 instanceof Person; // true    var str = 'hello world';  str instanceof String; // false    var str1 = new String('hello world');  str1 instanceof String; // true  ```    对于基本类型来说，你想直接通过 <code>instanceof</code> 来判断类型是不行的，当然我们还是有办法让 <code>instanceof</code> 判断原始类型的    ```js  class PrimitiveString {    static [Symbol.hasInstance](x) {      return typeof x === 'string';    }  }  console.log('hello world' instanceof PrimitiveString); // true  ```    这其实也侧面反映了一个问题， instanceof 也不是百分之百可信的。    3. <code>Object.prototype.toString.call(xx).slice(8, -1)</code>    对于任何变量都可以通过 <code>Object.prototype.toString.call(xx)</code>获得一个正确的类型,通过它我们可以获得一个类似 [object Type] 的字符串。    ```js  Object.prototype.toString.call('').slice(8, -1); //\"String\"  ```    ## 模拟实现<code>instanceof</code>    ```js  function instanceof(left, right) {      // 获得类型的原型      let right = right.prototype      // 获得对象的原型      left = left.__proto__      // 判断对象的类型是否等于类型的原型      while (true) {      \tif (left === null)      \t\treturn false      \tif (right === left)      \t\treturn true      \tleft = left.__proto__      }  }  ```    ## == 的比较规则    1. 首先会判断两者类型是否相同。相同的话就是比大小了  2. 类型不相同的话，那么就会进行类型转换  3. 会先判断是否在对比 <code>null</code> 和 <code>undefined</code>，是的话就会返回 <code>true</code>  4. 判断两者类型是否为 <code>string</code> 和 <code>number</code>，是的话就会将字符串转换为 <code>number</code>    ```js  1 == '1'        ↓  1 ==  1  ```    5. 判断其中一方是否为 <code>boolean</code>，是的话就会把 <code>boolean</code> 转为 <code>number</code> 再进行判断    ```js  '1' == true          ↓  '1' ==  1          ↓   1  ==  1  ```    6. 判断其中一方是否为 <code>object</code> 且另一方为 <code>string</code>、<code>number</code> 或者 <code>symbol</code>，是的话就会把 <code>object</code> 转为原始类型再进行判断    ```js  '1' == { name: 'yck' }          ↓  '1' == '[object Object]'  ```    详细完整流程如下：  ![== 的比较规则](https://s2.ax1x.com/2019/04/13/AqWD8s.png)    ## <code>\\=\\=</code> 和 <code>\\=\\=\\=</code>区别，什么时候用 <code>\\=\\=</code> 或 <code>\\===</code>    区别：前者会进行类型转换，后者不会。    使用：除了下面情况其他全部用 <code>===</code>    ```js  if (a == null) {    // 这里相当于 a === null || a === undefined, 简写形式    // 这是 jQuery 源码中推荐的写法  }  ```    ## 类型转换    在 JS 中类型转换只有三种情况，分别是：    - 转换为布尔值  - 转换为数字  - 转换为字符串    1. 转<code>Boolean</code>    在条件判断时，除了 <code>undefined</code>， <code>null</code>， <code>false</code>， <code>NaN</code>， <code>''</code>， <code>0</code>， <code>-0</code>，其他所有值都转为 <code>true</code>，包括所有对象。    2. 对象转原始类型    对象在转换类型的时候，会调用内置的<code>[[ToPrimitive]]</code>函数，对于该函数来说，算法逻辑一般来说如下：    - 如果已经是原始类型了，那就不需要转换了  - 调用 <code>x.valueOf()</code>，如果转换为基础类型，就返回转换的值  - 调用 <code>x.toString()</code>，如果转换为基础类型，就返回转换的值  - 如果都没有返回原始类型，就会报错  - 可以重写 <code>Symbol.toPrimitive</code> ，该方法在转原始类型时调用优先级最高。    ```js  let a = {    valueOf() {      return 0;    },    toString() {      return '1';    },    [Symbol.toPrimitive]() {      return 2;    }  };  1 + a; // => 3  ```  "},{title:"footer布局，粘连布局",path:"/posts/footer%E5%B8%83%E5%B1%80%EF%BC%8C%E7%B2%98%E8%BF%9E%E5%B8%83%E5%B1%80.html",strippedContent:' ## 要求  此博客就是使用此布局方法的，在内容区有空时，底部 footer 在窗口底部，填满时自动被挤下去  参考饿了么的商店详情,文字少时,footer 在详情底下,多时在页面底部,文字超出页面时,文字隐藏在 footer 底下,往下拉文字 footer 不变,文字往上升  ## 实现方法  1. html,body{height: 100%;} 2. #wrap{min-height: 100%;overflow: hidden;} 3. #footer{height: 50px;margin-top: -50px;} 4. #wrap .main{padding-bottom:50px ;}  ```html <div id="wrap">   <div class="main">     main <br />     main <br />     main <br />   </div> </div> <div id="footer">   footer </div> ``` '},{title:"三列布局方法汇总",path:"/posts/%E4%B8%89%E5%88%97%E5%B8%83%E5%B1%80%E6%96%B9%E6%B3%95%E6%B1%87%E6%80%BB.html",strippedContent:' ## 要求  1. 两边固定宽度,当中宽度自适应 2. 当中列要完整(显示 body 给个最小宽度) 3. 当中列要优先加载(中间列在 HTML 前面)  ```html <div id="middle">middle</div> <div id="left">left</div> <div id="right">right</div> ```  ## 方法  ### 定位  ```css * {   margin: 0;   padding: 0; } body {   /*2*left+right,既是中间列至少给个left或right的值*/   min-width: 600px;   position: relative; } div {   height: 100px; } #left, #right {   width: 200px;   background: pink; } #middle {   background: deeppink;   padding: 0 200px; } #left {   position: absolute;   left: 0;   top: 0; } #right {   position: absolute;   right: 0;   top: 0; } ```  body 一定要设置 position: relative,  缺点:  - 绝对定位脱离标准文档流,对以后的布局不好, - 必须有个容器,加上相对定位, - 提升层级,对以后我们布局带来极大的困扰  ### 浮动(当中列不能优先加载)  ```css * {   margin: 0;   padding: 0; } body {   /*2*left+right*/   min-width: 600px; } div {   height: 100px; } #left, #right {   width: 200px;   background: pink; } #left {   float: left; } #right {   float: right; } #middle {   background: deeppink; } ```  浮动提升半级,把 middle 文字顶过去. 缺点:  - 脱离标准文档流,对以后的布局不好, - 当中列不能优先加载  ### 圣杯布局  ```css * {   margin: 0;   padding: 0; } body {   min-width: 600px; } #content {   padding: 0 200px; } #content .middle {   float: left;   width: 100%;   background: pink;   /*padding: 0 200px;*/ } #content .left {   position: relative;   left: -200px;   margin-left: -100%;   float: left;   width: 200px;   background: yellow; } #content .right {   position: relative;   right: -200px;   margin-left: -200px;   float: left;   width: 200px;   background: yellow; } .clearfix {   *zoom: 1; } .clearfix:after {   content: \'\';   display: block;   clear: both; } ```  ```html <div id="content" class="clearfix">   <div class="middle">     <h4>middle</h4>   </div>   <div class="left">left</div>   <div class="right">right</div> </div> ```  步骤:  1. #middle{float: left;width: 100%;} 2. #left 和#right{float: left;width: 200px;} 3. #left{margin-left: -100%;}和#right{margin-left: -200px;} 4. body{min-width: 600px;} 5. #content{padding: 0 200px;} 6. #left{position: relative;left: -200px}和#right{position: relative;right: -200px}  缺点:  - 脱离标准文档流,对以后的布局不好, - 中间列高度越来越高时,左右列高度不会一起增高,三列高度不一致,UI 丑  ### 伪等高布局  步骤:  1. #content{overflow: hidden;} 2. #content #middl,#content #left,#content #right{padding-bottom: 10000px;margin-bottom: -10000px;} 3. 其他步骤和圣杯布局相同  ### 双飞翼布局  ```html <div id="content">   <div class="middle">     <div class="m_inner">       middle     </div>   </div>   <div class="left">left</div>   <div class="right">right</div> </div> ```  步骤:  1. 1.2.3.4.和圣杯相同 2. 5.#content .middle .m_inner{padding: 0 200px;}    缺点,布局用到定位 3. 三列的伪等高布局  ```css #content .middle, #content .left, #content .right {   /*padding-bottom:10000px ; \t\tmargin-bottom: -10000px;*/   height: 50px;   line-height: 50px;   float: left; } ```  缺点,高度写死  ### flex  ```css body {   min-width: 600px; } #content {   overflow: hidden;   display: flex; } #content .middle, #content .left, #content .right {   padding-bottom: 10000px;   margin-bottom: -10000px; }  #content .middle {   width: 100%;   background: pink;   order: 2;   flex-shrink: 1;   word-break: break-all; }  #content .left {   order: 1;   width: 200px;   background: yellow;   flex-shrink: 0;   order: 1; }  #content .right {   width: 200px;   background: yellow;   flex-shrink: 0;   order: 3; } ```  完美!!!  ### Grid  ```html <!DOCTYPE html> <html lang="en">   <head>     <meta charset="UTF-8" />     <title>Document</title>   </head>    <body>     <section class="layout grid">       <style>         .layout.grid .left-center-right {           display: grid;           width: 100%;           grid-template-rows: auto;           grid-template-columns: 300px auto 300px;           grid-template-areas: \'left center right\';         }          .layout.grid .left {           background: red;           grid-area: left;         }          .layout.grid .center {           background: yellow;           grid-area: center;         }          .layout.grid .right {           background: blue;           grid-area: right;         }       </style>       <article class="left-center-right">         <div class="center">           <h1>grid</h1>         </div>         <div class="left"></div>         <div class="right"></div>       </article>     </section>   </body> </html> ```  兼容性不好  ### table(当中列不能优先加载)  不能实现中间列优先加载  ```html <!DOCTYPE html> <html lang="en">   <head>     <meta charset="UTF-8" />     <title>Document</title>   </head>    <body>     <section class="layout table">       <style>         .layout.table .left-center-right {           width: 100%;           display: table;         }          .layout.table .left-center-right > div {           display: table-cell;         }          .layout.table .left {           width: 300px;           background: red;         }          .layout.table .center {           background: yellow;         }          .layout.table .right {           width: 300px;           background: blue;         }       </style>       <article class="left-center-right">         <div class="left"></div>         <div class="center">           <h1>table</h1>         </div>         <div class="right"></div>       </article>     </section>   </body> </html> ``` '},{title:"将一个多维数组彻底的降维",path:"/posts/%E5%B0%86%E4%B8%80%E4%B8%AA%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84%E5%BD%BB%E5%BA%95%E7%9A%84%E9%99%8D%E7%BB%B4.html",strippedContent:" 看到一个很简洁的工具函数,记录一下,  如果想将一个多维数组彻底的降维，可以这样实现:  ```js const flattenDeep = arr =>   Array.isArray(arr)     ? arr.reduce((a, b) => [...a, ...flattenDeep(b)], [])     : [arr]; ``` "},{title:"CORS详解笔记",path:"/posts/CORS%E8%AF%A6%E8%A7%A3%E7%AC%94%E8%AE%B0.html",strippedContent:' 学习自[跨域资源共享 CORS 详解](http://www.ruanyifeng.com/blog/2016/04/cors.html),自用!  ## 简介  CORS 是一个 W3C 标准，全称是"跨域资源共享"（Cross-origin resource sharing）。  CORS 需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE 浏览器不能低于 IE10。  浏览器将 CORS 请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。  ## 如何区分  只要同时满足以下两大条件，就属于简单请求。凡是不同时满足上面两个条件，就属于非简单请求。 （1) 请求方法是以下三种方法之一：  - HEAD - GET - POST  （2）HTTP 的头信息不超出以下几种字段：  - Accept - Accept-Language - Content-Language - Last-Event-ID - Content-Type：只限于三个值 application/x-www-form-urlencoded、multipart/form-data、text/plain  ## 简单请求（simple request）  ### 基本流程  对于简单请求，浏览器直接发出 CORS 请求。具体来说，就是在头信息之中，增加一个 Origin 字段。服务器根据这个值，决定是否同意这次请求。  ```js GET /cors HTTP/1.1 Origin: http://api.bob.com Host: api.alice.com Accept-Language: en-US Connection: keep-alive User-Agent: Mozilla/5.0... ```  如果 Origin 指定的源，不在许可范围内，服务器会返回一个正常的 HTTP 回应。浏览器发现，这个回应的头信息没有包含 Access-Control-Allow-Origin 字段（详见下文），就知道出错了，从而抛出一个错误，被 XMLHttpRequest 的 onerror 回调函数捕获。注意，这种错误无法通过状态码识别，因为 HTTP 回应的状态码有可能是 200。  如果 Origin 指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。  ```js Access-Control-Allow-Origin: http://api.bob.com Access-Control-Allow-Credentials: true Access-Control-Expose-Headers: FooBar Content-Type: text/html; charset=utf-8 ```  ### Access-Control-Allow-Origin  该字段是必须的。它的值要么是请求时 Origin 字段的值，要么是一个\\*，表示接受任意域名的请求。  ### Access-Control-Allow-Credentials  该字段可选。它的值是一个布尔值，表示是否允许发送 Cookie。默认情况下，Cookie 不包括在 CORS 请求之中。设为 true，即表示服务器明确许可，Cookie 可以包含在请求中，一起发给服务器。这个值也只能设为 true，如果服务器不要浏览器发送 Cookie，删除该字段即可。  ### Access-Control-Expose-Headers  该字段可选。CORS 请求时，XMLHttpRequest 对象的 getResponseHeader()方法只能拿到 6 个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在 Access-Control-Expose-Headers 里面指定。上面的例子指定，getResponseHeader(\'FooBar\')可以返回 FooBar 字段的值。  ### withCredentials  如果要把 Cookie 发到服务器，一方面要服务器同意，指定 Access-Control-Allow-Credentials 字段。另一方面，开发者必须在 AJAX 请求中打开 withCredentials 属性。  ```js var xhr = new XMLHttpRequest(); xhr.withCredentials = true; ```  需要注意的是，如果要发送 Cookie，Access-Control-Allow-Origin 就不能设为星号，必须指定明确的、与请求网页一致的域名。同时，Cookie 依然遵循同源政策，只有用服务器域名设置的 Cookie 才会上传，其他域名的 Cookie 并不会上传，且（跨源）原网页代码中的 document.cookie 也无法读取服务器域名下的 Cookie。  ## 非简单请求  ### 预检请求  "预检"请求用的请求方法是 OPTIONS，表示这个请求是用来询问的。  非简单请求的 CORS 请求，会在正式通信之前，增加一次 HTTP 查询请求，称为"预检"请求（preflight）。  浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些 HTTP 动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的 XMLHttpRequest 请求，否则就报错。  ### Access-Control-Request-Method  该字段是必须的，用来列出浏览器的 CORS 请求会用到哪些 HTTP 方法，上例是 PUT。  ### Access-Control-Request-Headers  该字段是一个逗号分隔的字符串，指定浏览器 CORS 请求会额外发送的头信息字段，上例是 X-Custom-Header。  ### 预检请求的回应  如果浏览器否定了"预检"请求，会返回一个正常的 HTTP 回应，但是没有任何 CORS 相关的头信息字段。这时，浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被 XMLHttpRequest 对象的 onerror 回调函数捕获。控制台会打印出如下的报错信息。  ```js XMLHttpRequest cannot load http://api.alice.com. Origin http://api.bob.com is not allowed by Access-Control-Allow-Origin. ```  ### Access-Control-Allow-Methods  该字段必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次"预检"请求。  ### Access-Control-Allow-Headers  如果浏览器请求包括 Access-Control-Request-Headers 字段，则 Access-Control-Allow-Headers 字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在"预检"中请求的字段。  ### Access-Control-Max-Age  该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是 20 天（1728000 秒），即允许缓存该条回应 1728000 秒（即 20 天），在此期间，不用发出另一条预检请求。 '},{title:"AJAX详解笔记",path:"/posts/AJAX%E8%AF%A6%E8%A7%A3%E7%AC%94%E8%AE%B0.html",strippedContent:" [学习参考文章:再也不学 AJAX 了！（二）使用 AJAX](https://segmentfault.com/a/1200000012237477),自用!  ## Ajax 简介  > Ajax 即“Asynchronous Javascript And XML”（异步 JavaScript 和 XML）。  > Ajax 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。  ajax 并非一种新的技术，而是几种原有技术的结合体。它由下列技术组合而成。  - 使用 CSS 和 XHTML 来表示。 - 使用 DOM 模型来交互和动态显示。 - 使用 XMLHttpRequest 来和服务器进行异步通信。 - 使用 javascript 来绑定和调用。  ## Ajax 优缺点  ### Ajax 的优点  - 页面无刷新更新数据 - 异步与服务器通信,不需要打断用户的操作 - 按需取数据，减少服务器的负担 - AJAX 基于标准化的并被广泛支持的技术，不需要下载浏览器插件或者小程序，只需要客户允许 JavaScript 在浏览器上执行 - 浏览器的内容和服务端代码进行分离。页面的内容全部由 JAVAScript 来控制，服务端负责逻辑的校验和从数据库中拿数据。  ### Ajax 缺点  - 安全问题：将服务端的方法暴露出来，黑客可利用这一点进行攻击 - AjAX 干掉了 Back 后退和加入收藏书签功能，即对浏览器机制的破坏。 - Ajax 的无刷新重载，由于页面的变化没有刷新重载那么明显，所以容易给用户带来困扰——用户不太清楚现在的数据是新的还是已经更新过的；通常的解决方案是，使用一个可视化的组件来告诉用户系统正在进行后台操作并且正在读取数据和内容  ## XMLHttpRequest 对象  ### 简介  为了使用 JavaScript 向服务器发出 HTTP 请求，需要一个提供此功能的类的实例。这就是 XMLHttpRequest 的由来。显而易见 XMLHttpRequest 类是 AJAX 技术的核心。  XMLHttpRequest 只是一个 JavaScript 对象，确切的说，是一个构造函数。它是由浏览器提供的,而不是 JavaScript 原生的，除此之外，它有属性，有方法，需要通过 new 关键字进行实例化  ``` const xhr = new XMLHttpRequest() ```  ### 方法  - .open()：初始化一个请求。该方法只能 JavaScript 代码中使用，若要在 native code 中初始化请求，请使用 openRequest()； - .setRequestHeader()：设置 HTTP 请求头的值。您必须在 open()之后、send()之前调用 setRequestHeader()这个方法； - .send()：发送请求。如果请求是异步的（默认），那么该方法将在请求发送后立即返回； - .getResponseHeader():返回包含指定响应头的字符串，如果响应尚未收到或响应中不存在该报头，则返回 null。； - .getAllResponseHeader()：如果请求已经被发送,则立刻中止请求； - .abort()：如果请求已经被发送,则立刻中止请求； - .overrideMimeType(): 重写由服务器返回的 MIME type。  ### 属性  - .response: 返回 ArrayBuffer、Blob、Document、DOMString}，具体是哪种类型取决于 XMLHttpRequest.responseType 的值。其中包含响应体 body。 - .responseText：返回一个 DOMString}，该 DOMString}包含对请求的响应，如果请求未成功或尚未发送，则返回 null。； - .responseXML：如果响应的内容类型时 text/xml 或 application/xml，该属性将保存包含着相应数据的 XML DOM 文档； - .status：响应的 HTTP 状态； - .statusText：HTTP 状态的说明； - .readyState：返回 一个 unsigned short 即无符号短整型，请求的状态码。 - .onreadystatechange: 当 readyState 属性发生变化时调用的 EventHandler; - ......  ## 初始化请求  XMLHttpRequest.open() 方法初始化一个请求。该方法有三个参数.  ### 要使用的 HTTP 方法  #### 详细分类  - GET   - 作用：标识该操作是用于获取服务端的资源，可以理解为 select 操作   - 特点：GET 方式提交的数据最多只能是 2KB 字节；数据通过 browser 地址栏进行传递，用户信息会暴露在 browser 地址了，不安全 - POST   - 作用：用于向服务端新增数据，常用于提交表单。可以理解为 insert 操作   - 特点：理论上 POST 方式，对提交的数据大小没有限制；数据通过 http 协议的 body 体中进行传递，不会暴露用户信息，相对安全 - PUT   - 作用：用于向服务端更新数据，与 post 的使用很相似。可以理解为 update 操作。 - Delete   - 作用：标识该操作是：用于删除服务端的资源，可以理解为 delete 操作 - HEAD   - HEAD 和 GET 本质是一样的,区别在于 HEAD 不含有呈现数据,而仅仅是 HTTP 头信息。作用：只请求页面首部，响应报文中没有实体的主体部分(没有 body 体) - Options   - 它用于获取当前 URL 所支持的方法。若请求成功,则它会在 HTTP 头中包含一个名为“Allow”的头,值是所支持的方法,如“GET, POST”。跨域 cors 的时候会遇到. - TRACE   - 是 HTTP（超文本传输）协议定义的一种协议调试方法，该方法使得服务器原样返回任何客户端请求的内容。启用 TRACE 方法存在安全风险!  平时用 get 和 post 基本能实现所有功能.  #### GET 请求  查询参数是指一个由?号起始，由&符号分割的包含相应键值对的字符串。用来告知浏览器所要查询的特定资源。  ```js const query = 'example.php?name=tom&age=24'; // \"?name=tom&age=24\"即是一个查询参数 ```  需要注意的是，查询字符串中每个参数的名和值都必须使用[encodeURIComponent()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent)进行编码（这是因为 URL 中有些字符会引起歧义，例如“&”）。  #### POST 请求  需要发送的数据会作为.send()方法的参数最终被发往服务器，该数据可以是任意大小，任意类型。  这里需要注意以下两点：  - .send()方法的参数是不可为空的，对于不需要发送任何数据的 GET 请求，也需要在调用.send()方法时，向其传入 null 值； - 表单提交以及发送 POST 请求，服务器对待这两种方式并不一视同仁，这意味着服务器需要有相应的代码专门处理 POST 请求发送来的原始数据。  ### 请求 URL 地址  这里需要注意若使用相对路径，请求 URL 是相对于执行代码的当前页面。  ### 同步请求或异步请求  “同步”意味着一旦请求发出，任何后续的 JavaScript 代码不会再执行，“异步”则是当请求发出后，后续的 JavaScript 代码会继续执行，当请求成功后，会调用相应的回调函数。  默认是异步,既是 true  ## 设置请求头  默认情况下，当发送 AJAX 请求时，会附带以下头部信息：  - Accept：浏览器能够处理的内容类型； - Accept-Charset: 浏览器能够显示的字符集； - Accept-Encoding：浏览器能够处理的压缩编码； - Accept-Language：浏览器当前设置的语言； - Connection：浏览器与服务器之间连接的类型； - Cookie：当前页面设置的任何 Cookie； - Host：发出请求的页面所在的域； - Referer：发出请求的页面 URI； - User-Agent：浏览器的用户代理字符串；  部分浏览器不允许使用.setRequestHeader()方法重写默认请求头信息，因此自定义请求头信息是更加安全的方法：  ```js // 自定义请求头 xhr.setRequestHeader('myHeader', 'MyValue'); ```  ## 发送请求  get  ```js const xhr = new XMLHttpRequest(); xhr.open('get', 'example.php'); xhr.setRequestHeader('myHeader', 'goodHeader'); xhr.send(null); ```  post  ```js const xhr = new XMLHttpRequest(); xhr.open('post', 'example.php'); xhr.setRequestHeader('myHeader', 'bestHeader'); xhr.send(some_data); ```  ## 处理响应  ### 处理同步请求  ```js const xhr = new XMLHttpRequest(); xhr.open('get', 'example.php', false); xhr.setRequestHeader('myHeader', 'goodHeader'); xhr.send(null); // 由于是同步的AJAX请求，因此只有当服务器响应后才会继续执行下面的代码 // 因此xhr.status的值一定不为默认值 if ((xhr.status >= 200 && xhr.status < 300) || xhr.status == 304) {   alert(xhr.responseText); } else {   alert('Request was unsuccessful: ' + xhr.status); } ```  ### 处理异步请求  为 XMLHTTPRequest 实例添加 onreadystatechange 事件处理程序（也可以直接使用 addEventListener()方法，但是 IE8 不支持该方法）。  xhr 实例的 readystatechange 事件会监听 xhr.readyState 属性的变化，其可取的值如下：  - 0：未初始化 -- 尚未调用.open()方法； - 1：启动 -- 已经调用.open()方法，但尚未调用.send()方法； - 2：发送 -- 已经调用.send()方法，但尚未接收到响应； - 3：接收 -- 已经接收到部分响应数据； - 4：完成 -- 已经接收到全部响应数据，而且已经可以在客户端使用了；  ```js const xhr = new XMLHttpRequest(); xhr.onreadystatechange = () => {   if (xhr.readystate == 4) {     if ((xhr.status >= 200 && xhr.status < 300) || xhr.status == 304) {       alert(xhr.responseText);     } else {       alert('Request was unsuccessful: ' + xhr.status);     }   } }; xhr.open('get', 'example.php', true); xhr.send(null); ```  注意：为了确保跨浏览器的兼容性，必须要在调用.open()方法之前指定事件处理程序.  ## 取消异步请求  如果该请求已被发出，XMLHttpRequest.abort() 方法将终止该请求。当一个请求被终止，它的 readyState 属性将被置为 0（ UNSENT )，当终止 AJAX 请求后，你需要手动对 XHR 对象实例进行解绑以释放内存空间。  ```js var xhr = new XMLHttpRequest(),   method = 'GET',   url = 'https://developer.mozilla.org/'; xhr.open(method, url, true);  xhr.send();  xhr.abort();  xhr = null; ```  [下面学习参考自:XMLHttpRequest Level 2 使用指南](http://www.ruanyifeng.com/blog/2012/09/xmlhttprequest_level_2.html)  ## XMLHttpRequest Level 2  新版本的 XMLHttpRequest 对象，针对老版本的缺点，做出了大幅改进。  - 可以设置 HTTP 请求的时限。 - 可以使用 FormData 对象管理表单数据。 - 可以上传文件。 - 可以请求不同域名下的数据（跨域请求）。 - 可以获取服务器端的二进制数据。 - 可以获得数据传输的进度信息。  老版本缺点:  - 只支持文本数据的传送，无法用来读取和上传二进制文件。 - 传送和接收数据时，没有进度信息，只能提示有没有完成。 - 受到\"同域限制\"（Same Origin Policy），只能向同一域名的服务器。  ## 请求的时限  新版本的 XMLHttpRequest 对象，增加了 timeout 属性，可以设置 HTTP 请求的时限。  ```js xhr.timeout = 3000; //3000毫秒 ```  与之配套的还有一个 timeout 事件，用来指定回调函数。  ```` xhr.ontimeout = function(event){ 　　alert('请求超时！'); } ```js 注意，当请求终止时，会调用ontimeout事件处理程序，此时xhr的readyState属性的值可能已变为4，这意味着会继续调用onreadystatechange事件处理程序，但是当超时中止请求后再访问xhr的status属性会使浏览器抛出一个错误，因此需要将检查status属性的语句放入try-catch语句中。 ## FormData对象 HTML 5新增了一个FormData对象，可以模拟表单。 ```js var formData = new FormData(); formData.append('username', '张三'); formData.append('id', 123456); xhr.send(formData); ````  ## 上传文件  新版 XMLHttpRequest 对象，不仅可以发送文本信息，还可以上传文件。  假定 files 是一个\"选择文件\"的表单元素（input[type=\"file\"]），我们将它装入 FormData 对象。  ```js var formData = new FormData(); for (var i = 0; i < files.length; i++) {   formData.append('files[]', files[i]); } xhr.send(formData); ```  ## 跨域资源共享（CORS）  新版本的 XMLHttpRequest 对象，可以向不同域名的服务器发出 HTTP 请求。这叫做\"跨域资源共享\"（Cross-origin resource sharing，简称 CORS）。  使用\"跨域资源共享\"的前提，是浏览器必须支持这个功能，而且服务器端必须同意这种\"跨域\"。如果能够满足上面的条件，则代码的写法与不跨域的请求完全一样。  ```js xhr.open('GET', 'http://other.server/and/path/to/script'); ```  目前，除了 IE 8 和 IE 9，主流浏览器都支持 CORS  ## 进度事件  前共有 6 个进度事件，他们会随数据传输进展被顺序触发（除了 error，abort 事件）  新版本的 XMLHttpRequest 对象，传送数据的时候，有一个 progress 事件，用来返回进度信息。  它分成上传和下载两种情况。下载的 progress 事件属于 XMLHttpRequest 对象，上传的 progress 事件属于 XMLHttpRequest.upload 对象。  ```js xhr.onprogress = updateProgress; xhr.upload.onprogress = updateProgress; ```  然后，在回调函数里面，使用这个事件的一些属性。  ```js function updateProgress(event) {   if (event.lengthComputable) {     var percentComplete = event.loaded / event.total;   } } ```  上面的代码中，event.total 是需要传输的总字节，event.loaded 是已经传输的字节。如果 event.lengthComputable 不为真，则 event.total 等于 0。  不过还要记得注意，需要在.open()方法前调用 onprogress 事件处理程序。  与 progress 事件相关的，还有其他五个事件，可以分别指定回调函数：  - load 事件：传输成功完成。   - 该事件帮助我们节省了 readstatechange 事件，我们不必在 XHR 对象实例上绑定该事件监听函数以追踪实例上 readState 属性的变化，而是可以直接使用以下代码：  ```js const xhr = new XMLHttpRequest(); xhr.onload = () => {   if ((xhr.status >= 200 && xhr.status < 300) || xhr.status == 304) {     alert(xhr.responseText);   } else {     alert('Something wrong!');   } }; xhr.open('get', 'example.php', true); xhr.send(null); ```  - abort 事件：传输被用户取消。 - error 事件：传输中出现错误。 - loadstart 事件：传输开始。 - loadEnd 事件：传输结束，但是不知道成功还是失败。  ## 接收二进制数据  ### 方法 A：改写 MIMEType  改写数据的 MIMEType，将服务器返回的二进制数据伪装成文本数据，并且告诉浏览器这是用户自定义的字符集。  ```js xhr.overrideMimeType('text/plain; charset=x-user-defined'); ```  然后，用 responseText 属性接收服务器返回的二进制数据。  ```js var binStr = xhr.responseText; ```  还必须再一个个字节地还原成二进制数据。  ```js for (var i = 0, len = binStr.length; i < len; ++i) {   var c = binStr.charCodeAt(i);   var byte = c & 0xff; } ```  最后一行的位运算\"c & 0xff\"，表示在每个字符的两个字节之中，只保留后一个字节，将前一个字节扔掉。原因是浏览器解读字符的时候，会把字符自动解读成 Unicode 的 0xF700-0xF7ff 区段。  ### 方法 B：responseType 属性  使用新增的 responseType 属性。如果服务器返回文本数据，这个属性的值是\"TEXT\"，这是默认值。较新的浏览器还支持其他值，也就是说，可以接收其他格式的数据。  你可以把 responseType 设为 blob，表示服务器传回的是二进制对象。  ```js var xhr = new XMLHttpRequest(); xhr.open('GET', '/path/to/image.png'); xhr.responseType = 'blob'; ```  接收数据的时候，用浏览器自带的 Blob 对象即可。  ```js var blob = new Blob([xhr.response], { type: 'image/png' }); ```  你还可以将 responseType 设为 arraybuffer，把二进制数据装在一个数组里。  ```js var xhr = new XMLHttpRequest(); xhr.open('GET', '/path/to/image.png'); xhr.responseType = 'arraybuffer'; ```  接收数据的时候，需要遍历这个数组。  ```js var arrayBuffer = xhr.response; if (arrayBuffer) {   var byteArray = new Uint8Array(arrayBuffer);   for (var i = 0; i < byteArray.byteLength; i++) {     // do something   } } ``` "},{title:"网络跨域解决方法合集",path:"/posts/%E7%BD%91%E7%BB%9C%E8%B7%A8%E5%9F%9F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%E5%90%88%E9%9B%86.html",strippedContent:" ## JSONP  ### 实现背景  浏览器通常允许跨域资源嵌入,例如:  - < script >< /script > 标签嵌入跨域脚本。语法错误信息只能在同源脚本中捕捉到。 - < link rel=\"stylesheet\" > 标签嵌入 CSS。由于 CSS 的松散的语法规则，CSS 的跨域需要一个设置正确的 Content-Type 消息头。不同浏览器有不同的限制 - < img >嵌入图片。支持的图片格式包括 PNG,JPEG,GIF,BMP,SVG,... - < video\\ > 和 < audio\\ >嵌入多媒体资源。 - < object\\ >, < embed\\ > 和 < applet\\ > 的插件。 - @font-face 引入的字体。一些浏览器允许跨域字体（ cross-origin fonts），一些需要同源字体（same-origin fonts）。 - < frame\\ > 和 < iframe\\ > 载入的任何资源。站点可以使用 X-Frame-Options 消息头来阻止这种形式的跨域交互。  所以可以用它来实现跨域,用破解的方式.  当服务端支持 JSONP 技术时，会做如下一些设置：  - 识别请求的 URL，提取 callback 参数的值，并动态生成一个执行该参数值（一个函数）的 JavaScript 语句； - 将需要返回的数据放入动态生成的函数中，等待其加在到页面时被执行.  ### JSONP 的客户端具体实现  让我们直接看看 JSONP 的使用方式：  ```js // 创建 Jsonp 类 // 初始化时传入两个参数, url 是接口的url // cb 是对于接口返回的参数的处理 function Jsonp(url, cb) {   this.callbackName = 'jsonp_' + Date.now();   this.cb = cb;   this.url = url;   this.init(); }  // 初始化方法 用于拼接 url Jsonp.prototype.init = function() {   if (this.url.indexOf('?')) {     this.url = this.url + '&callback=' + this.callbackName;   } else {     this.url = this.url + '?callback=' + this.callbackName;   }   this.createCallback();   this.createScript(); };  // 创建 script 标签, src 取接口请求的url Jsonp.prototype.createScript = function() {   var script = document.createElement('script');   script.src = this.url;   script.onload = function() {     this.remove();     // 删除 window 下定义的无用方法     delete window[this.callbackName];   };   document.body.appendChild(script); };  // 绑定回调函数 Jsonp.prototype.createCallback = function() {   window[this.callbackName] = this.cb; };  // 创建 jsonp 实例, 并指定回调函数 new Jsonp('http://localhost:8888/', function(data) {   console.log(data); }); ```  jQuery 如何实现 jsonp 调用？  ```js jQuery(document).ready(function() {   $.ajax({     type: 'get',     async: false,     url: 'http://flightQuery.com/jsonp/flightResult.aspx?code=CA1998',     dataType: 'jsonp',     jsonp: 'callback', //传递给请求处理程序或页面的，用以获得jsonp回调函数名的参数名(一般默认为:callback)     jsonpCallback: 'flightHandler', //自定义的jsonp回调函数名称，默认为jQuery自动生成的随机函数名，也可以写\"?\"，jQuery会自动为你处理数据     success: function(json) {       alert(         '您查询到航班信息：票价： ' +           json.price +           ' 元，余票： ' +           json.tickets +           ' 张。'       );     },     error: function() {       alert('fail');     }   }); }); ```  如果不想把整个 jQuery 引入,可以下载一个 npm 模块 jsonp-client(更小)或者 jsonp-retry(更强大)  ### JSONP 的服务端具体实现  ```sh npm install jsonp-body --save ```  ```js var koa = require('koa'); var jsonp = require('jsonp-body'); js; var app = koa(); app.use(function*() {   this.set('X-Content-Type-Options', 'nosniff');   if (this.query.callback) {     this.set('Content-Type', 'text/javascript');   } else {     this.set('Content-Type', 'application/json');   }   this.body = jsonp({ foo: 'bar' }, this.query.callback); }); ```  ## CORS  ### 客户端细节  [CORS 详解笔记](https://zhhlwd.github.io/2019/01/04/CORS%E8%AF%A6%E8%A7%A3%E7%AC%94%E8%AE%B0/)  ### 服务端细节  node  ```js const http = require('http');  const PORT = 8888;  // 协议名必填, 如果同时存在 http 和 https 就写两条s const allowOrigin = ['http://127.0.0.1:8080', 'http://localhost:8080', 'https://www.baidu.com'];  // 创建一个 http 服务 const server = http.createServer((request, response) = > {   const { method, headers: { origin, cookie } } = request;   if (allowOrigin.includes(origin)) {     response.setHeader('Access-Control-Allow-Origin', origin);   }   response.setHeader('Access-Control-Allow-Methods', 'PUT');   response.setHeader('Access-Control-Allow-Credentials', true);   response.setHeader('Access-Control-Allow-Headers', 'token');   response.setHeader('Access-Control-Expose-Headers', 'token');   response.setHeader('token', 'quanquan');   if (method === 'OPTIONS') {     response.writeHead(204);     response.end('');   } else if (!cookie) {     response.setHeader('Set-Cookie', 'quanquan=fe');   }   response.end(\"{name: 'quanquan', friend: 'guiling'}\"); });  // 启动服务, 监听端口 server.listen(PORT, () = > {   console.log('服务启动成功, 正在监听: ', PORT); });  ```  express4  ```js // 跨域处理 app.use(function(req, res, next) {   res.header('Access-Control-Allow-Origin', '*');   res.header('Access-Control-Allow-Credentials', true);   res.header(     'Access-Control-Allow-Headers',     'Origin, X-Requested-With, Content-Type, Accept'   );   res.header('Access-Control-Allow-Methods', 'PUT,POST,GET,DELETE,OPTIONS');   res.header('Access-Control-Allow-Credentials', true);   res.header('Access-Control-Max-Age', 5);   next(); }); ```  ## Nginx 反向代理  nginx 配置  ```js server {     # 监听80端口号     listen 80;      # 监听访问的域名     server_name a.com;      # 根据访问路径配置     location / {         # 把请求转发到 http://127.0.0.1:9999         proxy_pass http://127.0.0.1:9999;          # 兼容websocket         proxy_http_version 1.1;         proxy_set_header Upgrade $http_upgrade;         proxy_set_header Connection \"upgrade\";     }      # 监听根目录下的 /api 路径     location /api/ {         # 把请求转发到 http://127.0.0.1:8888         proxy_pass http://localhost:8888;     } } ```  不过有 cookie 相关问题,需要注意  ## WebSocket  HTML5 标准推出了 WebSocket 协议，使浏览器和服务器实现了双向通信，更妙的是，除了 IE9 及以下的 IE 浏览器，所有的浏览器都支持 WebSocket 协议。WebSocket 协议本身就不受浏览器“同源策略”的限制  下面是客户端告知服务端要升级为 WebSocket 协议的报头：  ``` GET /chat HTTP/1.1 Host: server.example.com Upgrade: websocket Connection: Upgrade Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw== Sec-WebSocket-Protocol: chat, superchat Sec-WebSocket-Version: 13 Origin: http://example.com ```  下面是服务端向客户端返回的响应报头：  ``` HTTP/1.1 101 Switching Protocols Upgrade: websocket Connection: Upgrade Sec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk= Sec-WebSocket-Protocol: chat ```  ```js var ws = new WebSocket('wss://echo.websocket.org'); ws.send('Hi, server!'); ```  传入的参数为响应 WebSocket 请求的地址。  同样类似 AJAX 的是，WebSocket 对象也有一个 readyState 属性，用来表示对象实例当前所处的链接状态，有四个值：  - 表示正在连接中（CONNECTING）； - 表示连接成功，可以通信（OPEN）； - 表示连接正在关闭（CLOSING）； - 表示连接已经关闭或打开连接失败（CLOSED）；  除此之外，WebSocket 对象还提供给我们一系列事件属性，使我们控制连接过程中的通信行为：  - onopen：用于指定连接成功后的回调函数； - onclose：用于指定连接关闭后的回调函数； - onmessage：用于指定收到服务器数据后的回调函数； - onerror：用于指定报错时的回调函数；  ## ServerProxy  浏览器有同源策略的限制服务器没有. 我们的前端项目托管在后端项目中所以访问我们自己的后端不跨域. 我们的后端请求第三方服务没有限制.  所以 ServerProxy 的原理大概就是通过页面通过 ajax 访问同域后端服务,后端服务访问目标服务并将目标服务返回的内容透传给前端. "},{title:"巧妙检测低版本ie",path:"/posts/%E5%B7%A7%E5%A6%99%E6%A3%80%E6%B5%8B%E4%BD%8E%E7%89%88%E6%9C%ACie.html",strippedContent:" 借助 IE 本身提供的 hack  ```js var isIE = function(ver) {   var b = document.createElement('b');   b.innerHTML = '\x3c!--[if IE ' + ver + ']><i></i><![endif]--\x3e';   return b.getElementsByTagName('i').length === 1; }; if (isIE(6)) {   // IE 6   //alert(\"现在是IE6的浏览器！\"); } // ... if (isIE(9)) {   // IE 9   //alert(\"现在是IE9的浏览器！\"); }  var ie = isIE();  document.write(   'ie6:' +     isIE(6) +     '<br>' +     'ie7:' +     isIE(7) +     '<br>' +     'ie8:' +     isIE(8) +     '<br>' +     'ie9:' +     isIE(9) +     '<br>' +     'ie10:' +     isIE(10) +     '<br>' +     'ie11:' +     isIE(11) +     '<br>' +     'ie:' +     isIE() ); ```  如果只想检测是不是 IE，而不关心浏览器版本，那只需要在调用函数的时候，不传递参数即可 "},{title:"CSS的继承性和层叠性",path:"/posts/CSS%E7%9A%84%E7%BB%A7%E6%89%BF%E6%80%A7%E5%92%8C%E5%B1%82%E5%8F%A0%E6%80%A7.html",strippedContent:"## 继承性 有一些属性，当给自己设置的时候，自己的后代都继承上了，这个就是继承性。  哪些属性能继承？ color、 text-开头的、line-开头的、font-开头的。 这些关于文字样式的，都能够继承； 所有关于盒子的、定位的、布局的属性都不能继承。 ## 层叠性 ### 含义 层叠性：就是css处理冲突的能力。 所有的权重计算，没有任何兼容问题！ ### 权重计算 优先级: - !important标记最高     - p{color:red !important;}来给一个属性提高权重。这个属性的权重就是无穷大。（分号的前面）     -  !important提升的是一个属性，而不是一个选择器     -  !important无法提升继承的权重，该是0还是0     -  如果大家都是继承来的，应该按照“就近原则”，!important不影响就近原则 - 内联样式 : 1000 - id选择器 : 100 - 类选择器、属性选择器和伪类选择器 : 10 - 标签（类型）选择器和伪元素选择器 : 1 - 通配选择器 : 0 - 继承的样式 : 没有优先级  格式：id的数量，类的数量，标签的数量  如果权重一样，那么以后出现的为准, 如果不能直接选中某个元素，通过继承性影响的话，那么权重是0（开始数权重之前一定要看看是不是真的选中了标签）  如果大家都是0，那么有一个就近原则：谁描述的近，听谁的。 ### 权重问题总结 1） 先看有没有选中，如果选中了，那么以（id数，类数，标签数）来计权重。谁大听谁的。如果都一样，听后写的为准。  2） 如果没有选中，那么权重是0。如果大家都是0，就近原则。"},{title:"CSS实现水平垂直居中的方法总结",path:"/posts/CSS%E5%AE%9E%E7%8E%B0%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93.html",strippedContent:' ## 子元素宽高固定  ```css /* 公共代码 */ .wp {   border: 1px solid red;   width: 300px;   height: 300px; }  .box {   background: green; }  .box.size {   width: 100px;   height: 100px; } /* 公共代码 */ ```  ### absolute + 负 margin  ```css /* 此处引用上面的公共代码 */ /* 此处引用上面的公共代码 */  /* 定位代码 */ .wp {   position: relative; } .box {   position: absolute;   top: 50%;   left: 50%;   margin-left: -50px;   margin-top: -50px; } ```  ### absolute + margin auto  ```css /* 此处引用上面的公共代码 */ /* 此处引用上面的公共代码 */  /* 定位代码 */ .wp {   position: relative; } .box {   position: absolute;   top: 0;   left: 0;   right: 0;   bottom: 0;   margin: auto; } ```  ### absolute + calc  ```css /* 此处引用上面的公共代码 */ /* 此处引用上面的公共代码 */  /* 定位代码 */ .wp {   position: relative; } .box {   position: absolute;   top: calc(50% - 50px);   left: calc(50% - 50px); } ```  ### after+vertical-align  ```html <div id="wrap">   <span     >xcdcdc xcdcdc xcdcdc xcdcdcxcdcdc xcdcdc xcdcdc xcdcdcxcdcdc xcdc dc xcdcdc     xcdcdcxcdcdc xcdcdc xcdcdc xcdcdcxcdcdc xcdcdc xcdcdc xcdcdcxcdcdc xcdcdc     xcdcdc xcdcdcxcdcdc xcdcdc xcdcdc xcdcdcxcdcdc xcdcdc xcdcdc xcdcdcxcdcdc     xcdcdc xcdcdc xcdcdcxcdcdc xcdcdc xcdcdc xcdcdcxcdcdc xcdcdc xcdcdc     xcdcdcxcdcdc xcdcdc xcdcdc xcdcdcxcdcdc xcdcdc xcdcdc xcdcdcxcdcdc xcdcdc     xcdcdc xcdcdc   </span> </div> ```  里面的容器的 max-width 最大是外面的容器的 width 的值-5  ```css #wrap {   width: 500px;   height: 500px;   background-color: #ff000030; } #wrap:after {   content: \'\';   display: inline-block;   height: 100%;   width: 0px;   vertical-align: middle;   background-color: blue; } #wrap span {   vertical-align: middle;   display: inline-block;   text-align: center;   max-width: 495px; } ```  其实差几像素没有完全居中  ## 子元素宽高不固定  ### absolute + transform  ```css /* 此处引用上面的公共代码 */ /* 此处引用上面的公共代码 */  /* 定位代码 */ .wp {   position: relative; } .box {   position: absolute;   top: 50%;   left: 50%;   transform: translate(-50%, -50%); } ```  ### line-height+vertical-align  ```css /* 此处引用上面的公共代码 */ /* 此处引用上面的公共代码 */  /* 定位代码 */ .wp {   line-height: 300px;   text-align: center;   font-size: 0px; } .box {   font-size: 16px;   display: inline-block;   vertical-align: middle;   line-height: initial;   text-align: left; /* 修正文字 */ } ```  ### writing-mode+text-align  ```html <div class="wp">   <div class="wp-inner">     <div class="box">123123</div>   </div> </div> ```  ```css /* 此处引用上面的公共代码 */ /* 此处引用上面的公共代码 */  /* 定位代码 */ .wp {   writing-mode: vertical-lr;   text-align: center; } .wp-inner {   writing-mode: horizontal-tb;   display: inline-block;   text-align: center;   width: 100%; } .box {   display: inline-block;   margin: auto;   text-align: left; } ```  ### table  ```html <table>   <tbody>     <tr>       <td class="wp">         <div class="box">123123</div>       </td>     </tr>   </tbody> </table> ```  tabel 单元格中的内容天然就是垂直居中的，只要添加一个水平居中属性就好了  ```css .wp {   text-align: center; } .box {   display: inline-block; } ```  ### table-cell  ```css .wp {   display: table-cell;   text-align: center;   vertical-align: middle; } .box {   display: inline-block; } ```  ### flex  ```css .wp {   display: flex;   justify-content: center;   align-items: center; } ```  ### grid  ```css .wp {   display: grid; } .box {   align-self: center;   justify-self: center; } ```  ### 图片垂直水平居中  其实差几像素没有完全居中  ```html <div id="wrap"><img src="a.jpg" /></div> ```  ```css #wrap {   text-align: center; } #wrap:after {   content: \'\';   display: inline-block;   height: 100%;   width: 0px;   vertical-align: middle; } #wrap img {   vertical-align: middle; } ``` '},{title:"css实现元素水平居中的方法总结",path:"/posts/css%E5%AE%9E%E7%8E%B0%E5%85%83%E7%B4%A0%E6%B0%B4%E5%B9%B3%E5%B1%85%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93.html",strippedContent:" ## 对于行内元素  ```css text-align: center; ```  ## 对于确定宽度的块级元素  ### margin: 0 auto  ```css .center {   width: 960px;   margin-left: auto;   margin-right: auto; } ```  ### 绝对定位和 margin-left: -(宽度值/2)  ```css .content {   width: 200px;   position: absolute;   left: 50%;   margin-left: -100px; /* 该元素宽度的一半，即100px */   background-color: aqua; } ```  ### absolute + margin:auto  ```css .content {   position: absolute;   width: 200px;   top: 0;   right: 0;   bottom: 0;   left: 0;   margin: auto; } ```  ## 对于未知宽度的块级元素  ### table 标签配合 margin 左右 auto 实现水平居中  使用 table 标签（或直接将块级元素设值为 display:table），再通过给该标签添加左右 margin 为 auto  ### inline-block+text-align  display：inline-block;（或 display:inline）和 text-align:center;实现水平居中,[如何解决 inline-block 元素的空白间距](https://www.w3cplus.com/css/fighting-the-space-between-inline-block-elements)  ### 绝对定位+transform  ```css .content {   position: absolute;   left: 50%;   transform: translateX(-50%); /* 移动元素本身50% */   background: aqua; } ```  ### flex  ```css .contentParent {   display: flex;   flex-direction: column; }  .content {   align-self: center; } ```  ```css .contentParent {   display: flex; }  .content {   margin: auto; } ```  ### grid  【1】在网格容器上设置 justify-items 或 justify-content  ```html <style>   .parent {     display: grid;     justify-items: center;     /*justify-content:center;*/   } </style> ```  2】在网格项目中设置 justify-self 或者 margin: 0 auto  ```html <style>   .parent {     display: grid;   }   .child {     justify-self: center;     /*margin: 0 auto;*/   } </style> ```  ### fit-content+margin  ```css .content {   width: fit-content;   margin-left: auto;   margin-right: auto; } ``` "},{title:"padding相关问题",path:"/posts/padding%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98.html",strippedContent:"![image](https://s2.ax1x.com/2019/01/06/FHC7gU.png)"},{title:"溢出隐藏显示省略号",path:"/posts/%E6%BA%A2%E5%87%BA%E9%9A%90%E8%97%8F%E6%98%BE%E7%A4%BA%E7%9C%81%E7%95%A5%E5%8F%B7.html",strippedContent:" ## 单行文本以省略号结尾  ```css display: block; (隐藏属性)white-space: nowrap; overflow: hidden; text-overflow: ellipsis; ```  ## 多行文本以省略号结尾  ### WebKit 浏览器或移动端的页面  ```css overflow: hidden; text-overflow: ellipsis; display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; ```  ### 伪元素方法  ```css p {   position: relative;   line-height: 1.4em;   /* 3 times the line-height to show 3 lines */   height: 4.2em;   overflow: hidden; } p::after {   content: '...';   font-weight: bold;   position: absolute;   bottom: 0;   right: 0;   padding: 0 20px 1px 45px;   background: url(http://newimg88.b0.upaiyun.com/newimg88/2014/09/ellipsis_bg.png)     repeat-y; } ```  - IE6-7 不显示 content 内容，所以要兼容 IE6-7 可以是在内容中加入一个标签，比如用<span class=\"line-clamp\">...</span>去模拟； - 要支持 IE8，需要将::after 替换成:after； - 不溢出也会显示  ### JavaScript 方案  1.Clamp.js 下载及文档地址：https://github.com/josephschmitt/Clamp.js 使用也非常简单：  js 代码:  ```js var module = document.getElementById('clamp-this-module'); $clamp(module, { clamp: 3 }); ```  https://github.com/ftlabs/ftellipsis  ```js var element = document.getElementById('my-element'); var ellipsis = new Ellipsis(element);  ellipsis.calc(); ellipsis.set(); ```  ```html <div   id=\"view\"   style=\"border:1px solid red;width:200px;height:70px;overflow:auto;word-break:break-all\" ></div> ```  ```js const s =   '这是一个文本这是一个文本这是一个文本这是一个文本这是一个文本这是一个文本'; const el = document.getElementById('view'); n = el.offsetHeight; for (i = 0; i < s.length; i++) {   el.innerHTML = s.substr(0, i);   if (n < el.scrollHeight) {     el.style.overflow = 'hidden';     el.innerHTML = s.substr(0, i - 3) + '...';     break;   } } ``` "},{title:"css样式相关属性",path:"/posts/css%E6%A0%B7%E5%BC%8F%E7%9B%B8%E5%85%B3%E5%B1%9E%E6%80%A7.html",strippedContent:"![image](https://s2.ax1x.com/2019/01/05/FTj8j1.png)"},{title:"两列布局方法汇总",path:"/posts/%E4%B8%A4%E5%88%97%E5%B8%83%E5%B1%80%E6%96%B9%E6%B3%95%E6%B1%87%E6%80%BB.html",strippedContent:' ## 要求  左边宽度固定，右边自适应  定位,margin 负值等等方法不讲,因为 BFC 和 flex 都已经很完美解决两列布局  ## BFC  BFC 的区域不会与 float box 重叠。   步骤:  1. body{min-width: 600px;} 2. div{height: 200px;} 3. #left{width: 200px;float: left;} 4. #right{overflow: hidden;}  ## 浮动  只需要#left{width: 200px;float: left;} 缺点: right 有一部分在 left 下,背景图,padding-left 等等都会受影响  ## flex  1. #content{display: flex;} 2. #left{flex-shrink: 0;width: 200px;} 3. #right{flex-shrink: 1;flex-grow: 1;}  完美!!!  ## grid  ```html <!DOCTYPE html> <html lang="en">   <head>     <meta charset="UTF-8" />     <title>Document</title>   </head>    <body>     <section class="layout grid">       <style>         .layout.grid .left-center-right {           display: grid;           width: 100%;           grid-template-rows: auto;           grid-template-columns: 300px auto;           grid-template-areas: \'left right\';         }          .layout.grid .left {           background: red;           grid-area: left;         }          .layout.grid .right {           background: blue;           grid-area: right;         }       </style>       <article class="left-center-right">         <div class="left"></div>         <div class="right"></div>       </article>     </section>   </body> </html> ```  兼容性不好 '},{title:"CSS选择器总结",path:"/posts/CSS%E9%80%89%E6%8B%A9%E5%99%A8%E6%80%BB%E7%BB%93.html",strippedContent:' ## 基本选择器  ### 通配符\\*  \\*就表示所有元素。效率不高，如果页面上的标签越多，效率越低，所以页面上不能出现这个选择器。  ### 标签选择器  所有的标签，都可以是选择器。无论这个标签藏的多深，一定能够被选择上。  ### 类选择器  类选择器的选择符是“.”。任何的标签都可以携带 class 属性，class 属性可以重复。同一个标签，可能同时属于多个类，用空格隔开。  - 不要去试图用一个类名，把某个标签的所有样式写完。这个标签要多携带几个类，共同造成这个标签的样式。 - 每一个类要尽可能小，有“公共”的概念，能够让更多的标签使用。 - 尽可能的用 class，除非极特殊的情况可以用 id。   原因：id 是 js 用的。也就是说，js 要通过 id 属性得到标签，所以我们 css 层面尽量不用 id，要不然 js 就很别扭。另一层面，我们会认为一个有 id 的元素，有动态效果。（类上样式，id 上行为）  ### id 选择器  id 选择器的选择符是“#”。一个 HTML 页面，不能出现相同的 id。  标签的名字，可以任取，但是：  - 只能有字母、数字、下划线 - 必须以字母开头，大小写严格区别 - 不能和标签同名。比如 id 不能叫做 body、img、a  ### 后代选择器  空格就表示后代，.div1 p 就是.div1 的后代所有的 p。  ### 交集选择器  选择的元素是同时满足两个条件：必须是 h3 标签，然后必须是 special 标签。交集选择器没有空格。  ```css h3.special {   color: red; } ```  交集选择器可以连续交（一般不要这么写）  ```css h3.special.zhongyao {   color: red; } ```  交集选择器，我们一般都是以标签名开头，比如 div.haha  ### 并集选择器（分组选择器）  同时选中多个符合多个选择器的元素  用逗号就表示并集。h3,li{color:red;}  ### 儿子选择器  IE7 开始兼容，IE6 不兼容。  div>p{color:red;}div 的儿子 p。和 div 的后代 p 的截然不同。儿子选择器只能选择标签相邻的。  ### 兄弟元素选择器  IE7 开始兼容，IE6 不兼容。 选取后一个兄弟元素: 前一个 + 后一个（必须紧跟）  h3+p{color:red;}选择上的是 h3 元素后面紧挨着的第一个兄弟。  选取后边所有的兄弟元素: 前一个 ~ 后边所有（不需要紧跟）  ## 属性选择器  根据元素的属性选择指定元素  ### 存在和值的属性选择器  - \\[属性名] : 选取含有指定属性的元素 - \\[属性名="属性值"] : 选取属性值等于指定值的元素 - \\[属性名~="属性值"] : 表示带有以 属性名 命名的属性的元素，并且该属性是一个以空格作为分隔的值列表，其中至少一个值为属性值，一个时，空格可以没有  ### 属性值的属性选择器  - [attr|=val] : 选择 attr 属性的值是 val（包括 val）或以 val-开头的元素。 - [attr^=val] : 选择 attr 属性的值以 val 开头（包括 val）的元素。 - [attr$=val] : 选择 attr 属性的值以 val 结尾（包括 val）的元素。 - [attr*=val] : 选择 attr 属性的值中包含字符串 val 的元素。  ## 伪类与伪元素选择器  注意:link，:visited，:target 是作用于链接元素的！  ### 链接伪类  #### 锚点伪类  :link 表示作为超链接，并指向一个未访问的地址的所有锚  :visited 表示作为超链接，并指向一个已访问的地址的所有锚  只有下列的属性才能被应用到已访问链接： color, background-color, border-color  #### 目标伪类  :target 代表一个特殊的元素，它的 id 是 URI 的片段标识符  ```css :target {   border: 2px solid #d4d4d4;   background-color: #e5eecc; } ```  ### 动态伪类  :hover 表示悬浮到元素上  :active 表示匹配被用户激活的元素（点击按住时）  注意:hover，:active 基本可以作用于所有的元素！ie6 中不支持对超链接链接以外的元素设置:hover 和:active  由于 a 标签的:link 和:visited 可以覆盖了所有 a 标签的状态，所以当:link，:visited，:hover，:active 同时出现在 a 标签身上时 :link 和:visited 不能放在最后！！！  记住，这四种状态，在 css 中，必须按照固定的顺序写：因为 lv 已经把 a 标签的所有状态覆盖了，ha 要起作用，就要放在后面才能在起作用时覆盖全面，ha 也是同理  a:link 、a:visited 、a:hover 、a:active 如果不按照顺序，那么将失效。“爱恨准则”love hate。必须先爱，后恨。  ### 表单相关伪类  - :enabled 匹配可编辑的表单 - :disable 匹配被禁用的表单 - :checked 匹配被选中的表单 - :focus 匹配获焦的表单  ### 结构性伪类  - index 的值从 1 开始计数！！！！ - index 可以为变量 n(只能是 n) - index 可以为 even odd  #### :nth-child(index)系列  IE8 开始兼容；IE6、7 都不兼容。  寻找父元素中的指定位置子元素,在所有的子元素中排序  ```css #wrap ele:nth-child(index) { } /*表示匹配#wrap中第index的子元素 */ /* 这个子元素必须是ele;;;; 如果不匹配index和ele则没有选中） */ ```  - :first-child : 寻找父元素的第一个元素，在所有的子元素中排序 - :last-child : 寻找父元素的最后一个子元素,在所有的子元素中排序 - :nth-last-child(index) : 寻找父元素中的指定位置子元素,在所有的子元素中排序，从下往上数 - :only-child : 只能有一个子元素,相当于:first-child:last-child 或者 :nth-child(1):nth-last-child(1)  #### nth-of-type(index)系列  和: first- child 这些非常的类似,只不过 child,是在所有的子元素中排列 而 type,是在当前类型的子元素中排列  ``` #wrap ele:nth-of-type(index) //表示匹配#wrap中第index的ele子元素 //除此之外:nth-child和:nth-of-type有一个很重要的区别！！ //nth-of-type以元素为中心！！！也就是前面只能是标签 ```  - :nth-of-type : 寻找指定类型中的指定子元素 - :first-of-type : 寻找指定类型中的第一个子元素 - :last-of-type : 寻找指定类型中的最后一个子元素 - :nth-last-type(index) - :only-of-type : 在当前类型的子元素中排列，只能有一个子元素, 相对于:first-of-type:last-of-type 或者 :nth-of-type(1):nth-last-of-type(1)  #### :not  从一组元素中将符合要求的元素剔除出去  ```css div > a:not(:last-of-type) {   border-right: 1px solid red; } ```  #### :empty  内容必须是空的，有空格都不行，有属性没关系  ### 伪元素  - ::after - ::before - ::firstLetter : 第一个字符 - ::firstLine : 第一行 - ::selection : 内容被选中时的状态, 在火狐用-moz-selection 来代替 '},{title:"学习Fetch",path:"/posts/%E5%AD%A6%E4%B9%A0Fetch.html",strippedContent:" ## 兼容性  ![image](https://s2.ax1x.com/2019/01/03/FIhUJS.png) IE11 及以下不行(万恶的 IE)  ## Fetch polyfill  引入下面这些 polyfill 后可以完美支持 IE8+ ：  1. 由于 IE8 是 ES3，需要引入 ES5 的 polyfill: es5-shim, es5-sham 2. 引入 Promise 的 polyfill: es6-promise 3. 引入 fetch 探测库：fetch-detector 4. 引入 fetch 的 polyfill: fetch-ie8 5. 可选：如果你还使用了 jsonp，引入 fetch-jsonp 6. 可选：开启 Babel 的 runtime 模式，现在就使用 async/await  ## fetch()方法  fetch()方法用于发起获取资源的请求。  ### 参数  第一个参数定义要获取的资源。这可能是：  - 一个 USVString 字符串，包含要获取资源的 URL。一些浏览器会接受 blob: 和 data: 作为 schemes. - 一个 Request 对象。  第二个参数是可选的,是一个配置项对象，包括所有对请求的设置。  - method: 请求使用的方法，如 GET、POST。 - headers: 请求的头信息，形式为 Headers 的对象或包含 ByteString 值的对象字面量。 - body: 请求的 body 信息：可能是一个 Blob、BufferSource、FormData、URLSearchParams 或者 USVString 对象。注意 GET 或 HEAD 方法的请求不能包含 body 信息。 - mode: 请求的模式，如 cors、 no-cors 或者 same-origin。 - credentials: 请求的 credentials，如 omit、same-origin 或者 include。为了在当前域名内自动发送 cookie ， 必须提供这个选项， 从 Chrome 50 开始， 这个属性也可以接受 FederatedCredential 实例或是一个 PasswordCredential 实例。 - cache: 请求的 cache 模式: default 、 no-store 、 reload 、 no-cache 、 force-cache 或者 only-if-cached 。 - redirect: 可用的 redirect 模式: follow (自动重定向), error (如果产生重定向将自动终止并且抛出一个错误), 或者 manual (手动处理重定向). 在 Chrome 中，Chrome 47 之前的默认值是 follow，从 Chrome 47 开始是 manual。 - referrer: 一个 USVString 可以是 no-referrer、client 或一个 URL。默认是 client。 - referrerPolicy: Specifies the value of the referer HTTP header. May be one of no-referrer、 no-referrer-when-downgrade、 origin、 origin-when-cross-origin、 unsafe-url 。 - integrity: 包括请求的 subresource integrity 值 （ 例如： sha256-BpfBw7ivV8q2jLiT13fxDYAe2tJllusRSZ273h2nFSE=）。  ```js var myInit = { method: 'GET',                headers: myHeaders,                mode: 'cors',                cache: 'default' };  var myRequest = new Request('flowers.jpg');  fetch(myRequest,myInit).then(function(response) {   ... }); ```  也可以传入同样的 init 对象到 Request 构造器，来实现同样的效果，如：  ```js var myInit = { method: 'GET',                headers: {                    'Content-Type': 'image/jpeg'                },                mode: 'cors',                cache: 'default' };  var myRequest = new Request('flowers.jpg', myInit); fetch(myRequest).then(function(response) {   ... }); ```  ### 返回值  它返回一个 promise，这个 promise 会在请求响应后被 resolve，并传回 Response 对象。  当遇到网络错误时，fetch() 返回的 promise 会被 reject，并传回 TypeError，虽然这也可能因为权限或其它问题导致。  成功的 fetch() 检查不仅要包括 promise 被 resolve，还要包括 Response.ok 属性为 true。  ```js fetch('http://example.com/movies.json')   .then(function(response) {     return response.json();   })   .then(function(myJson) {     console.log(myJson);   }); ```  注意,当接收到一个代表错误的 HTTP 状态码时，从 fetch()返回的 Promise 不会被标记为 reject， 即使该 HTTP 响应的状态码是 404 或 500。相反，它会将 Promise 状态标记为 resolve （但是会将 Response.ok 设置为 false ），仅当网络故障时或请求被阻止时，才会标记为 reject。  ## Request 对象  ### 得到 Request 对象  - 通过 Request.Request()构造函数创建一个 Request 对象,它的参数和 Fetch()方法的差不多,所以它能代替 Fetch()方法的 init 参数 - 一个 Request 对象也可能作为其它 API 的操作被返回，比如一个 service worker 的[FetchEvent.request](https://developer.mozilla.org/zh-CN/docs/Web/API/FetchEvent/request)。  ### 属性  Request 对象的属性都是只读的.  - Request.method 只读   - 包含请求的方法 (GET, POST, 等.)  ```js var myRequest = new Request('flowers.jpg'); var myMethod = myRequest.method; // GET ```  - Request.url 只读   - 包含这个请求的 URL。  ```js var myRequest = new Request('flowers.jpg'); var myURL = myRequest.url; // \"http://mdn.github.io/fetch-examples/fetch-request/flowers.jpg\" ```  - Request.headers 只读   - 包含请求相关的 Headers 对象。  ```js var myRequest = new Request('flowers.jpg'); var myHeaders = myRequest.headers; // Headers {} ```  - Request.context 只读   - 包含请求的上下文(例如：audio, image, iframe, 等) - Request.referrer 只读   - ?包含请求的来源 (例如：client)。 - Request.referrerPolicy 只读   - ?包含请求来源的策略 (例如：no-referrer)。 - Request.mode 只读   - 包含请求的模式 (例如： cors, no-cors, same-origin, navigate). - Request.credentials 只读   - 包含请求的证书(例如： omit, same-origin,include). - Request.redirect 只读   - 包含?如何处理重定向模式，它可能是一个 follow ，error 或者 manual。 - Request.integrity 只读   - 包含请求的子资源的完整性值 (例如： sha256-BpfBw7ivV8q2jLiT13fxDYAe2tJllusRSZ273h2nFSE=). - Request.cache 只读   - 包含请求的缓存模式 (例如： default, reload, no-cache).  ### 方法  - Request.clone()   - 创建当前 request 的副本。   - clone()TypeError 如果 Body 已经使用了响应，则抛出 a 。实际上，clone()存在的主要原因是允许 Body 对象的多次使用（当它们仅为一次使用时）。 - Request 实现 Body, 因此它也有 Body 的方法  ## Response 对象  ### 得到 Response 对象  - 通过 Response.Response()构造函数创建一个 Response 对象  ```js var myBlob = new Blob(); var init = { status: 200, statusText: 'SuperSmashingGreat!' }; var myResponse = new Response(myBlob, init); ```  - 一个 Request 对象也可能作为其它 API 的操作被返回，例如一个 service worker 的[Fetchevent.respondWith](https://developer.mozilla.org/zh-CN/docs/Web/API/Fetchevent/respondWith)，或者一个简单的 [GlobalFetch.fetch()](https://developer.mozilla.org/zh-CN/docs/Web/API/WindowOrWorkerGlobalScope/fetch)  ### 属性  - Response.type 只读   - 包含 Response 的类型 (例如, basic, cors). - Response.url 只读   - 包含 Response 的 URL. - Response.useFinalURL   - 包含了一个布尔值来标示这是否是该 Response 的最终 URL. - Response.status 只读   - 包含 Response 的状态码 (例如, 200 成功). - Response.ok 只读   - 包含了一个布尔值来标示该 Response 成功(状态码 200-299) 还是失败. - Response.redirected 只读   - 表示该 Response 是否来自一个重定向，如果是的话，它的 URL 列表将会有多个 - Response.statusText 只读   - 包含了与该 Response 状态码一致的状态信息 (例如, OK 对应 200). - Response.headers 只读   - 包含此 Response 所关联的 Headers 对象. - Response 实现了 Body, 所以以下属性同样可用:   - Body.bodyUsed 只读   - 包含了一个布尔值来标示该 Response 是否读取过 Body.  ### 方法  - Response.clone()   - 创建一个 Response 对象的克隆 - Response.error()   - 返回一个绑定了网络错误的新的 Response 对象 - Response.redirect()   - 用另一个 URL 创建一个新的 response. - Response 实现了 Body, 因此它也有 Body 的方法  ## Headers 对象  Fetch API 的 Headers 接口允许您对 HTTP 请求和响应头执行各种操作。这些操作包括检索，设置，添加和删除。  - Headers.append()   - 给现有的 header 添加一个值, 或者添加一个未存在的 header 并赋值. - Headers.delete()   - 从 Headers 对象中删除指定 header. - Headers.entries()   - 以 迭代器 的形式返回 Headers 对象中所有的键值对. - Headers.get()   - 从 Headers 对象中返回指定 header 的第一个值. - Headers.getAll()   - 以数组的形式从 Headers 对象中返回指定 header 的全部值. - Headers.has()   - 以布尔值的形式从 Headers 对象中返回是否存在指定的 header. - Headers.keys()   - 以迭代器的形式返回 Headers 对象中所有存在的 header 名. - Headers.set()   - 替换现有的 header 的值, 或者添加一个未存在的 header 并赋值. - Headers.values()   - 以迭代器的形式返回 Headers 对象中所有存在的 header 的值.  ```js let myHeaders = new Headers();  myHeaders.append('Content-Type', 'text/xml');  myHeaders.get('Content-Type'); // should return 'text/xml' ```  ## body 对象  Fetch API 中的 Body mixin 代表 代表响应/请求的正文，允许你声明其内容类型是什么以及应该如何处理。  正文由 Request 和 Response 实现 --- 这为这些对象提供了一个相关联的主体（字节流），一个已使用的标志（最初未设置）和一个 MIME 类型（最初为空字节序列）。  ### 属性  - Body.bodyUsed 只读   - 包含一个指示 body 是否被读取过的 Boolean 值。  ### 方法  - Body.arrayBuffer()   - 使用一个 buffer 数组来读取 Response 流中的数据，并将 bodyUsed 状态改为已使用。 - Body.blob()   - 使用一个 Blob 对象来读取 Response 流中的数据，并将 bodyUsed 状态改为已使用。 - Body.formData()   - 使用一个 FormData 对象来读取 Response 流中的数据，并将 bodyUsed 状态改为已使用。  ```js response.formData().then(function(formdata) {   // do something with your formdata }); ```  - Body.json()   - 使用一个 JSON 对象来读取 Response 流中的数据，并将 bodyUsed 状态改为已使用。  ```js fetch(`https://cdn.xgqfrms.xyz/json/badges.json`)   .then(response => response.json())   .then(data => {     console.log(`data = \\n`, data);   }); ```  - Body.text()   - 使用一个 USVString (文本) 对象来读取 Response 流中的数据，并将 bodyUsed 状态改为已使用。  ## Fetch 示例  ```js postData('http://example.com/answer', { answer: 42 })   .then(data => console.log(data)) // JSON from `response.json()` call   .catch(error => console.error(error));  function postData(url, data) {   // Default options are marked with *   return fetch(url, {     body: JSON.stringify(data), // must match 'Content-Type' header     cache: 'no-cache', // *default, no-cache, reload, force-cache, only-if-cached     credentials: 'same-origin', // include, same-origin, *omit     headers: {       'user-agent': 'Mozilla/4.0 MDN Example',       'content-type': 'application/json'     },     method: 'POST', // *GET, POST, PUT, DELETE, etc.     mode: 'cors', // no-cors, cors, *same-origin     redirect: 'follow', // manual, *follow, error     referrer: 'no-referrer' // *client, no-referrer   }).then(response => response.json()); // parses response to JSON } ```  ## 发送带 cookie 的请求  ```js fetch('https://example.com', {   credentials: 'include' }); ```  ## 上传文件  ```js var formData = new FormData(); var fileField = document.querySelector(\"input[type='file']\");  formData.append('username', 'abc123'); formData.append('avatar', fileField.files[0]);  fetch('https://example.com/profile/avatar', {   method: 'PUT',   body: formData })   .then(response => response.json())   .catch(error => console.error('Error:', error))   .then(response => console.log('Success:', response)); ```  ## 上传多个文件  ```js var formData = new FormData(); var photos = document.querySelector(\"input[type='file'][multiple]\");  formData.append('title', 'My Vegas Vacation'); formData.append('photos', photos.files);  fetch('https://example.com/posts', {   method: 'POST',   body: formData })   .then(response => response.json())   .then(response => console.log('Success:', JSON.stringify(response)))   .catch(error => console.error('Error:', error)); ```  ## 解决超时  ```js const defaultOptions = {   headers: {     'Content-Type': 'application/json'   } }; function request(url, options = {}) {   return new Promise((resolve, reject) => {     const headers = { ...defaultOptions.headers, ...options.headers };     let abortId;     let timeout = false;     if (options.timeout) {       abortId = setTimeout(() => {         timeout = true;         reject(new Error('timeout!'));       }, options.timeout || 6000);     }     fetch(url, { ...defaultOptions, ...options, headers })       .then(res => {         if (timeout) throw new Error('timeout!');         return res;       })       .then(checkStatus)       .then(parseJSON)       .then(res => {         clearTimeout(abortId);         resolve(res);       })       .catch(e => {         clearTimeout(abortId);         reject(e);       });   }); } ```  ## 感言  其实写到这里,我已经放弃 Fetch 了,ajax 的已经很成熟的优点,例如超时,进度事件.....都已经支持,就为了 ajax 的一些缺点改为 Fetch,却损失了很多 ajax 的缺点,有点丢了西瓜捡芝麻,还是用 axios 吧 "},{title:"浏览器同源政策总结",path:"/posts/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%90%8C%E6%BA%90%E6%94%BF%E7%AD%96%E6%80%BB%E7%BB%93.html",strippedContent:" 学习来自阮一峰的文章,本文只作为自己的总结和复习用.  ## 概述  1995 年，同源政策由 Netscape 公司引入浏览器。目前，所有浏览器都实行这个政策。  同源政策的目的，是为了保证用户信息的安全，防止恶意的网站窃取数据。  它的含义是指，A 网页设置的 Cookie，B 网页不能打开，除非这两个网页\"同源\"。所谓\"同源\"指的是\"三个相同\"。  - 协议相同 - 域名相同 - 端口相同  例如:http://www.example.com/dir/page.html  - http://www.example.com/dir2/other.html：同源 - http://example.com/dir/other.html：不同源（域名不同） - http://v2.www.example.com/dir/other.html：不同源（域名不同） - http://www.example.com:81/dir/other.html：不同源（端口不同）  ## 限制范围  目前，如果非同源，共有三种行为受到限制  - （1） Cookie、LocalStorage 和 IndexDB 无法读取。 - （2） DOM 无法获得。 - （3） AJAX 请求不能发送。  ## Cookie 不同源  A 网页是http://w1.example.com/a.html， B 网页是http://w2.example.com/b.html， 那么只要设置相同的 document.domain，两个网页就可以共享 Cookie。  ``` document.domain = 'example.com'; ```  注意，这种方法只适用于 Cookie 和 iframe 窗口，LocalStorage 和 IndexDB 无法通过这种方法，规避同源政策，而要使用下文介绍的 PostMessage API。  另外，服务器也可以在设置 Cookie 的时候，指定 Cookie 的所属域名为一级域名，比如 .example.com。  ``` Set-Cookie: key=value; domain=.example.com; path=/ ```  这样的话，二级域名和三级域名不用做任何设置，都可以读取这个 Cookie。  ## iframe 和窗口不同源  如果两个网页不同源，就无法拿到对方的 DOM。典型的例子是 iframe 窗口和 window.open 方法打开的窗口，它们与父窗口无法通信。  比如，父窗口运行下面的命令，如果 iframe 窗口不是同源，就会报错。  ```js document.getElementById('myIFrame').contentWindow.document; // Uncaught DOMException: Blocked a frame from accessing a cross-origin frame. ```  反之亦然，子窗口获取主窗口的 DOM 也会报错。  ```js window.parent.document.body; // 报错 ```  ### document.domain  如果两个窗口一级域名相同，只是二级域名不同，那么设置上一节介绍的 document.domain 属性，就可以规避同源政策，拿到 DOM。  对于完全不同源的网站，目前有三种方法，可以解决跨域窗口的通信问题。  - 片段识别符（fragment identifier） - window.name - 跨文档通信 API（Cross-document messaging）  ### 片段识别符(hash)  片段标识符（fragment identifier）指的是，URL 的#号后面的部分，比如http://example.com/x.html#fragment的#fragment。如果只是改变片段标识符，页面不会重新刷新。  父窗口可以把信息，写入子窗口的片段标识符。  ```js var src = originURL + '#' + data; document.getElementById('myIFrame').src = src; ```  子窗口通过监听 hashchange 事件得到通知。  ```js window.onhashchange = checkMessage;  function checkMessage() {   var message = window.location.hash;   // ... } ```  同样的，子窗口也可以改变父窗口的片段标识符。  ```js parent.location.href = target + '#' + hash; ```  ### window.name  浏览器窗口有 window.name 属性。这个属性的最大特点是，无论是否同源，只要在同一个窗口里，前一个网页设置了这个属性，后一个网页可以读取它。  父窗口先打开一个子窗口，载入一个不同源的网页，该网页将信息写入 window.name 属性。  ```js window.name = data; ```  接着，子窗口跳回一个与主窗口同域的网址。  ```js location = 'http://parent.url.com/xxx.html'; ```  然后，主窗口就可以读取子窗口的 window.name 了。  ```js var data = document.getElementById('myFrame').contentWindow.name; ```  这种方法的优点是，window.name 容量很大，可以放置非常长的字符串；缺点是必须监听子窗口 window.name 属性的变化，影响网页性能  ### window.postMessage  上面两种方法都属于破解，HTML5 为了解决这个问题，引入了一个全新的 API：跨文档通信 API（Cross-document messaging）。  这个 API 为 window 对象新增了一个 window.postMessage 方法，允许跨窗口通信，不论这两个窗口是否同源。  举例来说，父窗口http://aaa.com向子窗口http://bbb.com发消息，调用postMessage方法就可以了。  ```js var popup = window.open('http://bbb.com', 'title'); popup.postMessage('Hello World!', 'http://bbb.com'); ```  postMessage 方法的第一个参数是具体的信息内容，第二个参数是接收消息的窗口的源（origin），即\"协议 + 域名 + 端口\"。也可以设为\\*，表示不限制域名，向所有窗口发送。  子窗口向父窗口发送消息的写法类似。  ```js window.opener.postMessage('Nice to see you', 'http://aaa.com'); ```  父窗口和子窗口都可以通过 message 事件，监听对方的消息。  ```js window.addEventListener(   'message',   function(e) {     console.log(e.data);   },   false ); ```  message 事件的事件对象 event，提供以下三个属性。  ```js event.source：发送消息的窗口 event.origin: 消息发向的网址 event.data: 消息内容 ```  ## LocalStorage 不同源  通过 window.postMessage，读写其他窗口的 LocalStorage 也成为了可能。  下面是一个例子，主窗口写入 iframe 子窗口的 localStorage。  ```js window.onmessage = function(e) {   if (e.origin !== 'http://bbb.com') {     return;   }   var payload = JSON.parse(e.data);   localStorage.setItem(payload.key, JSON.stringify(payload.data)); }; ```  上面代码中，子窗口将父窗口发来的消息，写入自己的 LocalStorage。  父窗口发送消息的代码如下。  ```js var win = document.getElementsByTagName('iframe')[0].contentWindow; var obj = { name: 'Jack' }; win.postMessage(   JSON.stringify({ key: 'storage', data: obj }),   'http://bbb.com' ); ```  加强版的子窗口接收消息的代码如下。  ```js window.onmessage = function(e) {   if (e.origin !== 'http://bbb.com') return;   var payload = JSON.parse(e.data);   switch (payload.method) {     case 'set':       localStorage.setItem(payload.key, JSON.stringify(payload.data));       break;     case 'get':       var parent = window.parent;       var data = localStorage.getItem(payload.key);       parent.postMessage(data, 'http://aaa.com');       break;     case 'remove':       localStorage.removeItem(payload.key);       break;   } }; ```  加强版的父窗口发送消息代码如下。  ```js var win = document.getElementsByTagName('iframe')[0].contentWindow; var obj = { name: 'Jack' }; // 存入对象 win.postMessage(   JSON.stringify({ key: 'storage', method: 'set', data: obj }),   'http://bbb.com' ); // 读取对象 win.postMessage(JSON.stringify({ key: 'storage', method: 'get' }), '*'); window.onmessage = function(e) {   if (e.origin != 'http://aaa.com') return;   // \"Jack\"   console.log(JSON.parse(e.data).name); }; ```  ## AJAX 不同源  除了架设服务器代理（浏览器请求同源服务器，再由后者请求外部服务），有三种方法规避 AJAX 跨域。  - JSONP - WebSocket - CORS  AJAX 跨域另起文章详细总结 "},{title:"Nginx和HTTP",path:"/posts/Nginx%E5%92%8CHTTP.html",strippedContent:" ## 设置头  中间代理在 http 协议下, 很轻松就可以修改 header 头, 比如常见的手机中国移动等运营商的广告.  ```js server {   listen      80;   server_name test.com;    location / {     proxy_pass http://127.0.0.1:8888;     # 如果不设置就是 http://127.0.0.1:8888 设置了的话就是 test.com     proxy_set_header Host $host;   } } ```  ## Nginx 代理缓存  代理缓存设置  ```js proxy_cache_path cache levels=1:2 keys_zone=my_cache:10m;  server { \tlisten \t\t80; \tserver_name a.test.com;  \tlocation / { \t\tproxy_cache my_cache; \t\tproxy_pass http://localhost:8888; \t\tproxy_set_header Host $host; \t} } ```  代理缓存测试  chrome 浏览器访问 a.test.com, 第一次结果延迟两秒展示, 再次刷新速度大幅提升  换别的浏览器如 firfox 去访问 a.test.com 第一次结果并没有延迟两秒展示, 这是因为 nginx 做了代理缓存设置,  当一个用户访问了资源, 就会缓存下来, 当其他用户访问时就从缓存取  ### header 设置  同时设置 max-age 和 s-maxage, 代理缓存会设置 s-maxage  ```js response.writeHead(200, {   'Cache-Control': 'max-age=20, s-maxage=20' }); ```  private 只允许浏览器缓存, 不允许代理服务器缓存.  ```js response.writeHead(200, {   'Cache-Control': 'max-age=20, private' }); ```  no-store 浏览器和代理服务器都不允许缓存  Vary 只有头信息一致才缓存.  ```js response.writeHead(200, {   'Cache-Control': 's-maxage=20',   Vary: 'X-Test-Cache' }); ```  ```html <body>   <div>This is content <span id=\"data\"><span></div>   <button id=\"button\">click me</button>   <script>     var index = 0      function doRequest() {       var data = document.getElementById('data')       data.innerText = ''       fetch('/data', {         headers: {           'X-Test-Cache': index++         }       }).then(function (response) {         return response.text()       }).then(function (text) {         data.innerText = text       })     }     document.getElementById('button').addEventListener('click', doRequest)   <\/script> </body> ```  ## HTTPS  HTTP 明文传输, 传输的任意一层, 别人都可以抓到.  HTTPS 有公钥和私钥 ![image](https://s2.ax1x.com/2019/01/01/F45oUf.jpg)  ## Nginx 部署 HTTPS 服务  生成证书  ```sh openssl req -x509 -newkey rsa:2048 -nodes -sha256 -keyout localhost-privkey.pem -out localhost-cert.pem ```  配置 HTTPS  ```js server {   listen 443;   server_name a.test.com;    ssl on;   ssl_certificate_key certs/localhost-privkey.pem;   ssl_certificate certs/localhost-cert.pem;    location / {     proxy_cache my_cache;     proxy_pass http://localhost:8888;     proxy_set_header Host $host;   } } ```  配置 HTTP 到 HTTPS  ```js server {   listen 80 default_server;   listen [::]:80 default_server;   server_name test.com;   return 302 https://$server_name$request_uri; } ```  ## HTTP2 优势 和 Nginx 配置 HTTP2  我们做 Node 开发只要做 HTTP/1.1 就好了, 用 Nginx 处理 HTTP2  ### 优势  信道复用  分帧传输 (不一定要按顺序发送)  Server Push, 主动向客户端推送  #### 推送实例  'Link': '</test.jpg>; as=image; rel=preload', 这里的路径跟 html 图片的路径保持一致.  rel=preload 服务端推送.  ```js const http = require('http'); const fs = require('fs');  http   .createServer(function(request, response) {     console.log('request come', request.url);      const html = fs.readFileSync('test.html', 'utf8');     const img = fs.readFileSync('test.jpg');     if (request.url === '/') {       response.writeHead(200, {         'Content-Type': 'text/html',         Connection: 'keep-alive',         Link: '</test.jpg>; as=image; rel=preload'       });       response.end(html);     } else {       response.writeHead(200, {         'Content-Type': 'image/jpg',         Connection: 'keep-alive' // or close       });       response.end(img);     }   })   .listen(8888);  console.log('server listening on 8888'); ```  test.html \\<img src=\"/test.jpg\" alt=\"\"\\> 与上面 server.js 的图片路径保持一致  ### Nginx 开启 HTTP2  ```js server {   listen       443 http2;   server_name  test.com;   http2_push_preload on;    ssl on;   ssl_certificate   ../certs/214758036890959.pem;   ssl_certificate_key  ../certs/214758036890959.key;    location / {   proxy_cache my_cache;   proxy_pass http://localhost:8888;   proxy_set_header Host $host;   add_header Strict-Transport-Security max-age=200;   } } ```  ### HTTP2 性能测试网站  [性能测试网站](https://http2.akamai.com/demo/http2-lab.html) "},{title:"HTTP协议学习",path:"/posts/HTTP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0.html",strippedContent:" HTTP 的知识新手也许感觉没什么重要的,但是随着学习的加深,它就会变得越来越重要,限制人的技术的高度和深度,例如一个 HTTP 请求失败的分析,和后端讨论方案等等,都会让你畏手畏脚,底气不足.  ## 五层网络模型  ![五层网络模型](https://s1.ax1x.com/2018/12/31/F4UWo6.md.png)  我们一般在讲解网络信息传输的时候,都会套用一个五层模型来诠释.在每台电脑,每台服务器上都可以用它来维护我们的网络传输.  ### 低三层  比较底层,靠近硬件,我们不用过于关心了解  #### 物理层  主要作用是定义物理设备如何传输数据;   简单来说就是我们电脑的硬件,网卡,光缆  #### 数据链路层  在通信的实体间建立数据链路连接;   就是帮我们在硬件之间创建连接的比较底层的软件服务,最基础的 0101 的二进制传播  #### 网络层  为数据在结点之间传输创建逻辑链路;   就是比如我们的电脑如何寻找百度的服务器,和它建立连接  ### 传输层  主要有两个协议 tcp 和 udp.一般我们用 tcp 协议的比较多,因为它更加安全稳定  传输层向用户提供可靠的端到端(End-to-End)服务,就是我们的电脑和百度的服务器建立了连接后,我们之间如何去传输数据,我们传输的数据可能很小可能很大,我们要分包分片,传输过去后要进行数据的组装等等这些都是在传输层定义的.  传输层向高层屏蔽了下层数据通信的细节,我们输入一个 url,创建一个 ajax 等等,都是其中网络如何分包组装,如何保证数据的完整性等等这些都是 http 不用关心的事  ### 应用层  http 协议就在这一层  为应用软件提供了很多服务  构建于 TCP 协议之上  屏蔽网络传输相关细节  ## HTTP 协议历史  ### HTTP/0.9  比较简单,只有一个命令 GET  没有 header 等描述数据的信息  服务器发送完毕, 就关闭 TCP 连接  ### HTTP/1.0  增加了很多命令 如 POST ,HEAD , PUT  增加了 status code 和 header  多字符集支持、多部分发送、权限、缓存等  ### HTTP/1.1  持久连接,http 请求后 tcp 连接可以不立即关闭  pipeline,就是 http 请求的在服务端在以前前一个请求处理时间比较久,后一个比较快,都是服务端处理是按顺序的,问题就像 JavaScript 的事件的并行和串行,所以在 http1.1 做了优化  增加 host 和其他一些命令(一台物理服务器可以开多个 web 服务)  ### HTTP2  所有数据以二进制传输,在 http1.1 里.大部分的数据是字符串格式的  同一个连接里面发送多个请求不再需要按照顺序来(并行的效率)  头信息压缩以及推送等提高效率的功能,不必要的头信息会省略,还有服务器可以主动发起一些数据传输的,比如可以在请求 HTML 文档的时候主动把相关的图片,js 和 css 推送到客户端  ## TCP 三次握手  ![F40mp8.md.png](https://s1.ax1x.com/2018/12/31/F40mp8.md.png) http 协议不存在连接的概念,只有请求和响应的概念,它是进行在一个 TCP connection 中, tcp 连接可以发送多个 http 请求. ![F4wOT1.png](https://s1.ax1x.com/2018/12/31/F4wOT1.png) ![F4017n.md.png](https://s1.ax1x.com/2018/12/31/F4017n.md.png) 第一次握手   建立连接。客户端发送连接请求报文段，将 SYN 位置为 1，Sequence Number 为 x；然后，客户端进入 SYN_SEND 状态，等待服务器的确认；  第二次握手   服务器收到 SYN 报文段。服务器收到客户端的 SYN 报文段，需要对这个 SYN 报文段进行确认，设置 Acknowledgment Number 为 x+1(Sequence Number+1)；同时，自己自己还要发送 SYN 请求信息，将 SYN 位置为 1，Sequence Number 为 y；服务器端将上述所有信息放到一个报文段（即 SYN+ACK 报文段）中，一并发送给客户端，此时服务器进入 SYN_RECV 状态；  第三次握手   客户端收到服务器的 SYN+ACK 报文段。然后将 Acknowledgment Number 设置为 y+1，向服务器发送 ACK 报文段，这个报文段发送完毕以后，客户端和服务器端都进入 ESTABLISHED 状态，完成 TCP 三次握手。  ### 为什么要三次握手  为了防止已失效的连接请求报文段突然又传送到了服务端，因而让服务端创建无用的连接。  具体例子：“已失效的连接请求报文段”的产生在这样一种情况下：client 发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达 server。本来这是一个早已失效的报文段。但 server 收到此失效的连接请求报文段后，就误认为是 client 再次发出的一个新的连接请求。于是就向 client 发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要 server 发出确认，新的连接就建立了。由于现在 client 并没有发出建立连接的请求，因此不会理睬 server 的确认，也不会向 server 发送数据。但 server 却以为新的运输连接已经建立，并一直等待 client 发来数据。这样，server 的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client 不会向 server 的确认发出确认。server 由于收不到确认，就知道 client 并没有要求建立连接。  ## TCP 四次挥手  ![F4BEDJ.md.png](https://s1.ax1x.com/2018/12/31/F4BEDJ.md.png) 第一次分手   主机 1（可以使客户端，也可以是服务器端），设置 Sequence Number，向主机 2 发送一个 FIN 报文段；此时，主机 1 进入 FIN_WAIT_1 状态；这表示主机 1 没有数据要发送给主机 2 了；  第二次分手   主机 2 收到了主机 1 发送的 FIN 报文段，向主机 1 回一个 ACK 报文段，Acknowledgment Number 为 Sequence Number 加 1；主机 1 进入 FIN_WAIT_2 状态；主机 2 告诉主机 1，我“同意”你的关闭请求；  第三次分手   主机 2 向主机 1 发送 FIN 报文段，请求关闭连接，同时主机 2 进入 LAST_ACK 状态；  第四次分手   主机 1 收到主机 2 发送的 FIN 报文段，向主机 2 发送 ACK 报文段，然后主机 1 进入 TIME_WAIT 状态；主机 2 收到主机 1 的 ACK 报文段以后，就关闭连接；此时，主机 1 等待 2MSL 后依然没有收到回复，则证明 Server 端已正常关闭，那好，主机 1 也可以关闭连接了。  ### 为什么要四次分手  TCP 协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。TCP 是全双工模式，这就意味着，当主机 1 发出 FIN 报文段时，只是表示主机 1 已经没有数据要发送了，主机 1 告诉主机 2，它的数据已经全部发送完毕了；但是，这个时候主机 1 还是可以接受来自主机 2 的数据；当主机 2 返回 ACK 报文段时，表示它已经知道主机 1 没有数据发送了，但是主机 2 还是可以发送数据到主机 1 的；当主机 2 也发送了 FIN 报文段时，这个时候就表示主机 2 也没有数据要发送了，就会告诉主机 1，我也没有数据要发送了，之后彼此就会愉快的中断这次 TCP 连接。  ## URI、URL、URN  ### URI  URI 包含 URL 和 URN  Uniform Resource Identifier / 统一资源标识符  用来唯一标识互联网上的信息资源  ### URL  Uniform Resource Locator / 统一资源定位器  http://user:pass@host.com:80/path?query=string#hash  协议: http://  身份(现在基本不用): user:pass@  服务器地址: host.com (本质用的是 ip)  端口: :80 (默认是 80, 所以地址栏一般都是看不到)  路由: /path  搜索参数: ?query=string  文档的不同 hash: #hash  ### URN  永久统一资源定位符  在资源移动之后还能被找到  目前还没有非常成熟的使用方案  ## HTTP 报文  ![F4BtUI.md.png](https://s1.ax1x.com/2018/12/31/F4BtUI.md.png)  ### http 请求报文  http 请求报文是指客户端到服务器端的消息，客户端通过发送 http 请求向服务器请求对资源的访问。包括三个部分：请求行、请求头部、请求数据。请求方法有 OPTIONS、GET、HEAD、POST、PUT、DELETE、TRACE、CONNECT 这几种。  1. 请求行：包含请求方法、uri 和协议的版本，用空格分隔，例如：GET/sample.jsp HTTP/1.1 2. 请求头部：包含有关客户端环境及请求正文的信息，如请求正文长度、浏览器所用编码格式等，例如;  ``` Accept:image/gif.image/jpeg.*/*  Accept-Language:zh-cn  Connection:Keep-Alive  Host:localhost  User-Agent:Mozila/4.0(compatible:MSIE5.01:Windows NT5.0)  Accept-Encoding:gzip,deflate ```  3. 请求数据：即客户端发送给服务器的内容，可为空（GET 请求就没有请求数据），例如：username=jinqiao&password=1234, 请求头部和请求数据之间必须有空行，用以区分。  ### HTTP 响应报文  http 应答报文是指服务器回应 http 请求，发送给客户端的消息。也包括三个部分：状态行、响应头部、响应数据。  1. 状态行：协议版本、状态码、简要描述，例如：HTTP/1.1 200 OK 2. 响应头部：必须指明 Content-Type，其他可选，例如：Content-Type: text/plain 3. 响应数据：即服务器回应客户端的内容。  常见状态码  - 1xx：指示信息--表示请求已接收，继续处理。 - 2xx：成功--表示请求已被成功接收、理解、接受。 - 3xx：重定向--要完成请求必须进行更进一步的操作。 - 4xx：客户端错误--请求有语法错误或请求无法实现。 - 5xx：服务器端错误--服务器未能实现合法的请求。  ## CORS 跨域请求的限制与解决  不管有没有跨域, 客户端发起请求, 服务端都会接受你的请求并且返回内容.  跨域是浏览器来做的! 浏览器接受到服务器返回的内容, 没看到请求头中没有设置 Access-Control-Allow-Origin 就报错, 不展示给你结果!  一句话: 服务端没有跨域, 只有浏览器有同源策略  ### 解决跨域  #### CORS  增加 Access-Control-Allow-Origin 响应头  ```js response.writeHead(200, {   'Access-Control-Allow-Origin': '*' }); ```  #### JSONP 处理跨域  利用 img script link 三个标签可以发起跨域请求.  ### CORS 预请求  其他不被允许的都要经过预请求 跨域时, 允许的方法只有 GET HEAD POST.  跨域时, 允许的 Content-Type 有 text/plain multipart/form-data application/x-www-form-urlencoded  其他限制:  请求头限制  XMLHttpRequestUpload 对象均没有注册任何事件监听器  请求中没有使用 ReadableStream 对象  ### 增加 'Access-Control-Allow-Headers': 'X-Test-Cors'  浏览器对跨域请求的预请求  会先发送一个 OPTIONS 请求, 服务端根据不同的 methods 进行不同的操作.  利用 OPSTIONS 请求获得服务端认可, 实际发送 POST 请求 ![F4r96U.md.png](https://s1.ax1x.com/2018/12/31/F4r96U.md.png)  #### 设置 Methods  ![F4rim4.md.png](https://s1.ax1x.com/2018/12/31/F4rim4.md.png)  ### 设置 Max-Age  'Access-Control-Max-Age': '1000', 表示 1000 s 不需要再发预请求.  ```js const http = require('http');  http   .createServer(function(request, response) {     console.log('request come', request.url);     response.writeHead(200, {       'Access-Control-Allow-Origin': '*',       'Access-Control-Allow-Headers': 'X-Test-Cors',       'Access-Control-Allow-Methods': 'POST, PUT, DELETE',       'Access-Control-Max-Age': '1000'     });     response.end('123');   })   .listen(8887);  console.log('server run 8887'); ```  ## Cache-Control  ![F4rQne.md.png](https://s1.ax1x.com/2018/12/31/F4rQne.md.png)  ### 可缓存性  public, 表示所有 http 经过的任何地方(代理)都可以缓存  private, 只有发起请求的浏览器才可以缓存  no-cache, 告诉浏览器、缓存服务器，不管本地副本是否过期，使用资源副本前，一定要到源服务器进行副本有效性校验  no-cache 从字面意义上很容易误解为不缓存，但是 no-cache 代表不缓存过期的资源，缓存会向服务器进行有效处理确认之后处理资源  ### 到期  max-age=< seconds >, 缓存到多少秒过期  s-maxage=< seconds >, 会代替 max-age, 只有在代理服务器才会生效, 浏览器还是会读取 max-age  max-stale=< seconds >, 发起请求方主动带的头信息, 代表即便缓存已经过期, 在 max-stale 设置的时间内还是会读取缓存, 浏览器用不到.  ### 重新验证  must-revalidate, 设置了 max-age 并且已经过期了, 那么会重新发起请求到原服务端获取数据看是否真的过期, 而不是直接使用缓存  proxy-revalidate,同 must-revalidate 只不过用在代理服务器上.  ### 其他  no-store, 永远都要去服务器拿新的内容,no-store 才是真正的不进行缓存.  no-transform, 用于缓存服务器中,告诉代理服务器不要随意改动内容  前端最常见的是更新文件时按文件内容设置 hash 类似 72.63f2ae81.js, 这样如果文件内容改变, hash 就变化了, 浏览器就会拿到新的文件.  ## Last-Modified 和 Etag  ### 验证头  - Last-Modified - Etag  ### Last-Modified  根据上次修改时间  配合 If-Modified-Since 或者 If-Unmodified-Since 使用  也就是浏览器下次发起请求会带上 If-Modified-Since 头信息, 值就是 服务器返回 Last-Modified 的值.  对比上次修改时间以验证资源是否需要更新  ### Etag  根据数据签名 (常用的是 hash 计算)  配合 If-match 或者 If-Non-Match 使用  也就是浏览器下次发起请求会带上 If-match 或者 If-Non-Match 头信息, 值就是服务器返回的 Etag 的值.  对比资源的签名判断是否使用缓存  ### 设置  设置从缓存读取的话就不重新发送内容 ![F4smUs.md.png](https://s1.ax1x.com/2018/12/31/F4smUs.md.png)  ```js if (request.url === '/script.js') {   const etag = request.headers['if-none-match'];   if (etag === '777') {     response.writeHead(304, {       'Content-Type': 'text/javascript',       'Cache-Control': 'max-age=2000000, no-cache',       'Last-Modified': '123',       Etag: '777'     });     response.end('');   } else {     response.writeHead(200, {       'Content-Type': 'text/javascript',       'Cache-Control': 'max-age=2000000, no-cache',       'Last-Modified': '123',       Etag: '777'     });     response.end('console.log(\"script loaded\")');   } } ```  ## cookie 和 session  ### cookie  服务器通过 Set-Cookie 这个 header 设置到浏览器里面, 保存在浏览器  下次同域的请求中就会带上这个 cookie  键值对, 可以设置多个  ### cookie 属性  max-age 和 expires 设置过期时间  secure 只在 https 的时候发送  设置 http-only 后, 无法通过 document.cookie 访问  ### 设置过期时间  'Set-Cookie': ['id=123;max-age=2']  ### cookie domain  设置 domain 可以让 test.a.com 访问到 a.com 的 cookie.  ```js const http = require('http'); const fs = require('fs'); http   .createServer(function(request, response) {     console.log('request come', request.url);      const host = request.headers.host;      if (request.url === '/') {       const html = fs.readFileSync('test.html', 'utf-8');        if (host === 'test.com') {         response.writeHead(200, {           'Content-Type': 'text/html',           'Set-Cookie': ['id=123;max-age=2;domain=test.com']         });       }       response.end(html);     }   })   .listen(8888);  console.log('server run 8888'); ```  ### session  session 有很多种实现方式, 经常用的是 cookie 而已.  比如服务器可以根据 cookie 里面的一个唯一 key 然后去查用户信息, 只要能定位用户, 就是 session.  不一定要 cookie, 也可以 js 写在 header 中.  ## HTTP 长连接  在一个 tcp 连接发 多个 http 请求.  长连接会复用 tcp 连接, chrome 并发是 6 个.  Connection: keep-alive 表示长连接开启.  'Connection': 'close' 关闭常长连接:  ## 数据协商  客户端给服务端发送请求的时候, 客户端会在请求头中声明我希望拿到的数据格式及数据相关的限制是怎样的,  服务端会根据客户端请求, 做出判断, 再具体返回什么.  ### 分类  请求 和 返回  ### 请求  #### Accept  Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,_/_;q=0.8  指定想要的数据类型(根据 MIME 类型告诉服务端想要什么)  #### Accept-Encoding  Accept-Encoding: gzip, deflate, br  数据的编码方式, 主要是告诉服务端怎样的一个数据压缩(数据压缩算法有很多 gzip, deflate, br 等)  #### Accept-Language  Accept-Language: zh-CN,zh;q=0.9,en;q=0.8  语言, 比如中文, q 表示权重  #### User-Agent  User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.92 Safari/537.36  Mozilla/5.0 网景浏览器的头  Windows NT 10.0; WOW64 操作系统版本  AppleWebKit/537.36 表示 苹果公司开发的 WebKit 内核  KHTML 类似 火狐的 Gecko 的渲染引擎  Chrome/69.0.3497.92 浏览器版本号  Safari/537.36 因为是苹果的 webkit 内核, 所以会加上这个  浏览器相关的信息, 移动端还是 PC.  ### 返回  #### Content-Type  对应请求中的 Accept, Accept 可以有很多种类型, Content-Type 可以从里面选择一种返回  可以设置 X-Content-Type-Options: nosniff, 禁止浏览器根据内容去预测类型, 为了安全性.  #### Content-Encoding  对应 Accept-Language  #### Content-Language  对应 Accept-Language  #### 服务端不返回 User-Agent  数据在整个传输过程中大小: 包含 http headers 和 body 和首行信息  数据拿到后并且根据 Content-Encoding 解压后的 body 实际内容大小, 不是 传输里面的 body 大小  ### MIME 类型  application/x-www-form-urlencoded  ```html <form   action=\"/form\"   method=\"post\"   enctype=\"application/x-www-form-urlencoded \" >   <input type=\"text\" name=\"name \" />   <input type=\"password\" name=\"password \" /> <input type=\"submit \" /> </form> ```  请求头:  ``` Content-Type: application/x-www-form-urlencoded  name=1&password=1 ```  multipart/form-data  ```html <form action=\"/form\" method=\"post\" enctype=\"multipart/form-data \">   <input type=\"text\" name=\"name\" />   <input type=\"password\" name=\"password\" />   <input type=\"submit\" /> </form> ```  请求头:  ``` Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryIyBOcYI2n3gyM9IQ  // ----WebKitFormBoundaryIyBOcYI2n3gyM9IQ 用来分隔表单每一项 ```  ``` ------WebKitFormBoundaryIyBOcYI2n3gyM9IQ Content-Disposition: form-data; name=\"name\"  3 ------WebKitFormBoundaryIyBOcYI2n3gyM9IQ Content-Disposition: form-data; name=\"password\"  4 ------WebKitFormBoundaryIyBOcYI2n3gyM9IQ Content-Disposition: form-data; name=\"file\"; filename=\"url-tcp.png\" Content-Type: image/png  ------WebKitFormBoundaryIyBOcYI2n3gyM9IQ-- ```  ## Redirect  服务器告诉浏览器你要的资源在什么地方, 浏览器重新请求新的地址  ### 302 临时跳转  ```js const http = require('http');  http   .createServer(function(request, response) {     console.log('request come', request.url);      if (request.url === '/') {       response.writeHead(302, {         Location: '/new'       });       response.end('');     }     if (request.url === '/new') {       response.writeHead(200, {         'Content-Type': 'text/html'       });       response.end('< div >this is conetnt< div >');     }   })   .listen(8888);  console.log('server run 8888'); ```  ### 301 永远跳转  ```js response.writeHead(301, {   Location: '/new' }); ```  只有第一次是 301, 以后每次否是请求最新的了. 直接在浏览器变成新的路径, 不需要再去服务器指定新的 location.  from disk 已经存到浏览器了.注意: 301 不会主动失效, 只有当用户清除缓存才行.  ## Content-Security-Policy  [内容安全策略](https://developer.mozilla.org/zh-CN/docs/Glossary/CSP)  ### 作用  - 限制资源获取 - 报告资源获取越权  ### 限制方式  default-src 全局限制  指定资源类型 ![F4hGq0.md.png](https://s2.ax1x.com/2019/01/01/F4hGq0.md.png)  ### 限制只能外链  ``` 'Content-Security-Policy': 'default-src http: https:' 1 ```  ### 限制只能加载本站点脚本  ``` 'Content-Security-Policy': 'default-src \\'self\\'' 1 ```  ### 限制 form 为本站  ``` 'Content-Security-Policy': 'default-src \\'self\\'; form-action \\'self\\'' 1 ```  ### 只限制 script  ``` 'Content-Security-Policy': 'script-src \\'self\\'' 1 ```  ### 上报路径  如果触发 CSP 则请求 上报接口  ``` 'Content-Security-Policy': 'script-src \\'self\\'; report-uri /repoert' ```  ### 设置是上报, 但是给他加载资源:  ``` 'Content-Security-Policy-Report-Only': 'script-src \\'self\\'; report-uri /repoert' ```  ### html 中设置 meta 和服务端设置 header 都行  report-uri 需要在 header 才能设置.  ```html <head>   <meta charset=\"UTF-8 \" />   <title>Document</title>   <meta     http-equiv=\"Content-Security-Policy\"     content=\"script-src 'self'; form-action 'self'\"   /> </head> ``` "},{title:"从用途出发总结flex布局",path:"/posts/%E4%BB%8E%E7%94%A8%E9%80%94%E5%87%BA%E5%8F%91%E6%80%BB%E7%BB%93flex%E5%B8%83%E5%B1%80.html",strippedContent:' ## 简介  CSS3 弹性盒子(Flexible Box 或 Flexbox)，是一种用于在页面上布置元素的布局模式，使得当页面布局必须适应不同的屏幕尺寸和不同的显示设备时，元素可预测地运行/列。对于许多应用程序，弹性盒子模型提供了对块模型的改进，因为它不使用浮动，flex 容器的边缘也不会与其内容的边缘折叠。  ### 注意点  弹性盒模型,分老版与新版,老版本的我们通常称之为 box,新版本的我们通常称之为 flex.   有了新版本后，为什么还需要老版本？（新版本比老版本要强大的很多）很多移动端浏览器内核版本都超低  - 老版:容器设置 display 为 webkit-box - 新版:容器设置 display 为-webkit-flex 或 flex - 行内元素:也可以使用 Flex 布局,设置 display: inline-flex - 注意，设为 Flex 布局以后，子元素的 float、clear 和 vertical-align 属性将失效。  ## 基本概念  ### 容器和项目  采用 Flex 布局的元素，称为 Flex 容器（flex container），简称"容器"。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称"项目"。  ### 主轴和侧轴  容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴,我把它叫侧轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做 main start，结束位置叫做 main end；交叉轴的开始位置叫做 cross start，结束位置叫做 cross end。  项目默认沿主轴排列。单个项目占据的主轴空间叫做 main size，占据的交叉轴空间叫做 cross size。  ## 容器上的属性  - flex-direction - flex-wrap - flex-flow - justify-content - align-items - align-content  ### 项目的布局方向  因为项目永远是在主轴上排列的,所以只要改变主轴方向就可控制容器是往左布局还是往右布局.  #### 老版  -webkit-box-orient 属性本质上确定了主轴是哪一根  - horizontal:x 轴 - vertical:y 轴  #### 新版  - 主轴为水平方向，起点在右端:flex-direction: row; - 主轴为垂直方向，起点在上沿:flex-direction: column;  ### 如果一条轴线排不下，如何换行  - 老版:默认盒子小溢出不换行，不可改 - 新版:默认盒子小挤小不换行，可改   - flex-wrap(不可继承)     - 默认值：nowrap     - nowrap:不换行     - wrap：换行，第一行在上方     - wrap-reverse：换行，第一行在下方。  ### flex-direction,flex-wrap 的简写:flex-flow  flex-flow 属性是 flex-direction 属性和 flex-wrap 属性的简写形式，默认值为 row nowrap。  默认值：row nowrap,不可继承  ### 项目排列顺序  因为项目永远是沿着主轴的正方向排列的,所以我们只需要关心主轴的正方向  #### 老版  -webkit-box-direction 属性本质上改变了主轴的方向  - normal;x 轴 - reverse;y 轴  #### 新版  在新版的弹性盒模型中我们只需要一个：flex-direction：四个属性值  - 主轴为垂直方向，起点在上沿:flex-direction:row-reverse; - 主轴为垂直方向，起点在下沿:flex-direction:column-reverse;  ### 富裕空间的管理  #### 老版  富裕空间的位置跟项目排列顺序都无关，只跟主轴是哪一根有关,使用属性-webkit-box-pack  ##### 主轴是 x 轴  (其实可以根据语义判断,所谓的左对齐右对齐等等都是把当前主轴上的项目往左靠,往右靠等等,主轴不同,布局自然改变)  - start（默认值）：左对齐   - 效果是富裕空间在 x 轴的在右边,y 轴的在下边 - end：右对齐   - 效果是富裕空间在 x 轴的在左边,y 轴的在下边 - center：居中   - 效果是富裕空间在 x 轴,y 轴都在两边 - justify：两端对齐，项目之间的间隔都相等。   - 效果是富裕空间在 x 轴,y 轴的项目之间  ##### 主轴是 y 轴  (其实可以根据语义判断,所谓的左对齐右对齐等等都是把当前主轴上的项目往左靠,往右靠等等,主轴改变,自然改变)  - start（默认值）：左对齐   - 效果是富裕空间在 x 轴的在左边,y 轴的在上边 - end：右对齐   - 效果是富裕空间在 x 轴的在右边,y 轴的在上边 - center：居中   - 效果是富裕空间在 x 轴,y 轴都在两边 - justify：两端对齐，项目之间的间隔都相等。   - 效果是富裕空间在 x 轴,y 轴的项目之间  #### 新版  富裕空间分布跟主轴是哪一根有关  ##### 主轴是 x 轴或 y 轴  使用属性 justify-content,原理和表现和老版一样  - flex-start（默认值）：左对齐 - flex-end：右对齐 - center： 居中 - space-between：两端对齐，项目之间的间隔都相等。 - space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍  ### 单行项目在侧轴上如何对齐  align-items 属性定义项目在侧轴上如何对齐。  - flex-start：交叉轴的起点对齐。 - flex-end：交叉轴的终点对齐。 - center：交叉轴的中点对齐。 - baseline: 项目的第一行文字的基线对齐。 - stretch（默认值）：如果项目未设置高度或设为 auto，将占满整个容器的高度。  ### 多行或多列项目在侧轴上如何对齐  align-content 属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。  - flex-start：与交叉轴的起点对齐。 - flex-end：与交叉轴的终点对齐。 - center：与交叉轴的中点对齐。 - space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。 - space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。 - stretch（默认值）：轴线占满整个交叉轴。  ## 项目的属性  - order - flex-grow - flex-shrink - flex-basis - flex - align-self  ### 手动改变项目的排列顺序  order 属性规定了弹性容器中的可伸缩项目在布局时的顺序。元素按照 order 属性的值的增序进行布局。拥有相同 order 属性值的元素按照它们在源代码中出现的顺序进行布局，order 越大越靠后  默认值：0 不可继承  ### 伸缩规则计算的基准值  flex-basis 属性定义了在分配多余空间之前，项目占据的主轴空间（main size）既是 flex 元素在主轴方向上的初始大小。浏览器根据这个属性，计算主轴是否有多余空间。  默认值 ：auto 不可继承，即项目的本来大小(默认拿 width 或 height 的值)。  注意：在 flex 简写属性中 flex-basis 的默认值为 0  ### 定义项目的放大比例,塞满容器  flex-grow 属性定义项目的放大比例，默认为 0，即如果存在剩余空间，也不放大。放大的前提是有可用空间  #### 计算规则  - 可用空间 = (容器大小 - 所有项目 flex-basis（没有就拿 width 或 height 的值）的总和) - 可扩展空间 = (可用空间/所有项目 flex-grow 的总和) - 每项伸缩后大小 = (flex-basis + (可扩展空间 x flex-grow 值)) - 所以当有的项目用到了 flex-grow,有的没有,不会影响到没有用到的大小  ### 定义项目的缩小比例,让项目不溢出容器  flex-shrink 属性定义了项目的缩小比例，默认为 1，即如果空间不足，该项目将缩小。缩小的前提是没有可用空间,和只有在 flex-wrap:nowrap 时才有作用,负值对该属性无效。  #### 计算规则  - 计算收缩因子与项目基准值乘的总和  ```js var a = flex - basis * 每一项flex - shrink之和; // 200 *1+ 50*1+ 50*1+ 50*1+ 50*1 = 400 ```  - 计算收缩因数     收缩因数=（项目的收缩因子\\*项目基准值）/第一步计算总和  ```js var b = (flex - shrink * flex - basis) / a; // 1*200 / 400 = 1/2 // 1*50 / 400 = 1/8 ```  - 移除空间的计算     移除空间= 项目收缩因数 x 负溢出的空间  ```js var c = b * 溢出的空间; // 1/2*300 = 150 // 1/8*300 = 37.5 // 最后200 - 150 =50； //       50 - 37.5 = 12.5 ```  - 不会把元素缩没,填满容器 - 所以如果所有项目的 flex-shrink 属性都为 1，当空间不足时，都将等比例缩小。 - 所以如果一个项目的 flex-shrink 属性为 0，其他项目都为 1，则空间不足时，前者不缩小。  ### flex 简写:flex 属性  flex 属性是 flex-grow, flex-shrink 和 flex-basis 的简写，默认值为 0 1 auto。后两个属性可选。不可继承  该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。  等分布局:flex：1(1 1 0%)  ### 项目在侧轴上如何对齐前提下,设置单个项目  align-self 属性允许单个项目有与其他项目不一样的对齐方式，可覆盖 align-items 属性。  如果任何 flex 元素的侧轴方向 margin 值设置为 auto，则会忽略 align-self。  - auto,auto,表示继承父元素的 align-items 属性，如果没有父元素，则等同于 stretch。 - flex-start：交叉轴的起点对齐。 - flex-end：交叉轴的终点对齐。 - center：交叉轴的中点对齐。 - baseline: 项目的第一行文字的基线对齐。 - stretch：如果项目未设置高度或设为 auto，将占满整个容器的高度。 '},{title:"mvvm源码初体验(3):数据绑定",path:"/posts/mvvm%E6%BA%90%E7%A0%81%E5%88%9D%E4%BD%93%E9%AA%8C-3-%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A.html",strippedContent:" ## 概念  - 数据绑定(model==>View):一旦更新了 data 中的某个属性数据,所有界面上直接使用或间接使用了此属性的节点都会更新 - 数据劫持:数据劫持是 vue 中用来实现数据绑定的一种技术   - 基本思想: 通过 defineProperty()来监视 data 中所有属性(任意层次)数据的变化, 一旦变化就去更新界面  ## 数据劫持:Observer()  - 在 new MVVM 时执行 observe(data, this) - observe()负责判断 vm.\\_data 是不是一个对象,然后创建一个对应的观察者对象 new Observer(value) - Observer(value)保存 vm.\\_data 对象到当前观察者对象的实例的 data 属性中,然后调用 walk() - walk()中遍历 data 中所有属性,对每个属性调用 convert() - convert()对指定属性实现响应式数据绑定 this.defineReactive(this.data, key, val)  ```js function MVVM(options) {   // 对data进行监视,重点是给data的每个属性定义get,set方法   observe(data, this); } ```  ```js function observe(value, vm) {   // value必须是对象, 因为监视的是对象内部的属性   if (!value || typeof value !== 'object') {     return;   }   // 创建一个对应的观察者对象   return new Observer(value); } ```  ```js function Observer(data) {   // 保存data对象   this.data = data;   // 走起   this.walk(data); } ```  ```js walk: function(data) {     var me = this;     // 遍历data中所有属性     Object.keys(data).forEach(function(key) {         // 针对指定属性进行处理         me.convert(key, data[key]);     }); }, ```  ```js convert: function(key, val) {     // 对指定属性实现响应式数据绑定     this.defineReactive(this.data, key, val); }, ```  ## 负责记录订阅:dep()  - this.defineReactive()中首先创建一个 dep 对象 new Dep() - dep()的实例中首先保存一个 id 标识当前属性,然后创建一个 subs 属性,是一个保存相关的所有 watcher 的数组 - 然后 this.defineReactive()间接递归调用实现对 data 中所有层次属性的劫持 observe(val),当 val 不是一个对象,在 observe()判断 data 中就会退出递归 - 然后给 vm.\\_data 中的属性定义属性(添加 set/get) - 其中 getter 中首先判断,,Dep.target 的初始值 null,所以不执行 dep.depend() - getter 最后返回 vm.\\_data 中对应属性 - setter 中首先把新值保存到 vm.\\_data 对应属性中,然后如果设置的新值是 object 的话，进行监听 observe(newVal) - 最后执行 dep.notify(),它负责遍历当前属性的 dep 实例中的 subs,调用每个元素的 update(),通知所有相关的 watcher(一个订阅者)去更新页面  ```js defineReactive: function(data, key, val) {     // 创建与当前属性对应的dep对象     var dep = new Dep();     // 间接递归调用实现对data中所有层次属性的劫持     var childObj = observe(val);     // 给data重新定义属性(添加set/get)     Object.defineProperty(data, key, {         enumerable: true, // 可枚举         configurable: false, // 不能再define         get: function() {             // 建立dep与watcher的关系             if (Dep.target) {                 dep.depend();             }             // 返回属性值             return val;         },         set: function(newVal) {             if (newVal === val) {                 return;             }             val = newVal;             // 新的值是object的话，进行监听             childObj = observe(newVal);             // 调用每个元素的update()             dep.notify();         }     }); } ```  ```js function Dep() {   // 标识属性   this.id = uid++;   // 相关的所有watcher的数组   this.subs = []; } ```  ```js Dep.prototype = {   notify: function() {     // 通知所有相关的watcher(一个订阅者)     this.subs.forEach(function(sub) {       sub.update();     });   } };  Dep.target = null; ```  ## 负责更新节点:Watcher()  - 由于刚开始 dep.subs 是空,所以 Watcher()第一次发生在模板编译中 - 模板中每一个用到模板语法并且用了 vm.\\_data 的值的地方在刚开始解析时通过调用 Watcher(),向它传进对应的更新节点的函数 -  ```js     // 真正用于解析指令的方法     bind: function(node, vm, exp, dir) {         // 创建表达式对应的watcher对象         new Watcher(vm, exp, function(value, oldValue) {             /*更新界面*/             // 当对应的属性值发生了变化时, 自动调用, 更新对应的节点             updaterFn && updaterFn(node, value, oldValue);         });     }, ```  - Watcher()首先在实例中创建五个属性,get()负责获取值   - vm:vm 对象,   - exp:对应指令的表达式,   - cb:当表达式所对应的数据发生改变的回调函数,   - value:表达式当前的值,   - depIds:表达式中各级属性所对应的 dep 对象的 id  ```js function Watcher(vm, exp, cb) {   this.cb = cb; // callback   this.vm = vm;   this.exp = exp;   this.depIds = {}; // {0: d0, 1: d1, 2: d2}   this.value = this.get(); } ```  - get()中 Dep.target=this,this 是 Watcher()的当前实例  ```js   get: function () {     Dep.target = this;     // 获取当前表达式的值, 内部会导致属性的get()调用     var value = this.getVMVal();      Dep.target = null;     return value;   }, ```  - 然后调用 gteVMVal(),遍历表达式中所有用到 vm.\\_data 的值的地方,去 vm.\\_data 中取值  ```js   getVMVal: function () {     var exp = this.exp.split('.');     var val = this.vm._data;     exp.forEach(function (k) {       val = val[k];     });     return val;   } ```  - 取值导致下面代码运行  ```js if (Dep.target) {   dep.depend(); } dep.notify(); ```  - Dep.target 此时不是是 Watcher()的当前实例是 Watcher()的当前实例,dep.depend()负责往 dep 对象的 subs 属性添加 Dep.target  ```js depend: function() {     Dep.target.addDep(this); }, ```  - 如果 depIds 中没有 dep. id,则把当前 watcher 添加到 dep 的 subs 中,还把 dep.id 添加到当前 watcher 的 depIds 中,建立 watcher 到 dep 的关系  ```js   addDep: function (dep) {     if (!this.depIds.hasOwnProperty(dep.id)) {       // 建立dep到watcher       dep.addSub(this);       // 建立watcher到dep的关系       this.depIds[dep.id] = dep;     }   }, ```  ```js addSub: function(sub) {     this.subs.push(sub); }, ```  - 然后调用 dep.notify()  ```js     notify: function() {         // 通知所有相关的watcher(一个订阅者)         this.subs.forEach(function(sub) {             sub.update();         });     } ```  - 里面调用 sub.update()去更新节点  ```js Watcher.prototype = {   update: function() {     this.run();   },   run: function() {     // 得到最新的值     var value = this.get();     // 得到旧值     var oldVal = this.value;     // 如果不相同     if (value !== oldVal) {       this.value = value;       // 调用回调函数更新对应的界面       this.cb.call(this.vm, value, oldVal);     }   } }; ```  ## 双向数据绑定  双向数据绑定是建立在单向数据绑定(model==>View)的基础之上的   双向数据绑定的实现流程:  - 在解析 v-model 指令时, 给当前元素添加 input 监听 - 当 input 的 value 发生改变时, 将最新的值赋值给当前表达式所对应的 data 属性 - 当把最新的值赋值给当前表达式所对应的 data 属性,触发 setter  ```js     // 解析: v-model     model: function(node, vm, exp) {         this.bind(node, vm, exp, 'model');          var me = this,             val = this._getVMVal(vm, exp);         node.addEventListener('input', function(e) {             var newValue = e.target.value;             if (val === newValue) {                 return;             }              me._setVMVal(vm, exp, newValue);             val = newValue;         });     }, ```  ```js     _setVMVal: function(vm, exp, value) {         var val = vm._data;         exp = exp.split('.');         exp.forEach(function(k, i) {             // 非最后一个key，更新val的值             if (i < exp.length - 1) {                 val = val[k];             } else {                 val[k] = value;             }         });     } ```  ## 总结:四个重要对象  ### Observer  - 用来对 data 所有属性数据进行劫持的构造函数 - 给 data 中所有属性重新定义属性描述(get/set) - 为 data 中的每个属性创建对应的 dep 对象  ### Dep(Depend)  - data 中的每个属性(所有层次)都对应一个 dep 对象 - 创建的时机:   - 在初始化 define data 中各个属性时创建对应的 dep 对象   - 在 data 中的某个属性值被设置为新的对象时 - 对象的结构  ``` {     id, // 每个dep都有一个唯一的id     subs //包含n个对应watcher的数组(subscribes的简写)   } ```  - subs 属性说明   - 当一个 watcher 被创建时, 内部会将当前 watcher 对象添加到对应的 dep 对象的 subs 中   - 当此 data 属性的值发生改变时, 所有 subs 中的 watcher 都会收到更新的通知, 从而最终更新对应的界面  ### Compile  - 用来解析模板页面的对象的构造函数(一个实例) - 利用 compile 对象解析模板页面 - 每解析一个表达式(非事件指令)都会创建一个对应的 watcher 对象, 并建立 watcher 与 dep 的关系 - complie 与 watcher 关系: 一对多的关系  ### Watcher  - 模板中每个非事件指令或表达式都对应一个 watcher 对象 - 监视当前表达式数据的变化 - 创建的时机: 在初始化编译模板时 - 对象的组成  ``` {     vm,  //vm对象     exp, //对应指令的表达式     cb,//当表达式所对应的数据发生改变的回调函数     value, //表达式当前的值     depIds//表达式中各级属性所对应的dep对象的集合对象          //属性名为dep的id, 属性值为dep } ```  ### dep 与 watcher 的关系  - 一个 data 中的属性对应对应一个 dep, 一个 dep 中可能包含多个 watcher(模板中有几个表达式使用到了属性) - 模板中一个非事件表达式对应一个 watcher, 一个 watcher 中可能包含多个 dep(表达式中包含了几个 data 属性) "},{title:"mvvm源码初体验(2):模板解析",path:"/posts/mvvm%E6%BA%90%E7%A0%81%E5%88%9D%E4%BD%93%E9%AA%8C-2-%E6%A8%A1%E6%9D%BF%E8%A7%A3%E6%9E%90.html",strippedContent:" mvvm 实现模板解析的关键对象是 compile 对象,它在 compile.js 中,它是一个构造函数,在 mvvm.js 中的构造方法中运行,本文的模板解析只发生在 new MVVM 时运行一次:  ```js // 创建一个用来编译模板的compile对象 this.$compile = new Compile(options.el || document.body, this); ```  当 new MVVM 时,引发 Compile 调用,对它传入当前选项对象中 el 属性的值,如果没有,则传入当前文档的 body 部分,同时传入当前的实例.  ## 取出所有子节点  1. 把当前 MVVM 实例保存到当前 compile 实例的\\$vm 属性中  ```js this.$vm = vm; ```  2. 判断当前传入的选项对象中的 el 属性的值,  - 如果是不是一个元素节点,是就保存到当前 compile 实例的\\$el 中, - 如果不是则把它传入 document.querySelector(),保存方法返回的元素节点.  ```js // 保存el元素 this.$el = this.isElementNode(el) ? el : document.querySelector(el); ```  其中 isElementNode()方法  ```js Compile.prototype = {   isElementNode: function(node) {     return node.nodeType == 1;   } }; ```  3. 判断 this.$el是否存在,如果存在,首先将el的所有子节点取出,添加到一个新建的文档fragment对象中,然后保存到当前Compile实例的$fragment 属性中  ```js // 如果el元素存在 if (this.$el) {   // 1. 取出el中所有子节点, 封装在一个framgment对象中   this.$fragment = this.node2Fragment(this.$el); } ```  因为 Node.appendChild()方法如果被插入的节点已经存在于当前文档的文档树中,则那个节点会首先从原先的位置移除,然后再插入到新的位置.   所以其中 this.nodeFragment()的实现细节如下,  - 首先创建一个 DocumentFragment,用来装载 el 的所有子节点,一个 child 变量用来运输一个个子节点 - 循环检查 el 的第一个子节点,如果存在,则把它剪切到 DocumentFragment 里 - 最后当 el 中没有了子节点,循环结束,函数也结束,返回 DocumentFragment,其中装有所有 el 的子节点  ```js Compile.prototype = {   node2Fragment: function (el) {     var fragment = document.createDocumentFragment(),       child;      // 将原生节点拷贝到fragment     while (child = el.firstChild) {       fragment.appendChild(child);     }      return fragment;   } ```  ## 编译子节点  4. 然后编译 fragment 中所有层次子节点,解析其中的插值和指令,得到最终包含对应真实数据的节点.  ```js function Compile(el, vm) {   // 保存vm   this.$vm = vm;   // 保存el元素   this.$el = this.isElementNode(el) ? el : document.querySelector(el);   // 如果el元素存在   if (this.$el) {     // 1. 取出el中所有子节点, 封装在一个framgment对象中     this.$fragment = this.node2Fragment(this.$el);     // 2. 编译fragment中所有层次子节点     this.init();   } } ```  然后 this.init()的实现细节,其实就是调用一个新方法 this.compileElement(),同时把已经完全取出的 el 的子节点 this.\\$fragment 传入给它使用.  ```js Compile.prototype = {   init: function() {     // 编译fragment     this.compileElement(this.$fragment);   } }; ```  所以我们来看看 this.compileElement()方法的实现细节. 5.this.compileElement()能解析表达式文本节点和指令  - 得到所有子节点,保存到变量 childNodes 中,保存保存当前 compile 实例到变量 me 中, - 保存所有子节点转为数组,然后遍历, - 判断每一个数组元素,如果是元素节点,则编译元素节点的指令属性 - 如果是个文本节点且其文本内容中有用到大括号表达式,则编译大括号表达式的内容 - 如果子节点还有子节点,则把该节点传入 me.compileElement(),递归调用实现所有层次节点的编译  ```js Compile.prototype = {   compileElement: function(el) {     // 得到所有子节点     var childNodes = el.childNodes,       // 保存当前compile实例       me = this;     // 遍历所有子节点     [].slice.call(childNodes).forEach(function(node) {       // 得到节点的文本内容       var text = node.textContent;       // 正则对象(匹配大括号表达式)       var reg = /\\{\\{(.*)\\}\\}/; // {{name}}       // 如果是元素节点       if (me.isElementNode(node)) {         // 编译元素节点的指令属性         me.compile(node);         // 如果是一个大括号表达式格式的文本节点       } else if (me.isTextNode(node) && reg.test(text)) {         // 编译大括号表达式格式的文本节点         me.compileText(node, RegExp.$1); // RegExp.$1: 表达式   name       }       // 如果子节点还有子节点       if (node.childNodes && node.childNodes.length) {         // 递归调用实现所有层次节点的编译         me.compileElement(node);       }     });   } }; ```  ## 解析表达式文本节点  首先来看看 me.compileText()实现细节:  - me.compileText()调用 compileUtil.text()得到对应的 this.bind(node, vm, exp, 'text') - compileUtil.text()调用 this.bind(node, vm, exp, 'text')得到对应的更新节点函数 updater.textUpdater() - 然后调用 this.\\_getVMVal(vm, exp)来获得对应 vm.\\_data 中的属性值 - 最后调用 updater.textUpdater()并且把值传入 - updater.textUpdater()里面判断 val,更新 fragment 中此时对应子节点的 textContent 的值,如果是 undefined 此时对应子节点的 textContent 为空  compileText()  ```js   compileText: function (node, exp) {     // 调用编译工具对象解析     compileUtil.text(node, this.$vm, exp);   }, ```  compileUtil.text()  ```js var compileUtil = {   // 解析: v-text/{{}}   text: function(node, vm, exp) {     this.bind(node, vm, exp, 'text');   } }; ```  this.bind()  ```js   // 真正用于解析指令的方法   bind: function (node, vm, exp, dir) {     /*实现初始化显示*/     // 根据指令名(text)得到对应的更新节点函数     var updaterFn = updater[dir + 'Updater'];     // 如果存在调用来更新节点     updaterFn && updaterFn(node, this._getVMVal(vm, exp));   }, ```  updater.textUpdater()  ```js // 包含多个用于更新节点方法的对象 var updater = {   // 更新节点的textContent   textUpdater: function (node, value) {     node.textContent = typeof value == 'undefined' ? '' : value;   }, ```  \\_getVMVal()  ```js   // 得到表达式对应的value   _getVMVal: function (vm, exp) {     var val = vm._data;     exp = exp.split('.');     exp.forEach(function (k) {       val = val[k];     });     return val;   }, ```  ## 解析事件指令  compileElement()中调用 compile()来编译元素节点的指令属性  - 得到所有当前子节点的标签属性 - 转为数组然后遍历 - 取到属性名,判断是否是指令属性 - 如果是就取到表达式(属性值)和指令名 - 判断是否是事件指令 - 如果是则调用 compileUtil.eventHandler(node, me.\\$vm, exp, dir); - 如果不是则调用 compileUtil[dir] && compileUtil\\[dir\\](node, me.\\$vm, exp); - 解析完成就移除指令属性  ```js   compile: function (node) {     // 得到所有标签属性节点     var nodeAttrs = node.attributes,       me = this;     // 遍历所有属性     [].slice.call(nodeAttrs).forEach(function (attr) {       // 得到属性名: v-on:click       var attrName = attr.name;       // 判断是否是指令属性       if (me.isDirective(attrName)) {         // 得到表达式(属性值): test         var exp = attr.value;         // 得到指令名: on:click         var dir = attrName.substring(2);         // 事件指令         if (me.isEventDirective(dir)) {           // 解析事件指令           compileUtil.eventHandler(node, me.$vm, exp, dir);         // 普通指令         } else {           // 解析普通指令           compileUtil[dir] && compileUtil[dir](node, me.$vm, exp);         }          // 移除指令属性         node.removeAttribute(attrName);       }     });   }, ```  所以来看看 compileUtil.eventHandler(node, me.\\$vm, exp, dir);  - 首先首先取到指令对应的事件名 - 取得当前指令的事件处理函数,保存到变量 fn 中,但是前提是 vm.$options.methods 和 vm.$options.methods[exp]都存在 - 如果事件名和处理函数都存在则绑定指定事件名和回调函数的 DOM 事件监听, 将回调函数中的 this 强制绑定为当前实例 vm  ```js // 指令处理集合 var compileUtil = {   // 事件处理   eventHandler: function(node, vm, exp, dir) {     // 得到事件名/类型: click     var eventType = dir.split(':')[1],       // 根据表达式得到事件处理函数(从methods中): test(){}       fn = vm.$options.methods && vm.$options.methods[exp];     // 如果都存在     if (eventType && fn) {       // 绑定指定事件名和回调函数的DOM事件监听, 将回调函数中的this强制绑定为vm       node.addEventListener(eventType, fn.bind(vm), false);     }   } }; ```  ## 解析一般指令  从上面可以知道处理解析一般指令的函数是  ```js compileUtil\\[dir\\] && compileUtil\\[dir\\](node, me.$vm, exp) ```  当指令存在时调用 compileUtil\\[dir\\](node, me.\\$vm, exp),如果不存在,则不解析,   下面暂时跳过 v-model,后面再讲.  - 同上面相似,先是得到对应的指令处理函数 compileUtil. xxx - 调用 bind()然后根据指令名(text)得到对应的更新节点函数 - 更新节点函数调用对应的方法更新子节点 - - v-text---textContent 属性 - - v-html---innerHTML 属性 - - v-class--className 属性  ```js // 指令处理集合 var compileUtil = {   // 解析: v-text/{{}}   text: function(node, vm, exp) {     this.bind(node, vm, exp, 'text');   },   // 解析: v-html   html: function(node, vm, exp) {     this.bind(node, vm, exp, 'html');   },   // 解析: v-class   class: function(node, vm, exp) {     this.bind(node, vm, exp, 'class');   } }; ```  ```   // 真正用于解析指令的方法   bind: function (node, vm, exp, dir) {     /*实现初始化显示*/     // 根据指令名(text)得到对应的更新节点函数     var updaterFn = updater[dir + 'Updater'];     // 如果存在调用来更新节点     updaterFn && updaterFn(node, this._getVMVal(vm, exp));   }, ```  ```js // 包含多个用于更新节点方法的对象 var updater = {   // 更新节点的textContent   textUpdater: function(node, value) {     node.textContent = typeof value == 'undefined' ? '' : value;   },    // 更新节点的innerHTML   htmlUpdater: function(node, value) {     node.innerHTML = typeof value == 'undefined' ? '' : value;   },    // 更新节点的className   classUpdater: function(node, value, oldValue) {     var className = node.className;     className = className.replace(oldValue, '').replace(/\\s$/, '');     var space = className && String(value) ? ' ' : '';     node.className = className + space + value;   } }; ```  ## 将解析后的 fragment 添加到 el 中显示  ```js function Compile(el, vm) {     // 3. 将fragment添加到el中     this.$el.appendChild(this.$fragment);   } } ``` "},{title:"mvvm源码初体验(1):数据代理",path:"/posts/mvvm%E6%BA%90%E7%A0%81%E5%88%9D%E4%BD%93%E9%AA%8C-1-%E6%95%B0%E6%8D%AE%E4%BB%A3%E7%90%86.html",strippedContent:" 参考 Vue.js,作为一个 MVVM 框架的基本实现原理要包括:  - 数据代理 - 模板解析 - 数据绑定  本文不直接阅读 Vue 的源码,而是剖析 github 上仿 vue 实现的[mvvm](https://github.com/DMQ/mvvm)库,为以后阅读 Vue 源码打基础.  ## 知识准备  ### DocumentFragment  引用[MDN](https://developer.mozilla.org/zh-CN/docs/Web/API/DocumentFragment):  > DocumentFragment 接口表示一个没有父级文件的最小文档对象。它被当做一个轻量版的 Document 使用，用于存储已排好版的或尚未打理好格式的 XML 片段。最大的区别是因为 DocumentFragment 不是真实 DOM 树的一部分，它的变化不会引起 DOM 树的重新渲染的操作(reflow) ，且不会导致性能等问题。  这个接口用来创建一个文档对象,可以联想到 Vue 的虚拟 DOM,MVVM 用它来复制目标 DOM 到内存中,所有的 DOM 操作尽量在此修改,再插入到真实 DOM 中,从而尽量减少 DOM 的修改,提高性能.  ## 数据代理  ### 概念  通过一个对象代理对另一个对象中属性的操作(读/写)  在 MVVM 中就是通过 vm(实例)对象的\\_data 属性来代理 data 对象中所有属性的操作,读 data 的属性读的是 vm.\\_data 的属性,写的是 vm.\\_data 的属性,然后内部去检测\\_data 的变化,而不是 data.  好处: 更方便的操作 data 中的数据  ### 源码  发生在 new MVVM 时,来看看源码的带注释版,就在 mvvm.js 文件,不过是带删减版,只留下实现数据代理的代码:  ```js function MVVM(options) {   // 将选项对象保存到vm   this.$options = options;   // 将data对象保存到vm和data变量中   var data = (this._data = this.$options.data);   //将实例vm保存在me变量中   var me = this;   // 遍历data中所有属性   Object.keys(data).forEach(function(key) {     // 对指定属性实现代理     me._proxy(key);   }); } ```  实例的方法\\_proxy()如下  ```js MVVM.prototype = {   // 对指定属性实现代理   _proxy: function(key) {     // 保存vm     var me = this;     // 给vm添加指定属性名的属性(使用属性描述)     Object.defineProperty(me, key, {       configurable: false, // 不能再重新定义       enumerable: true, // 可以枚举       // 当通过vm.name读取属性值时自动调用       get: function proxyGetter() {         // 读取data中对应属性值返回(实现代理读操作)         return me._data[key];       },       // 当通过vm.name = 'xxx'时自动调用       set: function proxySetter(newVal) {         // 将最新的值保存到data中对应的属性上(实现代理写操作)         me._data[key] = newVal;       }     });   } }; ```  ### 基本实现流程  1. 在 new MVVM 的时候,首先把传进来的选项对象保存到实例的\\$option 属性中; 2. 然后把 vm.\\$option.data 保存到实例的\\_data 属性中; 3. 遍历\\_data 中的属性,通过 Object.defineProperty()给 vm 添加与 data 对象的属性相同的属性描述符; 4. 其中所有添加的属性都包含 getter/setter,把对当前属性的读和写都重定向到 vm.\\_data 的对应属性中,这样 this.xxx 其实读写的是 this.\\_data.xxx; "},{title:"vue2利用Bus.js进行兄弟(非父子)间组件通信",path:"/posts/vue2%E5%88%A9%E7%94%A8Bus-js%E8%BF%9B%E8%A1%8C%E5%85%84%E5%BC%9F-%E9%9D%9E%E7%88%B6%E5%AD%90-%E9%97%B4%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1.html",strippedContent:" ## 第一种:单独文件  第一种是分开单独文件,需要用到 bus 的每个文件单独 import 一次.  ### Bus.js  添加一个 Bus.js 文件,里面代码如下:  ```js import Vue from 'vue'; export default new Vue(); ```  ### 组件 1  ```js import Bus from './Bus'  export default {     data() {         return {             .........             }       },   methods: {         ....         Bus.$emit('log', 120)     },    } ```  ### 组件 2  ```js import Bus from './Bus'  export default {     data() {         return {             .........             }       },     mounted () {        Bus.$on('log', content => {           console.log(content)         });     } } ```  ## 第二种:根文件  ### main.js  直接将 Bus 注入到 main.js 的 Vue 根对象中,然后在子组件中通过 this.$root.Bus.$on(),this.$root.Bus.$emit()来调用.  ```js import Vue from 'vue'; const Bus = new Vue();  var app = new Vue({   el: '#app',   data: {     Bus   } }); ``` "},{title:"Node.js的path.resolve返回值快速总结",path:"/posts/Node-js%E7%9A%84path-resolve%E8%BF%94%E5%9B%9E%E5%80%BC%E5%BF%AB%E9%80%9F%E6%80%BB%E7%BB%93.html",strippedContent:" ## 参数和返回值设计  - ...paths < string > 路径或路径片段的序列。 - 返回: < string >  接受任意个字符串类型的参数,返回一个字符串值.   生成的路径是规范化后的，且末尾的斜杠会被删除，除非路径是根目录。  ```js console.log(path.resolve('a/')); //c:\\Users\\19624\\Desktop\\demo\\a ```  ## 处理规律  指定的路径序列是从右往左开始处理的，并且对每个参数进行相同规律的一次判断处理,但是先处理的参数不会放在前面,而是按照参数的顺序拼接.  - 长度为零的 path 片段会被忽略。 - 如果没有传入 path 片段，则返回当前工作目录的绝对路径; - 若字符以 / 开头，不会拼接到前面的路径； - 若以 ./ 开头 或者没有符号 则拼接前面路径； - 若以 ../ 开头，拼接前面的路径，且不含最后一节路径；  ```js path.resolve('/foo/bar', './baz'); // returns '/foo/bar/baz'  path.resolve('/foo/bar', 'baz'); // returns '/foo/bar/baz'  path.resolve('/foo/bar', '/baz'); // returns '/baz'  path.resolve('/foo/bar', '../baz'); // returns '/foo/baz'  path.resolve('home', '/foo/bar', '../baz'); // returns '/foo/baz'  path.resolve('home', './foo/bar', '../baz'); // returns '/home/foo/baz'  path.resolve('home', 'foo/bar', '../baz'); // returns '/home/foo/baz'  path.resolve('/foo/bar', './baz'); // returns '/foo/bar/baz'  path.resolve('/foo/bar', 'baz'); // returns '/foo/bar/baz'  path.resolve('/foo/bar', '/baz'); // returns '/baz'  path.resolve('/foo/bar', '../baz'); // returns '/foo/baz'  path.resolve('home', '/foo/bar', '../baz'); // returns '/foo/baz'  path.resolve('home', './foo/bar', '../baz'); // returns '/home/foo/baz'  path.resolve('home', 'foo/bar', '../baz'); // returns '/home/foo/baz' ``` "},{title:"【读书笔记】ES6之模块",path:"/posts/%E3%80%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%91ES6%E4%B9%8B%E6%A8%A1%E5%9D%97.html",strippedContent:" ## 模块简述  模块（Modules）是使用不同方式加载的 JS 文件（与 JS 原先的脚本加载方式相对）。这种不同模式很有必要，因为它与脚本（script）有大大不同的语义：  - 模块代码自动运行在严格模式下，并且没有任何办法跳出严格模式； - 在模块的顶级作用域创建的变量，不会被自动添加到共享的全局作用域，它们只会在模块顶级作用域的内部存在； - 模块顶级作用域的 this 值为 undefined； - 模块不允许在代码中使用 HTML 风格的注释（这是 JS 来自于早期浏览器的历史遗留特性）； - 对于需要让模块外部代码访问的内容，模块必须导出它们； - 允许模块从其他模块导入绑定。  ## ES6 模块语法  ### 静态加载  ES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。比如，CommonJS 模块就是对象，输入时必须查找对象属性。  ```js // CommonJS模块 let { stat, exists, readFile } = require('fs');  // 等同于 let _fs = require('fs'); let stat = _fs.stat; let exists = _fs.exists; let readfile = _fs.readfile; ```  上面代码的实质是整体加载 fs 模块（即加载 fs 的所有方法），生成一个对象（\\_fs），然后再从这个对象上面读取 3 个方法。这种加载称为“运行时加载”，因为只有运行时才能得到这个对象，导致完全没办法在编译时做“静态优化”。  由于 ES6 模块是编译时加载，使得静态分析成为可能。有了它，就能进一步拓宽 JavaScript 的语法，比如引入宏（macro）和类型检验（type system）这些只能靠静态分析实现的功能。  除了静态加载带来的各种好处，ES6 模块还有以下好处。  - 不再需要 UMD 模块格式了，将来服务器和浏览器都会支持 ES6 模块格式。目前，通过各种工具库，其实已经做到了这一点。 - 将来浏览器的新 API 就能用模块格式提供，不再必须做成全局变量或者 navigator 对象的属性。 - 不再需要对象作为命名空间（比如 Math 对象），未来这些功能可以通过模块提供。  ### 严格模式  ES6 的模块自动采用严格模式，不管你有没有在模块头部加上\"use strict\";。  - 严格模式主要有以下限制: - 变量必须声明后再使用 - 函数的参数不能有同名属性，否则报错 - 不能使用 with 语句 - 不能对只读属性赋值，否则报错 - 不能使用前缀 0 表示八进制数，否则报错 - 不能删除不可删除的属性，否则报错 - 不能删除变量 delete prop，会报错，只能删除属性 delete global[prop] - eval 不会在它的外层作用域引入变量 - eval 和 arguments 不能被重新赋值 - arguments 不会自动反映函数参数的变化 - 不能使用 arguments.callee - 不能使用 arguments.caller - 禁止 this 指向全局对象 - 不能使用 fn.caller 和 fn.arguments 获取函数调用的堆栈 - 增加了保留字（比如 protected、static 和 interface）  其中，尤其需要注意 this 的限制。ES6 模块之中，顶层的 this 指向 undefined，即不应该在顶层代码使用 this。  ### export 命令  #### 基本导出  一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，最简单方法就是将 export 放置在任意变量、函数或类声明之前，从模块中将它们公开出去。  ```js // profile.js export var firstName = 'Michael'; export var lastName = 'Jackson'; export var year = 1958; //或者 export {firstName, lastName, year}; ```  上面代码在 export 命令后面，使用大括号指定所要输出的一组变量。它与前一种写法（直接放置在 var 语句前）是等价的，但是应该优先考虑使用这种写法。因为这样就可以在脚本尾部，一眼看清楚输出了哪些变量。 export 命令除了输出变量，还可以输出函数或类（class）。  需要特别注意的是，export 命令规定的是对外的接口，必须与模块内部的变量建立一一对应关系。  ```js // 报错 export 1;  // 报错 var m = 1; export m; ```  上面两种写法都会报错，因为没有提供对外的接口。第一种写法直接输出 1，第二种写法通过变量 m，还是直接输出 1。1 只是一个值，不是接口。正确的写法是下面这样。  ```js // 写法一 export var m = 1;  // 写法二 var m = 1; export {m};  // 写法三 var n = 1; export {n as m}; ```  同样的，function 和 class 的输出，也必须遵守这样的写法。  ```js // 报错 function f() {} export f;  // 正确 export function f() {};  // 正确 function f() {} export {f}; ```  另外，export 语句输出的接口，与其对应的值是动态绑定关系，即通过该接口，可以取到模块内部实时的值。  ```js export var foo = 'bar'; setTimeout(() => (foo = 'baz'), 500); ```  上面代码输出变量 foo，值为 bar，500 毫秒之后变成 baz。  最后，export 命令可以出现在模块的任何位置，只要处于模块顶层就可以。如果处于块级作用域内，就会报错，下一节的 import 命令也是如此。这是因为处于条件代码块之中，就没法做静态优化了，违背了 ES6 模块的设计初衷。  #### 重命名导出  通常情况下，export 输出的变量就是本来的名字，但是可以使用 as 关键字重命名。  ```js function v1() { ... } function v2() { ... }  export {   v1 as streamV1,   v2 as streamV2,   v2 as streamLatestVersion }; ```  ### import 命令  #### 基本导入  使用 export 命令定义了模块的对外接口以后，其他 JS 文件就可以通过 import 命令加载这个模块。  ```js // main.js import { firstName, lastName, year } from './profile.js';  function setName(element) {   element.textContent = firstName + ' ' + lastName; } ```  上面代码的 import 命令，用于加载 profile.js 文件，并从中输入变量。import 命令接受一对大括号，里面指定要从其他模块导入的变量名。大括号里面的变量名，必须与被导入模块（profile.js）对外接口的名称相同。  import 命令输入的变量都是只读的，因为它的本质是输入接口。输入的变量指向的地址是只读的，不能重新赋值.也就是说，不允许在加载模块的脚本里面，改写接口。  ```js import { a } from './xxx.js';  a = {}; // Syntax Error : 'a' is read-only; a.foo = 'hello'; // 合法操作 ```  import 后面的 from 指定模块文件的位置，可以是相对路径，也可以是绝对路径，.js 后缀可以省略。如果只是模块名，不带有路径，那么必须有配置文件，告诉 JavaScript 引擎该模块的位置。  注意，import 命令具有提升效果，会提升到整个模块的头部，首先执行。这种行为的本质是，import 命令是编译阶段执行的，在代码运行之前。  ```js foo();  import { foo } from 'my_module'; ```  由于 import 是静态执行，所以不能使用表达式和变量，这些只有在运行时才能得到结果的语法结构。  ```js // 报错 import { 'f' + 'oo' } from 'my_module';  // 报错 let module = 'my_module'; import { foo } from module;  // 报错 if (x === 1) {   import { foo } from 'module1'; } else {   import { foo } from 'module2'; } ```  最后，import 语句会执行所加载的模块，因此可以有下面的写法。如果多次重复执行同一句 import 语句，那么只会执行一次，而不会执行多次。  ```js import 'lodash'; ```  ```js import { foo } from 'my_module'; import { bar } from 'my_module';  // 等同于 import { foo, bar } from 'my_module'; ```  上面代码仅仅执行 lodash 模块，但是不输入任何值。  #### 重命名导入  如果想为输入的变量重新取一个名字，import 命令要使用 as 关键字，将输入的变量重命名。  ```js import { lastName as surname } from './profile.js'; ```  #### 完全导入一个模块  除了指定加载某个输出值，还可以使用整体加载，即用星号（\\*）指定一个对象，所有输出值都加载在这个对象上面。  ```js import * as circle from './circle';  console.log('圆面积：' + circle.area(4)); console.log('圆周长：' + circle.circumference(14)); ```  注意，模块整体加载所在的那个对象（上例是 circle），应该是可以静态分析的，所以不允许运行时改变。下面的写法都是不允许的。  ```js import * as circle from './circle';  // 下面两行都是不允许的 circle.foo = 'hello'; circle.area = function() {}; ```  ### export default 命令  将一个函数作为默认值进行了导出，default 关键字标明了这是一个默认导出。此函数并不需要有名称，因为它就代表这个模块自身。其他模块加载该模块时，import 命令可以为该匿名函数指定任意名字。  ```js // export-default.js export default function() {   console.log('foo'); }  // import-default.js import customName from './export-default'; customName(); // 'foo' ```  一个模块只能有一个默认输出，因此 export default 命令只能使用一次。所以，import 命令后面才不用加大括号，因为只可能唯一对应 export default 命令。  一个模块只能有一个默认输出，因此 export default 命令只能使用一次。所以，import 命令后面才不用加大括号，因为只可能唯一对应 export default 命令。  ```js // modules.js function add(x, y) {   return x * y; } export { add as default }; // 等同于 // export default add;  // app.js import { default as foo } from 'modules'; // 等同于 // import foo from 'modules'; ```  正是因为 export default 命令其实只是输出一个叫做 default 的变量，所以它后面不能跟变量声明语句。  ```js // 正确 export var a = 1;  // 正确 var a = 1; export default a;  // 错误 export default var a = 1; ```  同样地，因为 export default 命令的本质是将后面的值，赋给 default 变量，所以可以直接将一个值写在 export default 之后。  ```js // 正确 export default 42;  // 报错 export 42; ```  如果想在一条 import 语句中，同时输入默认方法和其他接口，可以写成下面这样。  ```js import _, { each, forEach } from 'lodash'; ```  ### 绑定的再导出  如果在一个模块之中，先输入后输出同一个模块，import 语句可以与 export 语句写在一起。  ```js export { foo, bar } from 'my_module';  // 可以简单理解为 import { foo, bar } from 'my_module'; export { foo, bar };  // 接口改名 export { foo as myFoo } from 'my_module';  // 整体输出 export * from 'my_module';  //默认接口的写法如下。 export { default } from 'foo';  //具名接口改为默认接口 export { es6 as default } from './someModule'; // 等同于 import { es6 } from './someModule'; export default es6;  //默认接口也可以改名为具名接口 export { default as es6 } from './someModule'; ```  下面三种 import 语句，没有对应的复合写法。  ```js import * as someIdentifier from 'someModule'; import someIdentifier from 'someModule'; import someIdentifier, { namedIdentifier } from 'someModule'; ```  为了做到形式的对称，现在有提案，提出补上这三种复合写法。  ```js export * as someIdentifier from \"someModule\"; export someIdentifier from \"someModule\"; export someIdentifier, { namedIdentifier } from \"someModule\"; ```  #### 跨模块常量  const 声明的常量只在当前代码块有效。如果想设置跨模块的常量（即跨多个文件），或者说一个值要被多个模块共享，可以采用下面的写法。  ```js // constants/db.js export const db = {   url: 'http://my.couchdbserver.local:5984',   admin_username: 'admin',   admin_password: 'admin password' };  // constants/user.js export const users = ['root', 'admin', 'staff', 'ceo', 'chief', 'moderator'];  // constants/index.js export {db} from './db'; export {users} from './users';  // script.js import {db, users} from './constants/index'; ```  ### import()  #### 基本语法  前面介绍过，import 命令会被 JavaScript 引擎静态分析，先于模块内的其他语句执行（import 命令叫做“连接” binding 其实更合适）。  这样的设计，固然有利于编译器提高效率，但也导致无法在运行时加载模块。在语法上，条件加载就不可能实现。如果 import 命令要取代 Node 的 require 方法，这就形成了一个障碍。因为 require 是运行时加载模块，import 命令无法取代 require 的动态加载功能。因此，有一个提案，建议引入 import()函数，完成动态加载。  ```js import(specifier); ```  上面代码中，import 函数的参数 specifier，指定所要加载的模块的位置。import 命令能够接受什么参数，import()函数就能接受什么参数，两者区别主要是后者为动态加载。  import()返回一个 Promise 对象。下面是一个例子。  ```js const main = document.querySelector('main');  import(`./section-modules/${someVariable}.js`)   .then(module => {     module.loadPageInto(main);   })   .catch(err => {     main.textContent = err.message;   }); ```  import()加载模块成功以后，这个模块会作为一个对象，当作 then 方法的参数。因此，可以使用对象解构赋值的语法，获取输出接口。  ```js import('./myModule.js').then(({ export1, export2 }) => {   // ...· }); ```  如果模块有 default 输出接口，可以用参数直接获得。  ```js import('./myModule.js').then(myModule => {   console.log(myModule.default); }); //或者 import('./myModule.js').then(({ default: theDefault }) => {   console.log(theDefault); }); ```  如果想同时加载多个模块，可以采用下面的写法。  ```js Promise.all([   import('./module1.js'),   import('./module2.js'),   import('./module3.js'), ]) .then(([module1, module2, module3]) => {    ··· }); ```  import()也可以用在 async 函数之中。  ```js async function main() {   const myModule = await import('./myModule.js');   const { export1, export2 } = await import('./myModule.js');   const [module1, module2, module3] = await Promise.all([     import('./module1.js'),     import('./module2.js'),     import('./module3.js')   ]); } main(); ```  import()函数可以用在任何地方，不仅仅是模块，非模块的脚本也可以使用。它是运行时执行，也就是说，什么时候运行到这一句，就会加载指定的模块。另外，import()函数与所加载的模块没有静态连接关系，这点也是与 import 语句不相同。import()类似于 Node 的 require 方法，区别主要是前者是异步加载，后者是同步加载。  #### 适用场合  ##### 按需加载  import()可以在需要的时候，再加载某个模块。  ```js button.addEventListener('click', event => {   import('./dialogBox.js')     .then(dialogBox => {       dialogBox.open();     })     .catch(error => {       /* Error handling */     }); }); ```  ##### 条件加载  import()可以放在 if 代码块，根据不同的情况，加载不同的模块。  ```js if (condition) {   import('moduleA').then(...); } else {   import('moduleB').then(...); } ```  ##### 动态的模块路径  import()允许模块路径动态生成。  ```js import(f()) .then(...); ```  ## 在 Web 浏览器中使用模块  ### 脚本异步加载  即使在 ES6 之前，web 浏览器都有多种方式在 web 应用中加载 JS。这些可能的脚本加载选择是：  - 使用\\<script\\>元素以及 src 属性来指定代码加载的位置，以便加载 JS 代码文件； - 使用\\<script\\>元素但不使用 src 属性，来嵌入内联的 JS 代码； - 加载 JS 代码文件并作为 Worker（例如 Web Worker 或 Service Worker）来执行。  默认情况下，浏览器是同步加载 JavaScript 脚本，即渲染引擎遇到\\<script\\>标签就会停下来，等到执行完脚本，再继续向下渲染。如果是外部脚本，还必须加入脚本下载的时间。  如果脚本体积很大，下载和执行的时间就会很长，因此造成浏览器堵塞，用户会感觉到浏览器“卡死”了，没有任何响应。这显然是很不好的体验，所以浏览器允许脚本异步加载，下面就是两种异步加载的语法。  ```html <script src=\"path/to/myModule.js\" defer><\/script> <script src=\"path/to/myModule.js\" async><\/script> ```  defer 与 async 的区别是：  - defer 要等到整个页面在内存中正常渲染结束（DOM 结构完全生成，以及其他脚本执行完成），才会执行；async 一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染。一句话，defer 是“渲染完再执行”，async 是“下载完就执行”。 - 另外，如果有多个 defer 脚本，会按照它们在页面出现的顺序加载，而多个 async 脚本是不能保证加载顺序的。  ### 在 script 标签中使用模块  浏览器加载 ES6 模块，也使用 script 标签，但是要加入 type=\"module\"属性。  ```html <script type=\"module\" src=\"./foo.js\"><\/script> ```  浏览器对于带有 type=\"module\"的< script >，都是异步加载，不会造成堵塞浏览器，即等到整个页面渲染完，再执行模块脚本，等同于打开了 script 标签的 defer 属性。如果网页有多个\\< script type=\"module\">，它们会按照在页面出现的顺序依次执行。  ```html <script type=\"module\" src=\"./foo.js\"><\/script> \x3c!-- 等同于 --\x3e <script type=\"module\" src=\"./foo.js\" defer><\/script> ```  < script >标签的 async 属性也可以打开，这时只要加载完成，渲染引擎就会中断渲染立即执行。执行完成后，再恢复渲染。  ```html <script type=\"module\" src=\"./foo.js\" async><\/script> ```  一旦使用了 async 属性，< script type=\"module\" >就不会按照在页面出现的顺序执行，而是只要该模块加载完成，就执行该模块。  ES6 模块也允许内嵌在网页中，语法行为与加载外部脚本完全一致。  ```html <script type=\"module\">   import utils from './utils.js';    // other code <\/script> ```  对于外部的模块脚本（上例是 foo.js），有几点需要注意。  - 代码是在模块作用域之中运行，而不是在全局作用域运行。模块内部的顶层变量，外部不可见。 - 模块脚本自动采用严格模式，不管有没有声明 use strict。 - 模块之中，可以使用 import 命令加载其他模块（.js 后缀不可省略，需要提供绝对 URL 或相对 URL），也可以使用 export 命令输出对外接口。 - 模块之中，顶层的 this 关键字返回 undefined，而不是指向 window。也就是说，在模块顶层使用 this 关键字，是无意义的。 - 同一个模块如果加载多次，将只执行一次。  ## ES6 模块与 CommonJS 模块的差异  - CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。 - CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。  ```js // main.js var mod = require('./lib');  console.log(mod.counter); // 3 mod.incCounter(); console.log(mod.counter); // 3 ```  上面代码说明，lib.js 模块加载以后，它的内部变化就影响不到输出的 mod.counter 了。这是因为 mod.counter 是一个原始类型的值，会被缓存。除非写成一个函数，才能得到内部变动后的值。  ```js // lib.js var counter = 3; function incCounter() {   counter++; } module.exports = {   get counter() {     return counter;   },   incCounter: incCounter }; ```  最后，export 通过接口，输出的是同一个值。不同的脚本加载这个接口，得到的都是同样的实例  ```js // mod.js function C() {   this.sum = 0;   this.add = function() {     this.sum += 1;   };   this.show = function() {     console.log(this.sum);   }; }  export let c = new C();  // x.js import { c } from './mod'; c.add();  // y.js import { c } from './mod'; c.show();  // main.js import './x'; import './y'; ```  ## Node 的 ES6 模块  ### 基本规则  Node 对 ES6 模块的处理比较麻烦，因为它有自己的 CommonJS 模块格式，与 ES6 模块格式是不兼容的。目前的解决方案是，将两者分开，ES6 模块和 CommonJS 采用各自的加载方案。  Node 要求 ES6 模块采用.mjs 后缀文件名。也就是说，只要脚本文件里面使用 import 或者 export 命令，那么就必须采用.mjs 后缀名。require 命令不能加载.mjs 文件，会报错，只有 import 命令才可以加载.mjs 文件。反过来，.mjs 文件里面也不能使用 require 命令，必须使用 import。  目前，这项功能还在试验阶段。安装 Node v8.5.0 或以上版本，要用--experimental-modules 参数才能打开该功能。  ```js node --experimental-modules my-app.mjs ```  为了与浏览器的 import 加载规则相同，Node 的.mjs 文件支持 URL 路径。目前，Node 的 import 命令只支持加载本地模块（file:协议），不支持加载远程模块。  ```js import './foo?query=1'; // 加载 ./foo 传入参数 ?query=1 ```  上面代码中，脚本路径带有参数?query=1，Node 会按 URL 规则解读。同一个脚本只要参数不同，就会被加载多次，并且保存成不同的缓存。由于这个原因，只要文件名中含有:、%、#、?等特殊字符，最好对这些字符进行转义。  目前，Node 的 import 命令只支持加载本地模块（file:协议），不支持加载远程模块。  ```js import 'baz'; import 'abc/123'; ```  如果模块名包含路径，那么 import 命令会按照路径去寻找这个名字的脚本文件。  ```js import 'file:///etc/config/app.json'; import './foo'; import './foo?search'; import '../bar'; import '/baz'; ```  如果脚本文件省略了后缀名，比如 import './foo'，Node 会依次尝试四个后缀名：./foo.mjs、./foo.js、./foo.json、./foo.node。如果这些脚本文件都不存在，Node 就会去加载./foo/package.json 的 main 字段指定的脚本。如果./foo/package.json 不存在或者没有 main 字段，那么就会依次加载./foo/index.mjs、./foo/index.js、./foo/index.json、./foo/index.node。如果以上四个文件还是都不存在，就会抛出错误。  最后，Node 的 import 命令是异步加载，这一点与浏览器的处理方法相同。  ### 缺失的内部变量  ES6 模块应该是通用的，同一个模块不用修改，就可以用在浏览器环境和服务器环境。为了达到这个目标，Node 规定 ES6 模块之中不能使用 CommonJS 模块的特有的一些内部变量。  首先，就是 this 关键字。ES6 模块之中，顶层的 this 指向 undefined；CommonJS 模块的顶层 this 指向当前模块，这是两者的一个重大差异。  其次，以下这些顶层变量在 ES6 模块之中都是不存在的。  - arguments - require - module - exports - \\_\\_filename - \\_\\_dirname  如果你一定要使用这些变量，有一个变通方法，就是写一个 CommonJS 模块输出这些变量，然后再用 ES6 模块加载这个 CommonJS 模块。但是这样一来，该 ES6 模块就不能直接用于浏览器环境了，所以不推荐这样做。  ```js // expose.js module.exports = { __dirname };  // use.mjs import expose from './expose.js'; const { __dirname } = expose; ```  ## ES6 模块加载 CommonJS 模块  CommonJS 模块的输出都定义在 module.exports 这个属性上面。Node 的 import 命令加载 CommonJS 模块，Node 会自动将 module.exports 属性，当作模块的默认输出，即等同于 export default xxx。  ```js // a.js module.exports = {   foo: 'hello',   bar: 'world' };  // 等同于 export default {   foo: 'hello',   bar: 'world' }; ```  即 import 命令实际上输入的是这样一个对象{ default: module.exports}。所以，一共有三种写法，可以拿到 CommonJS 模块的 module.exports。  ```js // 写法一 import baz from './a'; // baz = {foo: 'hello', bar: 'world'};  // 写法二 import { default as baz } from './a'; // baz = {foo: 'hello', bar: 'world'};  // 写法三 import * as baz from './a'; // baz = { //   get default() {return module.exports;}, //   get foo() {return this.default.foo}.bind(baz), //   get bar() {return this.default.bar}.bind(baz) // } ```  ```js // c.js module.exports = function two() {   return 2; };  // es.js import foo from './c'; foo(); // 2  import * as bar from './c'; bar.default(); // 2 bar(); // throws, bar is not a function ```  上面代码中，bar 本身是一个对象，不能当作函数调用，只能通过 bar.default 调用。  CommonJS 模块的输出缓存机制，在 ES6 加载方式下依然有效。  ```js // foo.js module.exports = 123; setTimeout(_ => (module.exports = null)); ```  上面代码中，对于加载 foo.js 的脚本，module.exports 将一直是 123，而不会变成 null。  由于 ES6 模块是编译时确定输出接口，CommonJS 模块是运行时确定输出接口，所以采用 import 命令加载 CommonJS 模块时，不允许采用下面的写法。  ```js // 不正确 import { readFile } from 'fs';  // 正确的写法一 import * as express from 'express'; const app = express.default();  // 正确的写法二 import express from 'express'; const app = express(); ```  ## CommonJS 模块加载 ES6 模块  CommonJS 模块加载 ES6 模块，不能使用 require 命令，而要使用 import()函数。ES6 模块的所有输出接口，会成为输入对象的属性。  ```js // es.mjs let foo = { bar: 'my-default' }; export default foo;  // cjs.js const es_namespace = await import('./es.mjs'); // es_namespace = { //   get default() { //     ... //   } // } console.log(es_namespace.default); // { bar:'my-default' } ```  ```js // es.js export let foo = { bar: 'my-default' }; export { foo as bar }; export function f() {} export class c {}  // cjs.js const es_namespace = await import('./es'); // es_namespace = { //   get foo() {return foo;} //   get bar() {return foo;} //   get f() {return f;} //   get c() {return c;} // } ```  ## 循环加载  “循环加载”（circular dependency）指的是，a 脚本的执行依赖 b 脚本，而 b 脚本的执行又依赖 a 脚本。  ```js // a.js var b = require('b'); // b.js var a = require('a'); ```  ### CommonJS 模块的循环加载  #### CommonJS 模块的加载原理  CommonJS 的一个模块，就是一个脚本文件。require 命令第一次加载该脚本，就会执行整个脚本，然后在内存生成一个对象。  ```js {   id: '...',   exports: { ... },   loaded: true,   ... } ```  以后需要用到这个模块的时候，就会到 exports 属性上面取值。即使再次执行 require 命令，也不会再次执行该模块，而是到缓存之中取值。也就是说，CommonJS 模块无论加载多少次，都只会在第一次加载时运行一次，以后再加载，就返回第一次运行的结果，除非手动清除系统缓存。  #### CommonJS 模块的解决方案  CommonJS 模块的重要特性是加载时执行，即脚本代码在 require 的时候，就会全部执行。一旦出现某个模块被\"循环加载\"，就只输出已经执行的部分，还未执行的部分不会输出。  ```js //a.js exports.done = false; var b = require('./b.js'); console.log('在 a.js 之中，b.done = %j', b.done); exports.done = true; console.log('a.js 执行完毕');  //b.js exports.done = false; var a = require('./a.js'); console.log('在 b.js 之中，a.done = %j', a.done); exports.done = true; console.log('b.js 执行完毕');  //main.js var a = require('./a.js'); var b = require('./b.js'); console.log('在 main.js 之中, a.done=%j, b.done=%j', a.done, b.done); ```  执行 main.js，运行结果如下。  ```js $ node main.js  // 在 b.js 之中，a.done = false // b.js 执行完毕 // 在 a.js 之中，b.done = true // a.js 执行完毕 // 在 main.js 之中, a.done=true, b.done=true ```  上面的代码证明了两件事。一是，在 b.js 之中，a.js 没有执行完毕，只执行了第一行。二是，main.js 执行到第二行时，不会再次执行 b.js，而是输出缓存的 b.js 的执行结果，即它的第四行。  另外，由于 CommonJS 模块遇到循环加载时，返回的是当前已经执行的部分的值，而不是代码全部执行后的值，两者可能会有差异。所以，输入变量的时候，必须非常小心。  ```js var a = require('a'); // 安全的写法 var foo = require('a').foo; // 危险的写法  exports.good = function(arg) {   return a.foo('good', arg); // 使用的是 a.foo 的最新值 };  exports.bad = function(arg) {   return foo('bad', arg); // 使用的是一个部分加载时的值 }; ```  上面代码中，如果发生循环加载，require('a').foo 的值很可能后面会被改写，改用 require('a')会更保险一点。  ### ES6 模块的循环加载  ES6 处理“循环加载”与 CommonJS 有本质的不同。ES6 模块是动态引用，如果使用 import 从一个模块加载变量（即 import foo from 'foo'），那些变量不会被缓存，而是成为一个指向被加载模块的引用，需要开发者自己保证，真正取值的时候能够取到值。  ```js // a.mjs import { bar } from './b'; console.log('a.mjs'); console.log(bar); export let foo = 'foo';  // b.mjs import { foo } from './a'; console.log('b.mjs'); console.log(foo); export let bar = 'bar'; ```  上面代码中，a.mjs 加载 b.mjs，b.mjs 又加载 a.mjs，构成循环加载。执行 a.mjs，结果如下。  ```js $ node --experimental-modules a.mjs b.mjs ReferenceError: foo is not defined ```  首先，执行 a.mjs 以后，引擎发现它加载了 b.mjs，因此会优先执行 b.mjs，然后再执行 a.mjs。接着，执行 b.mjs 的时候，已知它从 a.mjs 输入了 foo 接口，这时不会去执行 a.mjs，而是认为这个接口已经存在了，继续往下执行。执行到第三行 console.log(foo)的时候，才发现这个接口根本没定义，因此报错。  解决这个问题的方法，就是让 b.mjs 运行的时候，foo 已经有定义了。这可以通过将 foo 写成函数来解决。  ```js // a.mjs import { bar } from './b'; console.log('a.mjs'); console.log(bar()); function foo() {   return 'foo'; } export { foo };  // b.mjs import { foo } from './a'; console.log('b.mjs'); console.log(foo()); function bar() {   return 'bar'; } export { bar }; ```  这时再执行 a.mjs 就可以得到预期结果。  ```js $ node --experimental-modules a.mjs // b.mjs // foo // a.mjs // bar ```  这是因为函数具有提升作用，在执行 import {bar} from './b'时，函数 foo 就已经有定义了，所以 b.mjs 加载的时候不会报错。这也意味着，如果把函数 foo 改写成函数表达式，也会报错. "},{title:"【读书笔记】ES6之修饰器(Decorator)",path:"/posts/%E3%80%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%91ES6%E4%B9%8B%E4%BF%AE%E9%A5%B0%E5%99%A8-Decorator.html",strippedContent:" ## 类的修饰  基本上，修饰器的行为就是下面这样。修饰器是一个对类进行处理的函数。修饰器函数的第一个参数，就是所要修饰的目标类。  ```js @decorator class A {}  // 等同于 class A {} A = decorator(A) || A; ```  如果觉得一个参数不够用，可以在修饰器外面再封装一层函数。  ```js function testable(isTestable) {   return function(target) {     target.isTestable = isTestable;   }; }  @testable(true) class MyTestableClass {} MyTestableClass.isTestable; // true  @testable(false) class MyClass {} MyClass.isTestable; // false ```  注意，修饰器对类的行为的改变，是代码编译时发生的，而不是在运行时。这意味着，修饰器能在编译阶段运行代码。也就是说，修饰器本质就是编译时执行的函数。   前面的例子是为类添加一个静态属性，如果想添加实例属性，可以通过目标类的 prototype 对象操作。  ```js function testable(target) {   target.prototype.isTestable = true; }  @testable class MyTestableClass {}  let obj = new MyTestableClass(); obj.isTestable; // true ```  下面代码通过修饰器 mixins，把 Foo 对象的方法添加到了 MyClass 的实例上面。可以用 Object.assign()模拟这个功能。  ```js // mixins.js export function mixins(...list) {   return function(target) {     Object.assign(target.prototype, ...list);   }; }  // main.js import { mixins } from './mixins';  const Foo = {   foo() {     console.log('foo');   } };  @mixins(Foo) class MyClass {}  let obj = new MyClass(); obj.foo(); // 'foo' ```  实际开发中，React 与 Redux 库结合使用时，常常需要写成下面这样。  ```js class MyReactComponent extends React.Component {}  export default connect(   mapStateToProps,   mapDispatchToProps )(MyReactComponent); ```  有了装饰器，就可以改写上面的代码。  ```js @connect(   mapStateToProps,   mapDispatchToProps ) export default class MyReactComponent extends React.Component {} ```  ## 方法的修饰  修饰器不仅可以修饰类，还可以修饰类的属性。   下面代码中，修饰器 readonly 用来修饰“类”的 name 方法。  ```js class Person {   @readonly   name() {     return `${this.first} ${this.last}`;   } } ```  修饰器函数 readonly 一共可以接受三个参数。  ```js function readonly(target, name, descriptor) {   // descriptor对象原来的值如下   // {   //   value: specifiedFunction,   //   enumerable: false,   //   configurable: true,   //   writable: true   // };   descriptor.writable = false;   return descriptor; }  readonly(Person.prototype, 'name', descriptor); // 类似于 Object.defineProperty(Person.prototype, 'name', descriptor); ```  修饰器第一个参数是类的原型对象，上例是 Person.prototype，修饰器的本意是要“修饰”类的实例，但是这个时候实例还没生成，所以只能去修饰原型（这不同于类的修饰，那种情况时 target 参数指的是类本身）；第二个参数是所要修饰的属性名，第三个参数是该属性的描述对象。   修饰器（readonly）会修改属性的描述对象（descriptor），然后被修改的描述对象再用来定义属性。   下面是另一个例子，修改属性描述对象的 enumerable 属性，使得该属性不可遍历。  ```js class Person {   @nonenumerable   get kidCount() {     return this.children.length;   } }  function nonenumerable(target, name, descriptor) {   descriptor.enumerable = false;   return descriptor; } ```  @log 修饰器的作用就是在执行原始的操作之前，执行一次 console.log，从而达到输出日志的目的。  ```js class Math {   @log   add(a, b) {     return a + b;   } }  function log(target, name, descriptor) {   var oldValue = descriptor.value;    descriptor.value = function() {     console.log(`Calling ${name} with`, arguments);     return oldValue.apply(this, arguments);   };    return descriptor; }  const math = new Math();  // passed parameters should get logged now math.add(2, 4); ```  修饰器有注释的作用。  ```js @testable class Person {   @readonly   @nonenumerable   name() {     return `${this.first} ${this.last}`;   } } ```  如果同一个方法有多个修饰器，会像剥洋葱一样，先从外到内进入，然后由内向外执行。  ```js function dec(id) {   console.log('evaluated', id);   return (target, property, descriptor) => console.log('executed', id); }  class Example {   @dec(1)   @dec(2)   method() {} } // evaluated 1 // evaluated 2 // executed 2 // executed 1 ```  上面代码中，外层修饰器@dec(1)先进入，但是内层修饰器@dec(2)先执行。   除了注释，修饰器还能用来类型检查。所以，对于类来说，这项功能相当有用。从长期来看，它将是 JavaScript 代码静态分析的重要工具。  ## 为什么修饰器不能用于函数？  修饰器只能用于类和类的方法，不能用于函数，因为存在函数提升。  ```js var counter = 0; var add = function () {   counter++; }; @add function foo() { } ```  上面的代码，意图是执行后 counter 等于 1，但是实际上结果是 counter 等于 0。因为函数提升，使得实际执行的代码是下面这样。  ```js @add function foo() { } var counter; var add; counter = 0; add = function () {   counter++; }; ```  下面是另一个例子。  ```js var readOnly = require(\"some-decorator\"); @readOnly function foo() { } ```  上面代码也有问题，因为实际执行是下面这样。  ```js var readOnly; @readOnly function foo() { } readOnly = require(\"some-decorator\"); ```  总之，由于存在函数提升，使得修饰器不能用于 函数。类是不会提升的，所以就没有这方面的问题。  如果一定要修饰函数，可以采用高阶函数的形式直接执行。  ```js function doSomething(name) {   console.log('Hello, ' + name); }  function loggingDecorator(wrapped) {   return function() {     console.log('Starting');     const result = wrapped.apply(this, arguments);     console.log('Finished');     return result;   }; }  const wrapped = loggingDecorator(doSomething); ```  ## core-decorators.js  core-decorators.js 是一个第三方模块，提供了几个常见的修饰器，通过它可以更好地理解修饰器。  ### @autobind  autobind 修饰器使得方法中的 this 对象，绑定原始对象。  ```js import { autobind } from 'core-decorators'; class Person {   @autobind   getPerson() {     return this;   } } let person = new Person(); let getPerson = person.getPerson; getPerson() === person; // true ```  ### @readonly  readonly 修饰器使得属性或方法不可写。  ```js import { readonly } from 'core-decorators'; class Meal {   @readonly   entree = 'steak'; } var dinner = new Meal(); dinner.entree = 'salmon'; // Cannot assign to read only property 'entree' of [object Object] ```  ### @override  override 修饰器检查子类的方法，是否正确覆盖了父类的同名方法，如果不正确会报错。  ```js import { override } from 'core-decorators';  class Parent {   speak(first, second) {} }  class Child extends Parent {   @override   speak() {}   // SyntaxError: Child#speak() does not properly override Parent#speak(first, second) }  // or  class Child extends Parent {   @override   speaks() {}   // SyntaxError: No descriptor matching Child#speaks() was found on the prototype chain.   //   //   Did you mean \"speak\"? } ```  ### @deprecate (别名@deprecated)  deprecate 或 deprecated 修饰器在控制台显示一条警告，表示该方法将废除。  ```js import { deprecate } from 'core-decorators';  class Person {   @deprecate   facepalm() {}    @deprecate('We stopped facepalming')   facepalmHard() {}    @deprecate('We stopped facepalming', {     url: 'http://knowyourmeme.com/memes/facepalm'   })   facepalmHarder() {} }  let person = new Person();  person.facepalm(); // DEPRECATION Person#facepalm: This function will be removed in future versions.  person.facepalmHard(); // DEPRECATION Person#facepalmHard: We stopped facepalming  person.facepalmHarder(); // DEPRECATION Person#facepalmHarder: We stopped facepalming // //     See http://knowyourmeme.com/memes/facepalm for more details. // ```  ### @suppressWarnings  suppressWarnings 修饰器抑制 deprecated 修饰器导致的 console.warn()调用。但是，异步代码发出的调用除外。  ```js import { suppressWarnings } from 'core-decorators';  class Person {   @deprecated   facepalm() {}    @suppressWarnings   facepalmWithoutWarning() {     this.facepalm();   } }  let person = new Person();  person.facepalmWithoutWarning(); // no warning is logged ```  ## 使用修饰器实现自动发布事件  我们可以使用修饰器，使得对象的方法被调用时，自动发出一个事件。  ```js const postal = require('postal/lib/postal.lodash');  export default function publish(topic, channel) {   const channelName = channel || '/';   const msgChannel = postal.channel(channelName);   msgChannel.subscribe(topic, v => {     console.log('频道: ', channelName);     console.log('事件: ', topic);     console.log('数据: ', v);   });    return function(target, name, descriptor) {     const fn = descriptor.value;      descriptor.value = function() {       let value = fn.apply(this, arguments);       msgChannel.publish(topic, value);     };   }; } ```  上面代码定义了一个名为 publish 的修饰器，它通过改写 descriptor.value，使得原方法被调用时，会自动发出一个事件。它使用的事件“发布/订阅”库是 Postal.js。  ```js // index.js import publish from './publish';  class FooComponent {   @publish('foo.some.message', 'component')   someMethod() {     return { my: 'data' };   }   @publish('foo.some.other')   anotherMethod() {     // ...   } }  let foo = new FooComponent();  foo.someMethod(); foo.anotherMethod(); ```  ## Mixin  下面，我们部署一个通用脚本 mixins.js，将 Mixin 写成一个修饰器。  ```js export function mixins(...list) {   return function(target) {     Object.assign(target.prototype, ...list);   }; } ```  然后，就可以使用上面这个修饰器，为类“混入”各种方法。  ```js import { mixins } from './mixins';  const Foo = {   foo() {     console.log('foo');   } };  @mixins(Foo) class MyClass {}  let obj = new MyClass(); obj.foo(); // \"foo\" ```  不过，上面的方法会改写 MyClass 类的 prototype 对象，如果不喜欢这一点，也可以通过类的继承实现 Mixin。  ```js let MyMixin = superclass =>   class extends superclass {     foo() {       console.log('foo from MyMixin');     }   }; ```  接着，目标类再去继承这个混入类，就达到了“混入”foo 方法的目的。  ```js class MyClass extends MyMixin(MyBaseClass) {   /* ... */ }  let c = new MyClass(); c.foo(); // \"foo from MyMixin\" ```  如果需要“混入”多个方法，就生成多个混入类。  ``` class MyClass extends Mixin1(Mixin2(MyBaseClass)) {   /* ... */ } ```  这种写法的一个好处，是可以调用 super，因此可以避免在“混入”过程中覆盖父类的同名方法。  ```js let Mixin1 = (superclass) => class extends superclass {   foo() {     console.log('foo from Mixin1');     if (super.foo) super.foo();   } };  let Mixin2 = (superclass) => class extends superclass {   foo() {     console.log('foo from Mixin2');     if (super.foo) super.foo();   } };  class S {   foo() {     console.log('foo from S');   } }  class C extends Mixin1(Mixin2(S)) {   foo() {     console.log('foo from C');     super.foo();   }  ```  上面代码中，每一次混入发生时，都调用了父类的 super.foo 方法，导致父类的同名方法没有被覆盖，行为被保留了下来。  ```js new C().foo(); // foo from C // foo from Mixin1 // foo from Mixin2 // foo from S ```  ## Trait  Trait 也是一种修饰器，效果与 Mixin 类似，但是提供更多功能，比如防止同名方法的冲突、排除混入某些方法、为混入的方法起别名等等。  下面采用 traits-decorator 这个第三方模块作为例子。这个模块提供的 traits 修饰器，不仅可以接受对象，还可以接受 ES6 类作为参数。  ```js import { traits } from 'traits-decorator';  class TFoo {   foo() {     console.log('foo');   } }  const TBar = {   bar() {     console.log('bar');   } };  @traits(TFoo, TBar) class MyClass {}  let obj = new MyClass(); obj.foo(); // foo obj.bar(); // bar ```  Trait 不允许“混入”同名方法。  ```js import { traits } from 'traits-decorator';  class TFoo {   foo() {     console.log('foo');   } }  const TBar = {   bar() {     console.log('bar');   },   foo() {     console.log('foo');   } };  @traits(TFoo, TBar) class MyClass {} // 报错 // throw new Error('Method named: ' + methodName + ' is defined twice.'); //        ^ // Error: Method named: foo is defined twice. ```  一种解决方法是排除 TBar 的 foo 方法。  ```js import { traits, excludes } from 'traits-decorator';  class TFoo {   foo() {     console.log('foo');   } }  const TBar = {   bar() {     console.log('bar');   },   foo() {     console.log('foo');   } };  @traits(TFoo, TBar::excludes('foo')) class MyClass {}  let obj = new MyClass(); obj.foo(); // foo obj.bar(); // bar ```  另一种方法是为 TBar 的 foo 方法起一个别名。  ```js import { traits, alias } from 'traits-decorator';  class TFoo {   foo() {     console.log('foo');   } }  const TBar = {   bar() {     console.log('bar');   },   foo() {     console.log('foo');   } };  @traits(TFoo, TBar::alias({ foo: 'aliasFoo' })) class MyClass {}  let obj = new MyClass(); obj.foo(); // foo obj.aliasFoo(); // foo obj.bar(); // bar ```  alias 和 excludes 方法，可以结合起来使用。  ```js @traits(TExample::excludes('foo', 'bar')::alias({ baz: 'exampleBaz' })) class MyClass {} ```  as 方法则为上面的代码提供了另一种写法。  ```js @traits(   TExample::as({ excludes: ['foo', 'bar'], alias: { baz: 'exampleBaz' } }) ) class MyClass {} ``` "},{title:"【读书笔记】ES6之JS的类和类继承",path:"/posts/%E3%80%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%91ES6%E4%B9%8BJS%E7%9A%84%E7%B1%BB%E5%92%8C%E7%B1%BB%E7%BB%A7%E6%89%BF.html",strippedContent:" ## 语法  ### ES5 中的仿类结构  ```js function Point(x, y) {   this.x = x;   this.y = y; } Point.prototype.toString = function() {   return '(' + this.x + ', ' + this.y + ')'; }; var p = new Point(1, 2); ```  ### ES6 中类的声明  #### 基本细节  ```js //定义类 class Point {   constructor(x, y) {     this.x = x;     this.y = y;   }    toString() {     return '(' + this.x + ', ' + this.y + ')';   } } ```  里面有一个 constructor 方法，这就是构造方法，而 this 关键字则代表实例对象。   Point 类除了构造方法，还定义了一个 toString 方法。注意，定义“类”的方法的时候，前面不需要加上 function 这个关键字，直接把函数定义放进去了就可以了。另外，方法之间不需要逗号分隔，加了会报错。使用的时候，也是直接对类使用 new 命令，跟构造函数的用法完全一致。  ```js class Bar {   doStuff() {     console.log('stuff');   } }  var b = new Bar(); b.doStuff(); // \"stuff\" ```  事实上，类的所有方法都定义在类的 prototype 属性上面。在类的实例上面调用方法，其实就是调用原型上的方法。  ```js // 等同于 Point.prototype = {   constructor() {},   toString() {},   toValue() {} }; ```  b 是 B 类的实例，它的 constructor 方法就是 B 类原型的 constructor 方法。而 prototype 对象的 constructor 属性，直接指向“类”的本身，这与 ES5 的行为是一致的。即为 B.  ```js class B {} let b = new B();  b.constructor === B.prototype.constructor; // true ```  b 是 B 类的实例，它的 constructor 方法就是 B 类原型的 constructor 方法。  ```js class Point {   constructor() {     // ...   } } Object.assign(Point.prototype, {   toString() {},   toValue() {} }); ```  类的内部所有定义的方法，都是不可枚举的（non-enumerable）。这一点与 ES5 的行为不一致。  ````js class Point {   constructor(x, y) {     // ...   }    toString() {     // ...   } }  Object.keys(Point.prototype) // [] Object.getOwnPropertyNames(Point.prototype) // [\"constructor\",\"toString\"] ```js 类的属性名，可以采用表达式。 ```js let methodName = 'getArea';  class Square {   constructor(length) {     // ...   }    [methodName]() {     // ...   } } ````  与 ES5 一样，实例的属性除非显式定义在其本身（即定义在 this 对象上），否则都是定义在原型上（即定义在 class 上）。  ```js //定义类 class Point {   constructor(x, y) {     this.x = x;     this.y = y;   }    toString() {     return '(' + this.x + ', ' + this.y + ')';   } } var point = new Point(2, 3); point.toString(); // (2, 3) point.hasOwnProperty('x'); // true point.hasOwnProperty('y'); // true point.hasOwnProperty('toString'); // false point.__proto__.hasOwnProperty('toString'); // true ```  #### 默认为严格模式  类和模块的内部，默认就是严格模式，所以不需要使用 use strict 指定运行模式。只要你的代码写在类或模块之中，就只有严格模式可用。   考虑到未来所有的代码，其实都是运行在模块之中，所以 ES6 实际上把整个语言升级到了严格模式。  #### constructor 方法  constructor 方法是类的默认方法，通过 new 命令生成对象实例时，自动调用该方法。一个类必须有 constructor 方法，如果没有显式定义，一个空的 constructor 方法会被默认添加。  ```js class Point {}  // 等同于 class Point {   constructor() {} } ```  constructor 方法默认返回实例对象（即 this），完全可以指定返回另外一个对象。  ```js class Foo {   constructor() {     return Object.create(null);   } } new Foo() instanceof Foo; // false ```  上面代码中，constructor 函数返回一个全新的对象，结果导致实例对象不是 Foo 类的实例。  ## 与自定义类型的区别  1. 类声明不会被提升，这与函数定义不同。类声明的行为与 let 相似，因此在程序的执行到达声明处之前，类会存在于暂时性死区内。 2. 类声明中的所有代码会自动运行在严格模式下，并且也无法退出严格模式。 3. 类的所有方法都是不可枚举的，这是对于自定义类型的显著变化，后者必须用 Object.defineProperty()才能将方法改变为不可枚举。 4. 类的所有方法内部都没有[[Construct]]，因此使用 new 来调用它们会抛出错误。 5. 调用类构造器时不使用 new，会抛出错误。 6. 试图在类的方法内部重写类名，会抛出错误。  ## 类表达式  与函数一样，类也可以使用表达式的形式定义。  ```js const MyClass = class Me {   getClassName() {     return Me.name;   } }; ```  需要注意的是，这个类的名字是 MyClass 而不是 Me，Me 只在 Class 的内部代码可用，指代当前类。  ```js let inst = new MyClass(); inst.getClassName(); // Me Me.name; // ReferenceError: Me is not defined ```  如果类的内部没用到的话，可以省略 Me，也就是可以写成下面的形式。  ``` const MyClass = class { /* ... */ }; ```  ## 被当作值的类  在编程中，能被当作值来使用的就称为一级公民（ first-class citizen），意味着它能作为参数传给函数、能作为函数返回值、能用来给变量赋值。JS 的函数就是一级公民（它们有时又被称为一级函数），此特性让 JS 独一无二。   ES6 延续了传统，让类同样成为一级公民。这就使得类可以被多种方式所使用。例如，它能作为参数传入函数：  ```js function createObject(classDef) {   return new classDef(); } let obj = createObject(   class {     sayHi() {       console.log('Hi!');     }   } ); obj.sayHi(); //\t\"Hi!\" ```  ## 私有方法和私有属性  ### 私有方法现有的方案  私有方法是常见需求，但 ES6 不提供，只能通过变通方法模拟实现。   一种做法是在命名上加以区别。  ```js class Widget {   // 公有方法   foo(baz) {     this._bar(baz);   }   // 私有方法   _bar(baz) {     return (this.snaf = baz);   }   // ... } ```  另一种方法就是索性将私有方法移出模块，因为模块内部的所有方法都是对外可见的。  ```js class Widget {   foo(baz) {     bar.call(this, baz);   }   // ... } function bar(baz) {   return (this.snaf = baz); } ```  上面代码中，foo 是公有方法，内部调用了 bar.call(this, baz)。这使得 bar 实际上成为了当前模块的私有方法。   还有一种方法是利用 Symbol 值的唯一性，将私有方法的名字命名为一个 Symbol 值。  ```js const bar = Symbol('bar'); const snaf = Symbol('snaf');  export default class myClass {   // 公有方法   foo(baz) {     this[bar](baz);   }   // 私有方法   [bar](baz) {     return (this[snaf] = baz);   }   // ... } ```  上面代码中，bar 和 snaf 都是 Symbol 值，导致第三方无法获取到它们，因此达到了私有方法和私有属性的效果。  ### 私有属性和方法的提案  目前，有一个提案，为 class 加了私有属性。方法是在属性名之前，使用#表示。  ```js class Point {   #x;    constructor(x = 0) {     #x = +x; // 写成 this.#x 亦可   }    get x() { return #x }   set x(value) { #x = +value } } ```  私有属性可以指定初始值，在构造函数执行时进行初始化。  ```js class Point {   #x = 0;   constructor() {     #x; // 0   } } ```  这种写法不仅可以写私有属性，还可以用来写私有方法。  ```js class Foo {   #a;   #b;   #sum() { return #a + #b; }   printSum() { console.log(#sum()); }   constructor(a, b) { #a = a; #b = b; } } ```  另外，私有属性也可以设置 getter 和 setter 方法。  ```js class Counter {   #xValue = 0;    get #x() { return #xValue; }   set #x(value) {     this.#xValue = value;   }    constructor() {     super();     // ...   } } ```  私有属性不限于从 this 引用，类的实例也可以引用私有属性。  ```js class Foo {   #privateValue = 42;   static getPrivateValue(foo) {     return foo.#privateValue;   } } Foo.getPrivateValue(new Foo()); // 42 ```  但是，直接从实例上引用私有属性是不可以的，只能在类的定义中引用。  ```js class Foo {   #bar; } let foo = new Foo(); foo.#bar; // 报错 ```  ## this 的指向  类的方法内部如果含有 this，它默认指向类的实例。但是，必须非常小心，一旦单独使用该方法，很可能报错。  ```js class Logger {   printName(name = 'there') {     this.print(`Hello ${name}`);   }    print(text) {     console.log(text);   } }  const logger = new Logger(); const { printName } = logger; printName(); // TypeError: Cannot read property 'print' of undefined ```  上面代码中，printName 方法中的 this，默认指向 Logger 类的实例。但是，如果将这个方法提取出来单独使用，this 会指向该方法运行时所在的环境，因为找不到 print 方法而导致报错。   一个比较简单的解决方法是，在构造方法中绑定 this，这样就不会找不到 print 方法了  ```js class Logger {   constructor() {     this.printName = this.printName.bind(this);   }   // ... } ```  另一种解决方法是使用箭头函数。  ```js class Logger {   constructor() {     this.printName = (name = 'there') => {       this.print(`Hello ${name}`);     };   }   // ... } ```  还有一种解决方法是使用 Proxy，获取方法的时候，自动绑定 this。  ```js function selfish(target) {   const cache = new WeakMap();   const handler = {     get(target, key) {       const value = Reflect.get(target, key);       if (typeof value !== 'function') {         return value;       }       if (!cache.has(value)) {         cache.set(value, value.bind(target));       }       return cache.get(value);     }   };   const proxy = new Proxy(target, handler);   return proxy; } const logger = selfish(new Logger()); ```  ## name 属性  ```js class Point {} Point.name; // \"Point\" ```  name 属性总是返回紧跟在 class 关键字后面的类名。  ## Class 的取值函数（getter）和存值函数（setter）  ```js class MyClass {   constructor() {     // ...   }   get prop() {     return 'getter';   }   set prop(value) {     console.log('setter: ' + value);   } }  let inst = new MyClass();  inst.prop = 123; // setter: 123  inst.prop; // 'getter' ```  存值函数和取值函数是设置在属性的 Descriptor 对象上的。  ```js class CustomHTMLElement {   constructor(element) {     this.element = element;   }    get html() {     return this.element.innerHTML;   }    set html(value) {     this.element.innerHTML = value;   } }  var descriptor = Object.getOwnPropertyDescriptor(   CustomHTMLElement.prototype,   'html' );  'get' in descriptor; // true 'set' in descriptor; // true ```  ## Class 的 Generator 方法  如果某个方法之前加上星号（\\*），就表示该方法是一个 Generator 函数。  ```js class Foo {   constructor(...args) {     this.args = args;   }   *[Symbol.iterator]() {     for (let arg of this.args) {       yield arg;     }   } }  for (let x of new Foo('hello', 'world')) {   console.log(x); } // hello // world ```  ## Class 的静态方法 static  如果在一个方法前，加上 static 关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。静态方法可以与非静态方法重名。  ```js class Foo {   static classMethod() {     return 'hello';   } } Foo.classMethod(); // 'hello' var foo = new Foo(); foo.classMethod(); // TypeError: foo.classMethod is not a function ```  注意，如果静态方法包含 this 关键字，这个 this 指的是类，而不是实例。  ```js class Foo {   static bar() {     this.baz();   }   static baz() {     console.log('hello');   }   baz() {     console.log('world');   } } Foo.bar(); // hello ```  父类的静态方法，可以被子类继承。  ```js class Foo {   static classMethod() {     return 'hello';   } } class Bar extends Foo {} Bar.classMethod(); // 'hello' ```  静态方法也是可以从 super 对象上调用的。  ```js class Foo {   static classMethod() {     return 'hello';   } } class Bar extends Foo {   static classMethod() {     return super.classMethod() + ', too';   } } Bar.classMethod(); // \"hello, too\" ```  ## Class 的静态属性和实例属性  静态属性指的是 Class 本身的属性，即 Class.propName，而不是定义在实例对象（this）上的属性。ES6 明确规定，Class 内部只有静态方法，没有静态属性。  ```js class Foo {} Foo.prop = 1; Foo.prop; // 1 ```  ```js // 以下两种写法都无效 class Foo {   // 写法一   prop: 2;    // 写法二   static prop: 2; }  Foo.prop; // undefined ```  目前有一个静态属性的提案，对实例属性和静态属性都规定了新的写法。   （1）类的实例属性   类的实例属性可以用等式，写入类的定义之中。  ```js class MyClass {   myProp = 42;    constructor() {     console.log(this.myProp); // 42   } } ```  为了可读性的目的，对于那些在 constructor 里面已经定义的实例属性，新写法允许直接列出。  ```js class ReactCounter extends React.Component {   state;   constructor(props) {     super(props);     this.state = {       count: 0     };   } } ```  （2）类的静态属性 类的静态属性只要在上面的实例属性写法前面，加上 static 关键字就可以了。  ```js class MyClass {   static myStaticProp = 42;    constructor() {     console.log(MyClass.myStaticProp); // 42   } } ```  ```js class MyClass {   static myStaticProp = 42;    constructor() {     console.log(MyClass.myStaticProp); // 42   } } ```  ## new.target 属性  Class 内部调用 new.target，返回当前 Class。  ```js class Rectangle {   constructor(length, width) {     console.log(new.target === Rectangle);     this.length = length;     this.width = width;   } }  var obj = new Rectangle(3, 4); // 输出 true ```  需要注意的是，子类继承父类时，new.target 会返回子类。  ```js class Rectangle {   constructor(length, width) {     console.log(new.target === Rectangle);     // ...   } }  class Square extends Rectangle {   constructor(length) {     super(length, length);   } }  var obj = new Square(3); // 输出 false ```  利用这个特点，可以写出不能独立使用、必须继承后才能使用的类。  ```js class Shape {   constructor() {     if (new.target === Shape) {       throw new Error('本类不能实例化');     }   } }  class Rectangle extends Shape {   constructor(length, width) {     super();     // ...   } }  var x = new Shape(); // 报错 var y = new Rectangle(3, 4); // 正确 ```  注意，在函数外部，使用 new.target 会报错。  ## Class 的继承  ### ES6 之前  ES6 之前，实现自定义类型的继承是个繁琐的过程。严格的继承要求有多个步骤。例如，研究以下范例：  ```js function Rectangle(length, width) {   this.length = length;   this.width = width; }  Rectangle.prototype.getArea = function() {   return this.length * this.width; };  function Square(length) {   Rectangle.call(this, length, length); }  Square.prototype = Object.create(Rectangle.prototype, {   constructor: {     value: Square,     enumerable: true,     writable: true,     configurable: true   } });  var square = new Square(3); console.log(square.getArea()); //\t9 console.log(square instanceof Square); //\ttrue console.log(square instanceof Rectangle); //\ttrue ```  ### ES6  Class 可以通过 extends 关键字实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。  ```js class Point {}  class ColorPoint extends Point {} ```  子类必须在 constructor 方法中调用 super 方法，否则新建实例时会报错。这是因为子类自己的 this 对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，加上子类自己的实例属性和方法。如果不调用 super 方法，子类就得不到 this 对象。  ```js class Point {   /* ... */ } class ColorPoint extends Point {   constructor() {} } let cp = new ColorPoint(); // ReferenceError ```  ES5 的继承，实质是先创造子类的实例对象 this，然后再将父类的方法添加到 this 上面（Parent.apply(this)）。ES6 的继承机制完全不同，实质是先将父类实例对象的属性和方法，加到 this 上面（所以必须先调用 super 方法），然后再用子类的构造函数修改 this。如果子类没有定义 constructor 方法，这个方法会被默认添加.   另一个需要注意的地方是，在子类的构造函数中，只有调用 super 之后，才可以使用 this 关键字，否则会报错。这是因为子类实例的构建，基于父类实例，只有 super 方法才能调用父类实例。  ```js class Point {   constructor(x, y) {     this.x = x;     this.y = y;   } } class ColorPoint extends Point {   constructor(x, y, color) {     this.color = color; // ReferenceError     super(x, y);     this.color = color; // 正确   } } ```  ### Object.getPrototypeOf()  Object.getPrototypeOf 方法可以用来从子类上获取父类。  ``` Object.getPrototypeOf(ColorPoint) === Point // true ```  ### super 关键字  super 这个关键字，既可以当作函数使用，也可以当作对象使用。在这两种情况下，它的用法完全不同。  注意，使用 super 的时候，必须显式指定是作为函数、还是作为对象使用，否则会报错。  ```js class A {} class B extends A {   constructor() {     super();     console.log(super); // 报错   } } ```  #### 当作函数使用  super 作为函数调用时，代表父类的构造函数。ES6 要求，子类的构造函数必须执行一次 super 函数。  ```js class A {}  class B extends A {   constructor() {     super();   } } ```  注意，super 虽然代表了父类 A 的构造函数，但是返回的是子类 B 的实例，即 super 内部的 this 指的是 B，因此 super()在这里相当于 A.prototype.constructor.call(this)。   作为函数时，super()只能用在子类的构造函数之中，用在其他地方就会报错。  ```js class A {} class B extends A {   m() {     super(); // 报错   } } ```  #### super 作为对象时  ##### 在普通方法中  super 作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。  ```js class A {   p() {     return 2;   } } class B extends A {   constructor() {     super();     console.log(super.p()); // 2   } } let b = new B(); ```  这里需要注意，由于 super 指向父类的原型对象，所以定义在父类实例上的方法或属性，是无法通过 super 调用的。  ```js class A {   constructor() {     this.p = 2;   } } class B extends A {   get m() {     return super.p;   } } let b = new B(); b.m; // undefined ```  如果属性定义在父类的原型对象上，super 就可以取到。  ```js class A {} A.prototype.x = 2; class B extends A {   constructor() {     super();     console.log(super.x); // 2   } } let b = new B(); ```  ES6 规定，在子类普通方法中通过 super 调用父类的方法时，方法内部的 this 指向当前的子类实例。  ```js class A {   constructor() {     this.x = 1;   }   print() {     console.log(this.x);   } } class B extends A {   constructor() {     super();     this.x = 2;   }   m() {     super.print();   } } let b = new B(); b.m(); // 2 ```  由于 this 指向子类实例，所以如果通过 super 对某个属性赋值，这时 super 就是 this，赋值的属性会变成子类实例的属性。  ```js class A {   constructor() {     this.x = 1;   } } class B extends A {   constructor() {     super();     this.x = 2;     super.x = 3;     console.log(super.x); // undefined     console.log(this.x); // 3   } } let b = new B(); ```  ##### 用在静态方法中  如果 super 作为对象，用在静态方法之中，这时 super 将指向父类，而不是父类的原型对象.  ```js class Parent {   static myMethod(msg) {     console.log('static', msg);   }   myMethod(msg) {     console.log('instance', msg);   } } class Child extends Parent {   static myMethod(msg) {     super.myMethod(msg);   }   myMethod(msg) {     super.myMethod(msg);   } } Child.myMethod(1); // static 1 var child = new Child(); child.myMethod(2); // instance 2 ```  另外，在子类的静态方法中通过 super 调用父类的方法时，方法内部的 this 指向当前的子类，而不是子类的实例。  ```js class A {   constructor() {     this.x = 1;   }   static print() {     console.log(this.x);   } } class B extends A {   constructor() {     super();     this.x = 2;   }   static m() {     super.print();   } } B.x = 3; B.m(); // 3 ```  ##### 在任意一个对象中  最后，由于对象总是继承其他对象的，所以可以在任意一个对象中，使用 super 关键字。  ```js var obj = {   toString() {     return 'MyObject: ' + super.toString();   } }; obj.toString(); // MyObject: [object Object] ```  ### 原生构造函数的继承  原生构造函数是指语言内置的构造函数，通常用来生成数据结构。ECMAScript 的原生构造函数大致有下面这些。  - Boolean() - Number() - String() - Array() - Date() - Function() - RegExp() - Error() - Object()  #### ES5  以前，这些原生构造函数是无法继承的，比如，不能自己定义一个 Array 的子类。  ```js function MyArray() {   Array.apply(this, arguments); } MyArray.prototype = Object.create(Array.prototype, {   constructor: {     value: MyArray,     writable: true,     configurable: true,     enumerable: true   } }); var colors = new MyArray(); colors[0] = 'red'; colors.length; // 0 colors.length = 0; colors[0]; // \"red\" ```  之所以会发生这种情况，是因为子类无法获得原生构造函数的内部属性，通过 Array.apply()或者分配给原型对象都不行。原生构造函数会忽略 apply 方法传入的 this，也就是说，原生构造函数的 this 无法绑定，导致拿不到内部属性。  ES5 是先新建子类的实例对象 this，再将父类的属性添加到子类上，由于父类的内部属性无法获取，导致无法继承原生的构造函数。比如，Array 构造函数有一个内部属性[[DefineOwnProperty]]，用来定义新属性时，更新 length 属性，这个内部属性无法在子类获取，导致子类的 length 属性行为不正常。  #### ES6  ES6 允许继承原生构造函数定义子类，因为 ES6 是先新建父类的实例对象 this，然后再用子类的构造函数修饰 this，使得父类的所有行为都可以继承。下面是一个继承 Array 的例子。  ```js class MyArray extends Array {   constructor(...args) {     super(...args);   } } var arr = new MyArray(); arr[0] = 12; arr.length; // 1  arr.length = 0; arr[0]; // undefined ```  这意味着，ES6 可以自定义原生数据结构（比如 Array、String 等）的子类，这是 ES5 无法做到的。   下面是一个自定义 Error 子类的例子，可以用来定制报错时的行为。  ```js class ExtendableError extends Error {   constructor(message) {     super();     this.message = message;     this.stack = new Error().stack;     this.name = this.constructor.name;   } } class MyError extends ExtendableError {   constructor(m) {     super(m);   } } var myerror = new MyError('ll'); myerror.message; // \"ll\" myerror instanceof Error; // true myerror.name; // \"MyError\" myerror.stack; // Error //     at MyError.ExtendableError //     ... ```  注意，继承 Object 的子类，有一个行为差异。  ```js class NewObj extends Object {   constructor() {     super(...arguments);   } } var o = new NewObj({ attr: true }); o.attr === true; // false ```  上面代码中，NewObj 继承了 Object，但是无法通过 super 方法向父类 Object 传参。这是因为 ES6 改变了 Object 构造函数的行为，一旦发现 Object 方法不是通过 new Object()这种形式调用，ES6 规定 Object 构造函数会忽略参数。  ``` class B extends A { } ```  上面代码的 A，只要是一个有 prototype 属性的函数，就能被 B 继承。由于函数都有 prototype 属性（除了 Function.prototype 函数），因此 A 可以是任意函数。  ### Mixin 模式的实现  Mixin 指的是多个对象合成一个新的对象，新对象具有各个组成成员的接口。它的最简单实现如下。  ```js const a = {   a: 'a' }; const b = {   b: 'b' }; const c = { ...a, ...b }; // {a: 'a', b: 'b'} ```  下面是一个更完备的实现，将多个类的接口“混入”（mix in）另一个类。  ```js function mix(...mixins) {   class Mix {}   for (let mixin of mixins) {     copyProperties(Mix.prototype, mixin); // 拷贝实例属性     copyProperties(Mix.prototype, Reflect.getPrototypeOf(mixin)); // 拷贝原型属性   }   return Mix; } function copyProperties(target, source) {   for (let key of Reflect.ownKeys(source)) {     if (key !== 'constructor' && key !== 'prototype' && key !== 'name') {       let desc = Object.getOwnPropertyDescriptor(source, key);       Object.defineProperty(target, key, desc);     }   } } ```  ```js class DistributedEdit extends mix(Loggable, Serializable) {   // ... } ``` "},{title:"【读书笔记】ES6之async函数",path:"/posts/%E3%80%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%91ES6%E4%B9%8Basync%E5%87%BD%E6%95%B0.html",strippedContent:" ## 含义  async 函数是什么？一句话，它就是 Generator 函数的语法糖。  ```js const asyncReadFile = async function() {   const f1 = await readFile('/etc/fstab');   const f2 = await readFile('/etc/shells');   console.log(f1.toString());   console.log(f2.toString()); }; ```  async 函数就是将 Generator 函数的星号（\\*）替换成 async，将 yield 替换成 await，仅此而已。  ## async 函数对 Generator 函数的改进  - 内置执行器。     Generator 函数的执行必须靠执行器，所以才有了 co 模块，而 async 函数自带执行器。也就是说，async 函数的执行，与普通函数一模一样，只要一行。  ```js asyncReadFile(); ```  - 更好的语义。     async 和 await，比起星号和 yield，语义更清楚了。async 表示函数里有异步操作，await 表示紧跟在后面的表达式需要等待结果。 - 更广的适用性。     co 模块约定，yield 命令后面只能是 Thunk 函数或 Promise 对象，而 async 函数的 await 命令后面，可以是 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）。 - 返回值是 Promise。     async 函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用 then 方法指定下一步的操作。  进一步说，async 函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而 await 命令就是内部 then 命令的语法糖。  ## 基本用法  async 函数返回一个 Promise 对象，可以使用 then 方法添加回调函数。当函数执行的时候，一旦遇到 await 就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。  ```js async function getStockPriceByName(name) {   const symbol = await getStockSymbol(name);   const stockPrice = await getStockPrice(symbol);   return stockPrice; }  getStockPriceByName('goog').then(function(result) {   console.log(result); }); ```  async 函数有多种使用形式。  ```js // 函数声明 async function foo() {}  // 函数表达式 const foo = async function () {};  // 对象的方法 let obj = { async foo() {} }; obj.foo().then(...)  // Class 的方法 class Storage {   constructor() {     this.cachePromise = caches.open('avatars');   }    async getAvatar(name) {     const cache = await this.cachePromise;     return cache.match(`/avatars/${name}.jpg`);   } }  const storage = new Storage(); storage.getAvatar('jake').then(…);  // 箭头函数 const foo = async () => {}; ```  ## 语法  ### 返回 Promise 对象  async 函数返回一个 Promise 对象。  async 函数内部 return 语句返回的值，会成为 then 方法回调函数的参数。  ```js async function f() {   return 'hello world'; }  f().then(v => console.log(v)); // \"hello world\" ```  async 函数内部抛出错误，会导致返回的 Promise 对象变为 reject 状态。抛出的错误对象会被 catch 方法回调函数接收到。  ``` async function f() {   throw new Error('出错了'); }  f().then(   v => console.log(v),   e => console.log(e) ) // Error: 出错了 ```  ### 返回的 Promise 对象的状态变化  async 函数返回的 Promise 对象，必须等到内部所有 await 命令后面的 Promise 对象执行完，才会发生状态改变，除非遇到 return 语句或者抛出错误。也就是说，只有 async 函数内部的异步操作执行完，才会执行 then 方法指定的回调函数.  ```js async function getTitle(url) {   let response = await fetch(url);   let html = await response.text();   return html.match(/<title>([\\s\\S]+)<\\/title>/i)[1]; } getTitle('https://tc39.github.io/ecma262/').then(console.log); // \"ECMAScript 2017 Language Specification\" ```  上面代码中，函数 getTitle 内部有三个操作：抓取网页、取出文本、匹配页面标题。只有这三个操作全部完成，才会执行 then 方法里面的 console.log。  ### await 命令  正常情况下，await 命令后面是一个 Promise 对象。如果不是，就返回对应的值。  ```js async function f() {   // 等同于   // return 123;   return await 123; }  f().then(v => console.log(v)); // 123 ```  await 命令后面的 Promise 对象如果变为 reject 状态，则 reject 的参数会被 catch 方法的回调函数接收到。  ```js async function f() {   await Promise.reject('出错了'); }  f()   .then(v => console.log(v))   .catch(e => console.log(e)); // 出错了 ```  只要一个 await 语句后面的 Promise 变为 reject，那么整个 async 函数都会中断执行。  ```js async function f() {   await Promise.reject('出错了');   await Promise.resolve('hello world'); // 不会执行 } ```  有时，我们希望即使前一个异步操作失败，也不要中断后面的异步操作。这时可以将第一个 await 放在 try...catch 结构里面，这样不管这个异步操作是否成功，第二个 await 都会执行。  ```js async function f() {   try {     await Promise.reject('出错了');   } catch (e) {}   return await Promise.resolve('hello world'); }  f().then(v => console.log(v)); // hello world ```  另一种方法是 await 后面的 Promise 对象再跟一个 catch 方法，处理前面可能出现的错误。  ```js async function f() {   await Promise.reject('出错了').catch(e => console.log(e));   return await Promise.resolve('hello world'); }  f().then(v => console.log(v)); // 出错了 // hello world ```  ### 错误处理  如果 await 后面的异步操作出错，那么等同于 async 函数返回的 Promise 对象被 reject。   防止出错的方法，也是将其放在 try...catch 代码块之中。  ```js async function f() {   try {     await new Promise(function(resolve, reject) {       throw new Error('出错了');     });   } catch (e) {}   return await 'hello world'; } ```  如果有多个 await 命令，可以统一放在 try...catch 结构中。  ```js async function main() {   try {     const val1 = await firstStep();     const val2 = await secondStep(val1);     const val3 = await thirdStep(val1, val2);      console.log('Final: ', val3);   } catch (err) {     console.error(err);   } } ```  ### 使用注意点  - 第一点，前面已经说过，await 命令后面的 Promise 对象，运行结果可能是 rejected，所以最好把 await 命令放在 try...catch 代码块中。 - 第二点，多个 await 命令后面的异步操作，如果不存在继发关系，最好让它们同时触发。  ```js // 写法一 let [foo, bar] = await Promise.all([getFoo(), getBar()]);  // 写法二 let fooPromise = getFoo(); let barPromise = getBar(); let foo = await fooPromise; let bar = await barPromise; ```  - 第三点，await 命令只能用在 async 函数之中，如果用在普通函数，就会报错。  ```js function dbFuc(db) {   //这里不需要 async   let docs = [{}, {}, {}];    // 可能得到错误结果   docs.forEach(async function(doc) {     await db.post(doc);   }); } ```  如果确实希望多个请求并发执行，可以使用 Promise.all 方法。当三个请求都会 resolved 时，下面两种写法效果相同。  ```js async function dbFuc(db) {   let docs = [{}, {}, {}];   let promises = docs.map(doc => db.post(doc));    let results = await Promise.all(promises);   console.log(results); }  // 或者使用下面的写法  async function dbFuc(db) {   let docs = [{}, {}, {}];   let promises = docs.map(doc => db.post(doc));    let results = [];   for (let promise of promises) {     results.push(await promise);   }   console.log(results); } ```  目前，esm 模块加载器支持顶层 await，即 await 命令可以不放在 async 函数里面，直接使用。  ```js // async 函数的写法 const start = async () => {   const res = await fetch('google.com');   return res.text(); };  start().then(console.log);  // 顶层 await 的写法 const res = await fetch('google.com'); console.log(await res.text()); ```  ## async 函数的实现原理  async 函数的实现原理，就是将 Generator 函数和自动执行器，包装在一个函数里。  ```js async function fn(args) {   // ... }  // 等同于  function fn(args) {   return spawn(function*() {     // ...   }); }  function spawn(genF) {   return new Promise(function(resolve, reject) {     const gen = genF();     function step(nextF) {       let next;       try {         next = nextF();       } catch (e) {         return reject(e);       }       if (next.done) {         return resolve(next.value);       }       Promise.resolve(next.value).then(         function(v) {           step(function() {             return gen.next(v);           });         },         function(e) {           step(function() {             return gen.throw(e);           });         }       );     }     step(function() {       return gen.next(undefined);     });   }); } ```  ## 实例：按顺序完成异步操作  实际开发中，经常遇到一组异步操作，需要按照顺序完成。比如，依次远程读取一组 URL，然后按照读取的顺序输出结果。  ```js async function logInOrder(urls) {   for (const url of urls) {     const response = await fetch(url);     console.log(await response.text());   } } ```  上面代码确实大大简化，问题是所有远程操作都是继发。只有前一个 URL 返回结果，才会去读取下一个 URL，这样做效率很差，非常浪费时间。我们需要的是并发发出远程请求。  ```js async function logInOrder(urls) {   // 并发读取远程URL   const textPromises = urls.map(async url => {     const response = await fetch(url);     return response.text();   });    // 按次序输出   for (const textPromise of textPromises) {     console.log(await textPromise);   } } ```  就是改为 一个 async 只有一个 await,然后同时发几个 async.  ## 异步遍历器  Iterator 接口这里隐含着一个规定，next 方法必须是同步的，只要调用就必须立刻返回值。也就是说，一旦执行 next 方法，就必须同步地得到 value 和 done 这两个属性。如果遍历指针正好指向同步操作，当然没有问题，但对于异步操作，就不太合适了。目前的解决方法是，Generator 函数里面的异步操作，返回一个 Thunk 函数或者 Promise 对象，即 value 属性是一个 Thunk 函数或者 Promise 对象，等待以后返回真正的值，而 done 属性则还是同步产生的。   ES2018 引入了”异步遍历器“（Async Iterator），为异步操作提供原生的遍历器接口，即 value 和 done 这两个属性都是异步产生。  ### 异步遍历的接口  异步遍历器的最大的语法特点，就是调用遍历器的 next 方法，返回的是一个 Promise 对象。  ```js asyncIterator   .next()   .then(     ({ value, done }) => /* ... */   ); ```  上面代码中，asyncIterator 是一个异步遍历器，调用 next 方法以后，返回一个 Promise 对象。因此，可以使用 then 方法指定，这个 Promise 对象的状态变为 resolve 以后的回调函数。回调函数的参数，则是一个具有 value 和 done 两个属性的对象，这个跟同步遍历器是一样的。   对象的异步遍历器接口，部署在 Symbol.asyncIterator 属性上面。不管是什么样的对象，只要它的 Symbol.asyncIterator 属性有值，就表示应该对它进行异步遍历。  ```js const asyncIterable = createAsyncIterable(['a', 'b']); const asyncIterator = asyncIterable[Symbol.asyncIterator]();  asyncIterator   .next()   .then(iterResult1 => {     console.log(iterResult1); // { value: 'a', done: false }     return asyncIterator.next();   })   .then(iterResult2 => {     console.log(iterResult2); // { value: 'b', done: false }     return asyncIterator.next();   })   .then(iterResult3 => {     console.log(iterResult3); // { value: undefined, done: true }   }); ```  由于异步遍历器的 next 方法，返回的是一个 Promise 对象。因此，可以把它放在 await 命令后面。  ```js async function f() {   const asyncIterable = createAsyncIterable(['a', 'b']);   const asyncIterator = asyncIterable[Symbol.asyncIterator]();   console.log(await asyncIterator.next());   // { value: 'a', done: false }   console.log(await asyncIterator.next());   // { value: 'b', done: false }   console.log(await asyncIterator.next());   // { value: undefined, done: true } } ```  上面代码中，next 方法用 await 处理以后，就不必使用 then 方法了。   注意，异步遍历器的 next 方法是可以连续调用的，不必等到上一步产生的 Promise 对象 resolve 以后再调用。这种情况下，next 方法会累积起来，自动按照每一步的顺序运行下去。下面是一个例子，把所有的 next 方法放在 Promise.all 方法里面。  ```js const asyncIterable = createAsyncIterable(['a', 'b']); const asyncIterator = asyncIterable[Symbol.asyncIterator](); const [{ value: v1 }, { value: v2 }] = await Promise.all([   asyncIterator.next(),   asyncIterator.next() ]);  console.log(v1, v2); // a b ```  ### for await...of  新引入的 for await...of 循环，则是用于遍历异步的 Iterator 接口。  ```js async function f() {   for await (const x of createAsyncIterable(['a', 'b'])) {     console.log(x);   } } // a // b ```  上面代码中，createAsyncIterable()返回一个拥有异步遍历器接口的对象，for...of 循环自动调用这个对象的异步遍历器的 next 方法，会得到一个 Promise 对象。await 用来处理这个 Promise 对象，一旦 resolve，就把得到的值（x）传入 for...of 的循环体。  如果 next 方法返回的 Promise 对象被 reject，for await...of 就会报错，要用 try...catch 捕捉。  ```js async function () {   try {     for await (const x of createRejectingIterable()) {       console.log(x);     }   } catch (e) {     console.error(e);   } } ```  for await...of 循环也可以用于同步遍历器。  ```js (async function() {   for await (const x of ['a', 'b']) {     console.log(x);   } })(); // a // b ```  Node v10 支持异步遍历器，Stream 就部署了这个接口。下面是读取文件的传统写法与异步遍历器写法的差异。  ```js // 传统写法 function main(inputFilePath) {   const readStream = fs.createReadStream(inputFilePath, {     encoding: 'utf8',     highWaterMark: 1024   });   readStream.on('data', chunk => {     console.log('>>> ' + chunk);   });   readStream.on('end', () => {     console.log('### DONE ###');   }); }  // 异步遍历器写法 async function main(inputFilePath) {   const readStream = fs.createReadStream(inputFilePath, {     encoding: 'utf8',     highWaterMark: 1024   });    for await (const chunk of readStream) {     console.log('>>> ' + chunk);   }   console.log('### DONE ###'); } ```  ## 异步 Generator 函数  就像 Generator 函数返回一个同步遍历器对象一样，异步 Generator 函数的作用，是返回一个异步遍历器对象。 在语法上，异步 Generator 函数就是 async 函数与 Generator 函数的结合。  ```js async function* gen() {   yield 'hello'; } const genObj = gen(); genObj.next().then(x => console.log(x)); // { value: 'hello', done: false } ```  ```js async function* readLines(path) {   let file = await fileOpen(path);    try {     while (!file.EOF) {       yield await file.readLine();     }   } finally {     await file.close();   } } ```  上面代码定义的异步 Generator 函数的用法如下。  ```js (async function() {   for await (const line of readLines(filePath)) {     console.log(line);   } })(); ```  异步 Generator 函数可以与 for await...of 循环结合起来使用。  ```js async function* prefixLines(asyncIterable) {   for await (const line of asyncIterable) {     yield '> ' + line;   } } ```  如果异步 Generator 函数抛出错误，会导致 Promise 对象的状态变为 reject，然后抛出的错误被 catch 方法捕获。  ```js async function* asyncGenerator() {   throw new Error('Problem!'); }  asyncGenerator()   .next()   .catch(err => console.log(err)); // Error: Problem! ```  一个异步 Generator 函数的执行器。  ```js async function takeAsync(asyncIterable, count = Infinity) {   const result = [];   const iterator = asyncIterable[Symbol.asyncIterator]();   while (result.length < count) {     const { value, done } = await iterator.next();     if (done) break;     result.push(value);   }   return result; } ```  ```js async function f() {   async function* gen() {     yield 'a';     yield 'b';     yield 'c';   }    return await takeAsync(gen()); }  f().then(function(result) {   console.log(result); // ['a', 'b', 'c'] }); ```  基本上，如果是一系列按照顺序执行的异步操作（比如读取文件，然后写入新内容，再存入硬盘），可以使用 async 函数；如果是一系列产生相同数据结构的异步操作（比如一行一行读取文件），可以使用异步 Generator 函数。   异步 Generator 函数也可以通过 next 方法的参数，接收外部传入的数据。  ```js const writer = openFile('someFile.txt'); writer.next('hello'); // 立即执行 writer.next('world'); // 立即执行 await writer.return(); // 等待写入结束 ```  最后，同步的数据结构，也可以使用异步 Generator 函数。  ```js async function* createAsyncIterable(syncIterable) {   for (const elem of syncIterable) {     yield elem;   } } ```  yield\\*语句也可以跟一个异步遍历器。  ```js async function* gen1() {   yield 'a';   yield 'b';   return 2; }  async function* gen2() {   // result 最终会等于 2   const result = yield* gen1(); } ```  与同步 Generator 函数一样，for await...of 循环会展开 yield\\*。  ```js (async function() {   for await (const x of gen2()) {     console.log(x);   } })(); // a // b ``` "},{title:"【读书笔记】ES6之Generator 函数的异步应用",path:"/posts/%E3%80%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%91ES6%E4%B9%8BGenerator-%E5%87%BD%E6%95%B0%E7%9A%84%E5%BC%82%E6%AD%A5%E5%BA%94%E7%94%A8.html",strippedContent:" ## 传统异步方法  ES6 诞生以前，异步编程的方法，大概有下面四种。  - 回调函数 - 事件监听 - 发布/订阅 - Promise 对象  Generator 函数将 JavaScript 异步编程带入了一个全新的阶段。  ## 基本概念  ### 异步  所谓\"异步\"，简单说就是一个任务不是连续完成的，可以理解成该任务被人为分成两段，先执行第一段，然后转而执行其他任务，等做好了准备，再回过头执行第二段。   比如，有一个任务是读取文件进行处理，任务的第一段是向操作系统发出请求，要求读取文件。然后，程序执行其他任务，等到操作系统返回文件，再接着执行任务的第二段（处理文件）。这种不连续的执行，就叫做异步。  ### 回调函数  JavaScript 语言对异步编程的实现，就是回调函数。所谓回调函数，就是把任务的第二段单独写在一个函数里面，等到重新执行这个任务的时候，就直接调用这个函数。回调函数的英语名字 callback，直译过来就是\"重新调用\"。   一个有趣的问题是，为什么 Node 约定，回调函数的第一个参数，必须是错误对象 err（如果没有错误，该参数就是 null）？   原因是执行分成两段，第一段执行完以后，任务所在的上下文环境就已经结束了。在这以后抛出的错误，原来的上下文环境已经无法捕捉，只能当作参数，传入第二段。  ## 协程的 Generator 函数实现  Generator 函数是协程在 ES6 的实现，最大特点就是可以交出函数的执行权（即暂停执行）。   整个 Generator 函数就是一个封装的异步任务，或者说是异步任务的容器。异步操作需要暂停的地方，都用 yield 语句注明。Generator 函数的执行方法如下。  ```js function* gen(x) {   var y = yield x + 2;   return y; }  var g = gen(1); g.next(); // { value: 3, done: false } g.next(); // { value: undefined, done: true } ```  ## Generator 函数的数据交换和错误处理  Generator 函数可以暂停执行和恢复执行，这是它能封装异步任务的根本原因。除此之外，它还有两个特性，使它可以作为异步编程的完整解决方案：函数体内外的数据交换和错误处理机制。   next 返回值的 value 属性，是 Generator 函数向外输出数据；next 方法还可以接受参数，向 Generator 函数体内输入数据。  ````js function* gen(x){   var y = yield x + 2;   return y; }  var g = gen(1); g.next() // { value: 3, done: false } g.next(2) // { value: 2, done: true } ```js Generator 函数内部还可以部署错误处理代码，捕获函数体外抛出的错误。 ```js function* gen(x){   try {     var y = yield x + 2;   } catch (e){     console.log(e);   }   return y; }  var g = gen(1); g.next(); g.throw('出错了'); // 出错了 ````  ## Thunk 函数  Thunk 函数是自动执行 Generator 函数的一种方法。  ### 参数的求值策略  ```js var x = 1;  function f(m) {   return m * 2; }  f(x + 5); ```  上面代码先定义函数 f，然后向它传入表达式 x + 5。请问，这个表达式应该何时求值.一种意见是\"传值调用\"（call by value），即在进入函数体之前，就计算 x + 5 的值（等于 6），再将这个值传入函数 f。C 语言就采用这种策略。   另一种意见是“传名调用”（call by name），即直接将表达式 x+5 传入函数体，只在用到它的时候求值。Haskell 语言采用这种策略。 传值调用和传名调用，哪一种比较好？回答是各有利弊。传值调用比较简单，但是对参数求值的时候，实际上还没用到这个参数，有可能造成性能损失。  ### Thunk 函数的含义  编译器的“传名调用”实现，往往是将参数放到一个临时函数之中，再将这个临时函数传入函数体。这个临时函数就叫做 Thunk 函数。  ````js function f(m) {   return m * 2; } f(x + 5); // 等同于 var thunk = function () {   return x + 5; }; function f(thunk) {   return thunk() * 2; } ```js 这就是 Thunk函数的定义，它是“传名调用”的一种实现策略，用来替换某个表达式。 ### JavaScript 语言的Thunk函数 JavaScript 语言是传值调用，它的 Thunk 函数含义有所不同。在 JavaScript 语言中，Thunk 函数替换的不是表达式，而是多参数函数，将其替换成一个只接受回调函数作为参数的单参数函数。 ```js // 正常版本的readFile（多参数版本） fs.readFile(fileName, callback);  // Thunk版本的readFile（单参数版本） var Thunk = function (fileName) {   return function (callback) {     return fs.readFile(fileName, callback);   }; };  var readFileThunk = Thunk(fileName); readFileThunk(callback); ````  上面代码中，fs 模块的 readFile 方法是一个多参数函数，两个参数分别为文件名和回调函数。经过转换器处理，它变成了一个单参数函数，只接受回调函数作为参数。这个单参数版本，就叫做 Thunk 函数。   任何函数，只要参数有回调函数，就能写成 Thunk 函数的形式。下面是一个简单的 Thunk 函数转换器。  ```js // ES5版本 var Thunk = function(fn) {   return function() {     var args = Array.prototype.slice.call(arguments);     return function(callback) {       args.push(callback);       return fn.apply(this, args);     };   }; };  // ES6版本 const Thunk = function(fn) {   return function(...args) {     return function(callback) {       return fn.call(this, ...args, callback);     };   }; }; ```  使用上面的转换器，生成 fs.readFile 的 Thunk 函数。  ```js var readFileThunk = Thunk(fs.readFile); readFileThunk(fileA)(callback); ```  ### Thunkify 模块  生产环境的转换器，建议使用 Thunkify 模块。  ```js npm install thunkify ```  使用方式如下。  ```js var thunkify = require('thunkify'); var fs = require('fs');  var read = thunkify(fs.readFile); read('package.json')(function(err, str) {   // ... }); ```  Thunkify 的源码与上一节那个简单的转换器非常像。  ```js function thunkify(fn) {   return function() {     var args = new Array(arguments.length);     var ctx = this;      for (var i = 0; i < args.length; ++i) {       args[i] = arguments[i];     }      return function(done) {       var called;        args.push(function() {         if (called) return;         called = true;         done.apply(null, arguments);       });        try {         fn.apply(ctx, args);       } catch (err) {         done(err);       }     };   }; } ```  它的源码主要多了一个检查机制，变量 called 确保回调函数只运行一次。  ```js function f(a, b, callback) {   var sum = a + b;   callback(sum);   callback(sum); } var ft = thunkify(f); var print = console.log.bind(console); ft(1, 2)(print); // 3 ```  ### 用于 Generator 函数的流程管理  Thunk 函数现在可以用于 Generator 函数的自动流程管理。Generator 函数可以自动执行。  ```js function* gen() {   // ... } var g = gen(); var res = g.next(); while (!res.done) {   console.log(res.value);   res = g.next(); } ```  上面代码中，Generator 函数 gen 会自动执行完所有步骤。但是，这不适合异步操作。如果必须保证前一步执行完，才能执行后一步，上面的自动执行就不可行。这时，Thunk 函数就能派上用处。Thunk 函数真正的威力，在于可以自动执行 Generator 函数。下面就是一个基于 Thunk 函数的 Generator 执行器。  ```js function run(fn) {   var gen = fn();    function next(err, data) {     var result = gen.next(data);     if (result.done) return;     result.value(next);   }    next(); }  function* g() {   // ... }  run(g); ```  上面代码的 run 函数，就是一个 Generator 函数的自动执行器。内部的 next 函数就是 Thunk 的回调函数。next 函数先将指针移到 Generator 函数的下一步（gen.next 方法），然后判断 Generator 函数是否结束（result.done 属性），如果没结束，就将 next 函数再传入 Thunk 函数（result.value 属性），否则就直接退出。   有了这个执行器，执行 Generator 函数方便多了。不管内部有多少个异步操作，直接把 Generator 函数传入 run 函数即可。当然，前提是每一个异步操作，都要是 Thunk 函数，也就是说，跟在 yield 命令后面的必须是 Thunk 函数.  ````js var g = function* (){   var f1 = yield readFileThunk('fileA');   var f2 = yield readFileThunk('fileB');   // ...   var fn = yield readFileThunk('fileN'); };  run(g); ```js ## co模块 ### 基本用法 下面是一个 Generator函数，用于依次读取两个文件。 ```js var gen = function* () {   var f1 = yield readFile('/etc/fstab');   var f2 = yield readFile('/etc/shells');   console.log(f1.toString());   console.log(f2.toString()); }; ````  co 模块可以让你不用编写 Generator 函数的执行器。  ```js var co = require('co'); co(gen); ```  co 函数返回一个 Promise 对象，因此可以用 then 方法添加回调函数。  ```js co(gen).then(function() {   console.log('Generator 函数执行完成'); }); ```  ### co 模块的原理  前面说过，Generator 就是一个异步操作的容器。它的自动执行需要一种机制，当异步操作有了结果，能够自动交回执行权。 两种方法可以做到这一点。  - 回调函数。将异步操作包装成 Thunk 函数，在回调函数里面交回执行权。 - Promise 对象。将异步操作包装成 Promise 对象，用 then 方法交回执行权。     co 模块其实就是将两种自动执行器（Thunk 函数和 Promise 对象），包装成一个模块。使用 co 的前提条件是，Generator 函数的 yield 命令后面，只能是 Thunk 函数或 Promise 对象。如果数组或对象的成员，全部都是 Promise 对象，也可以使用 co，详见后文的例子。  ### 基于 Promise 对象的自动执行  ```js var fs = require('fs');  var readFile = function(fileName) {   return new Promise(function(resolve, reject) {     fs.readFile(fileName, function(error, data) {       if (error) return reject(error);       resolve(data);     });   }); };  var gen = function*() {   var f1 = yield readFile('/etc/fstab');   var f2 = yield readFile('/etc/shells');   console.log(f1.toString());   console.log(f2.toString()); }; ```  然后，手动执行上面的 Generator 函数。  ```js var g = gen();  g.next().value.then(function(data) {   g.next(data).value.then(function(data) {     g.next(data);   }); }); ```  手动执行其实就是用 then 方法，层层添加回调函数。理解了这一点，就可以写出一个自动执行器。  ```js function run(gen) {   var g = gen();    function next(data) {     var result = g.next(data);     if (result.done) return result.value;     result.value.then(function(data) {       next(data);     });   }    next(); }  run(gen); ```  ### co 模块的源码  首先，co 函数接受 Generator 函数作为参数，返回一个 Promise 对象。  ```js function co(gen) {   var ctx = this;    return new Promise(function(resolve, reject) {}); } ```  在返回的 Promise 对象里面，co 先检查参数 gen 是否为 Generator 函数。如果是，就执行该函数，得到一个内部指针对象；如果不是就返回，并将 Promise 对象的状态改为 resolved。  ```js function co(gen) {   var ctx = this;    return new Promise(function(resolve, reject) {     if (typeof gen === 'function') gen = gen.call(ctx);     if (!gen || typeof gen.next !== 'function') return resolve(gen);   }); } ```  接着，co 将 Generator 函数的内部指针对象的 next 方法，包装成 onFulfilled 函数。这主要是为了能够捕捉抛出的错误。  ````js function co(gen) {   var ctx = this;    return new Promise(function(resolve, reject) {     if (typeof gen === 'function') gen = gen.call(ctx);     if (!gen || typeof gen.next !== 'function') return resolve(gen);      onFulfilled();     function onFulfilled(res) {       var ret;       try {         ret = gen.next(res);       } catch (e) {         return reject(e);       }       next(ret);     }   }); } ```js 最后，就是关键的next函数，它会反复调用自身。 ```js function next(ret) {   if (ret.done) return resolve(ret.value);   var value = toPromise.call(ctx, ret.value);   if (value && isPromise(value)) return value.then(onFulfilled, onRejected);   return onRejected(     new TypeError(       'You may only yield a function, promise, generator, array, or object, '       + 'but the following object was passed: \"'       + String(ret.value)       + '\"'     )   ); } ````  第一行，检查当前是否为 Generator 函数的最后一步，如果是就返回。   第二行，确保每一步的返回值，是 Promise 对象。   第三行，使用 then 方法，为返回值加上回调函数，然后通过 onFulfilled 函数再次调用 next 函数。   第四行，在参数不符合要求的情况下（参数非 Thunk 函数和 Promise 对象），将 Promise 对象的状态改为 rejected，从而终止执行。  ### 处理并发的异步操作  co 支持并发的异步操作，即允许某些操作同时进行，等到它们全部完成，才进行下一步。 这时，要把并发的操作都放在数组或对象里面，跟在 yield 语句后面。  ```js // 数组的写法 co(function*() {   var res = yield [Promise.resolve(1), Promise.resolve(2)];   console.log(res); }).catch(onerror);  // 对象的写法 co(function*() {   var res = yield {     1: Promise.resolve(1),     2: Promise.resolve(2)   };   console.log(res); }).catch(onerror); ```  ### 实例：处理 Stream  Node 提供 Stream 模式读写数据，特点是一次只处理数据的一部分，数据分成一块块依次处理，就好像“数据流”一样。这对于处理大规模数据非常有利。Stream 模式使用 EventEmitter API，会释放三个事件。  - data 事件：下一块数据块已经准备好了。 - end 事件：整个“数据流”处理“完了。 - error 事件：发生错误  使用 Promise.race()函数，可以判断这三个事件之中哪一个最先发生，只有当 data 事件最先发生时，才进入下一个数据块的处理。从而，我们可以通过一个 while 循环，完成所有数据的读取。  ```js const co = require('co'); const fs = require('fs');  const stream = fs.createReadStream('./les_miserables.txt'); let valjeanCount = 0;  co(function*() {   while (true) {     const res = yield Promise.race([       new Promise(resolve => stream.once('data', resolve)),       new Promise(resolve => stream.once('end', resolve)),       new Promise((resolve, reject) => stream.once('error', reject))     ]);     if (!res) {       break;     }     stream.removeAllListeners('data');     stream.removeAllListeners('end');     stream.removeAllListeners('error');     valjeanCount += (res.toString().match(/valjean/gi) || []).length;   }   console.log('count:', valjeanCount); // count: 1120 }); ```  上面代码采用 Stream 模式读取《悲惨世界》的文本文件，对于每个数据块都使用 stream.once 方法，在 data、end、error 三个事件上添加一次性回调函数。变量 res 只有在 data 事件发生时才有值，然后累加每个数据块之中 valjean 这个词出现的次数。 "},{title:"【读书笔记】ES6之生成器（generator）",path:"/posts/%E3%80%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%91ES6%E4%B9%8B%E7%94%9F%E6%88%90%E5%99%A8%EF%BC%88generator%EF%BC%89.html",strippedContent:" ## 简介  Generator 函数有多种理解角度。语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。   执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。   调用 Generator 函数后，该函数并不执行，返回的也不是函数运行结果，而是一个遍历器对象（Iterator Object）。   下一步，必须调用遍历器对象的 next 方法，使得指针移向下一个状态。也就是说，每次调用 next 方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个 yield 表达式（或 return 语句）为止。换言之，Generator 函数是分段执行的，yield 表达式是暂停执行的标记，而 next 方法可以恢复执行。   生成器函数由放在 function 关键字之后的一个星号（\\*）来表示，并能使用新的 yield 关键字。将星号紧跟在 function 关键字之后，或是在中间留出空格，都是没问题的.  ```js function * foo(x, y) { ··· } function *foo(x, y) { ··· } function* foo(x, y) { ··· } function*foo(x, y) { ··· }  function* helloWorldGenerator() {   yield 'hello';   yield 'world';   return 'ending'; }  var hw = helloWorldGenerator(); hw.next() // { value: 'hello', done: false } hw.next() // { value: 'world', done: false } hw.next() // { value: 'ending', done: true } hw.next() // { value: undefined, done: true } ```  ## yield 表达式的细节  yield 表达式后面的表达式，只有当调用 next 方法、内部指针指向该语句时才会执行，因此等于为 JavaScript 提供了手动的“惰性求值”（Lazy Evaluation）的语法功能。  ```js function* gen() {   yield 123 + 456; } ```  另外需要注意，yield 表达式只能用在 Generator 函数里面，用在其他地方都会报错。  ```js (function (){   yield 1; })() // SyntaxError: Unexpected number ```  yield 表达式如果用在另一个表达式之中，必须放在圆括号里面。  ```js function* demo() {   console.log('Hello' + yield); // SyntaxError   console.log('Hello' + yield 123); // SyntaxError    console.log('Hello' + (yield)); // OK   console.log('Hello' + (yield 123)); // OK } ```  yield 表达式用作函数参数或放在赋值表达式的右边，可以不加括号。  ```js function* demo() {   foo(yield 'a', yield 'b'); // OK   let input = yield; // OK } ```  ## 与 Iterator 接口的关系  任意一个对象的 Symbol.iterator 方法，等于该对象的遍历器生成函数，调用该函数会返回该对象的一个遍历器对象。   由于 Generator 函数就是遍历器生成函数，因此可以把 Generator 赋值给对象的 Symbol.iterator 属性，从而使得该对象具有 Iterator 接口。  ```js var myIterable = {}; myIterable[Symbol.iterator] = function*() {   yield 1;   yield 2;   yield 3; };  [...myIterable]; // [1, 2, 3] ```  Generator 函数执行后，返回一个遍历器对象。该对象本身也具有 Symbol.iterator 属性，执行后返回自身。  ```js function* gen() {   // some code }  var g = gen();  g[Symbol.iterator]() === g; // true ```  ## 传递参数给迭代器,next 方法的参数  yield 表达式本身没有返回值，或者说总是返回 undefined。Generator 函数执行后，返回一个遍历器对象。此遍历器对象的 next 方法可以带一个参数，该参数就会被当作上一个 yield 表达式的返回值。  ```js function* f() {   for (var i = 0; true; i++) {     var reset = yield i;     if (reset) {       i = -1;     }   } }  var g = f();  g.next(); // { value: 0, done: false } g.next(); // { value: 1, done: false } g.next(true); // { value: 0, done: false } ```  这个功能有很重要的语法意义。Generator 函数从暂停状态到恢复运行，它的上下文状态（context）是不变的。通过 next 方法的参数，就有办法在 Generator 函数开始运行之后，继续向函数体内部注入值。也就是说，可以在 Generator 函数运行的不同阶段，从外部向内部注入不同的值，从而调整函数行为。  ```js function* foo(x) {   var y = 2 * (yield x + 1);   var z = yield y / 3;   return x + y + z; }  var a = foo(5); a.next(); // Object{value:6, done:false} a.next(); // Object{value:NaN, done:false} a.next(); // Object{value:NaN, done:true}  var b = foo(5); b.next(); // { value:6, done:false } b.next(12); // { value:8, done:false } b.next(13); // { value:42, done:true } ```  注意，在 Generator 函数中,由于 next 方法的参数表示上一个 yield 表达式的返回值，所以在第一次使用 next 方法时，传递参数是无效的。V8 引擎直接忽略第一次使用 next 方法时的参数，只有从第二次使用 next 方法开始，参数才是有效的。从语义上讲，第一个 next 方法用来启动遍历器对象，所以不用带有参数。不过 Iterator（遍历器）的 next 方法第一次是有值的.   如果想要第一次调用 next 方法时，就能够输入值，可以在 Generator 函数外面再包一层。用来返回一个启动的 Generator 函数.  ```js function wrapper(generatorFunction) {   return function(...args) {     let generatorObject = generatorFunction(...args);     generatorObject.next();     return generatorObject;   }; }  const wrapped = wrapper(function*() {   console.log(`First input: ${yield}`);   return 'DONE'; });  wrapped().next('hello!'); // First input: hello! ```  ## 与 for...of 循环结合  原生的 JavaScript 对象没有遍历接口，无法使用 for...of 循环，通过 Generator 函数为它加上这个接口，就可以用了。  ```js function* objectEntries(obj) {   let propKeys = Reflect.ownKeys(obj);    for (let propKey of propKeys) {     yield [propKey, obj[propKey]];   } }  let jane = { first: 'Jane', last: 'Doe' };  for (let [key, value] of objectEntries(jane)) {   console.log(`${key}: ${value}`); } // first: Jane // last: Doe ```  加上遍历器接口的另一种写法是，将 Generator 函数加到对象的 Symbol.iterator 属性上面。  ```js function* objectEntries() {   let propKeys = Object.keys(this);    for (let propKey of propKeys) {     yield [propKey, this[propKey]];   } }  let jane = { first: 'Jane', last: 'Doe' };  jane[Symbol.iterator] = objectEntries;  for (let [key, value] of jane) {   console.log(`${key}: ${value}`); } // first: Jane // last: Doe ```  ## Generator.prototype.throw()  Generator 函数返回的遍历器对象，都有一个 throw 方法，可以在函数体外抛出错误，然后在 Generator 函数体内捕获。  ```js var g = function*() {   try {     yield;   } catch (e) {     console.log('内部捕获', e);   } };  var i = g(); i.next();  try {   i.throw('a');   i.throw('b'); } catch (e) {   console.log('外部捕获', e); } // 内部捕获 a // 外部捕获 b ```  上面代码中，遍历器对象 i 连续抛出两个错误。第一个错误被 Generator 函数体内的 catch 语句捕获。i 第二次抛出错误，由于 Generator 函数内部的 catch 语句已经执行过了，不会再捕捉到这个错误了，所以这个错误就被抛出了 Generator 函数体，被函数体外的 catch 语句捕获。   throw 方法可以接受一个参数，该参数会被 catch 语句接收，建议抛出 Error 对象的实例.  ```js var g = function*() {   try {     yield;   } catch (e) {     console.log(e);   } };  var i = g(); i.next(); i.throw(new Error('出错了！')); // Error: 出错了！(…) ```  函数体外的 catch 语句块，捕获了抛出的 a 错误以后，就不会再继续 try 代码块里面剩余的语句了。  ```js var g = function*() {   while (true) {     try {       yield;     } catch (e) {       if (e != 'a') throw e;       console.log('内部捕获', e);     }   } };  var i = g(); i.next();  try {   throw new Error('a');   throw new Error('b'); } catch (e) {   console.log('外部捕获', e); } // 外部捕获 [Error: a] ```  如果 Generator 函数内部和外部，都没有部署 try...catch 代码块，那么程序将报错，直接中断执行。throw 方法抛出的错误要被内部捕获，前提是必须至少执行过一次 next 方法。  ```js function* gen() {   try {     yield 1;   } catch (e) {     console.log('内部捕获');   } }  var g = gen(); g.throw(1); // Uncaught 1 ```  throw 方法被捕获以后，会附带执行下一条 yield 表达式。也就是说，会附带执行一次 next 方法。  ```js var gen = function* gen() {   try {     yield console.log('a');   } catch (e) {     // ...   }   yield console.log('b');   yield console.log('c'); };  var g = gen(); g.next(); // a g.throw(); // b g.next(); // c ```  一旦 Generator 执行过程中抛出错误，且没有被内部捕获，就不会再执行下去了。如果此后还调用 next 方法，将返回一个 value 属性等于 undefined、done 属性等于 true 的对象，即 JavaScript 引擎认为这个 Generator 已经运行结束了。  ```js function* g() {   yield 1;   console.log('throwing an exception');   throw new Error('generator broke!');   yield 2;   yield 3; }  function log(generator) {   var v;   console.log('starting generator');   try {     v = generator.next();     console.log('第一次运行next方法', v);   } catch (err) {     console.log('捕捉错误', v);   }   try {     v = generator.next();     console.log('第二次运行next方法', v);   } catch (err) {     console.log('捕捉错误', v);   }   try {     v = generator.next();     console.log('第三次运行next方法', v);   } catch (err) {     console.log('捕捉错误', v);   }   console.log('caller done'); }  log(g()); // starting generator // 第一次运行next方法 { value: 1, done: false } // throwing an exception // 捕捉错误 { value: 1, done: false } // 第三次运行next方法 { value: undefined, done: true } // caller done ```  ## Generator.prototype.return()  Generator 函数返回的遍历器对象，还有一个 return 方法，可以返回给定的值，并且终结遍历 Generator 函数。如果 return 方法调用时，不提供参数，则返回值的 value 属性为 undefined.  ```js function* gen() {   yield 1;   yield 2;   yield 3; }  var g = gen();  g.next(); // { value: 1, done: false } g.return('foo'); // { value: \"foo\", done: true } g.next(); // { value: undefined, done: true } ```  如果 Generator 函数内部有 try...finally 代码块，且正在执行 try 代码块，那么 return 方法会推迟到 finally 代码块执行完再执行。  ```js function* numbers() {   yield 1;   try {     yield 2;     yield 3;   } finally {     yield 4;     yield 5;   }   yield 6; } var g = numbers(); g.next(); // { value: 1, done: false } g.next(); // { value: 2, done: false } g.return(7); // { value: 4, done: false } g.next(); // { value: 5, done: false } g.next(); // { value: 7, done: true } ```  ## next()、throw()、return() 的共同点  next()、throw()、return()这三个方法本质上是同一件事，可以放在一起理解。它们的作用都是让 Generator 函数恢复执行，并且使用不同的语句替换 yield 表达式。 next()是将 yield 表达式替换成一个值。  ```js const g = function*(x, y) {   let result = yield x + y;   return result; };  const gen = g(1, 2); gen.next(); // Object {value: 3, done: false}  gen.next(1); // Object {value: 1, done: true} // 相当于将 let result = yield x + y // 替换成 let result = 1; ```  throw()是将 yield 表达式替换成一个 throw 语句。  ```js gen.throw(new Error('出错了')); // Uncaught Error: 出错了 // 相当于将 let result = yield x + y // 替换成 let result = throw(new Error('出错了')); ```  return()是将 yield 表达式替换成一个 return 语句。  ```js gen.return(2); // Object {value: 2, done: true} // 相当于将 let result = yield x + y // 替换成 let result = return 2; ```  ## 生成器委托 yield\\*  如果在 Generator 函数内部，调用另一个 Generator 函数，默认情况下是没有效果的。  ```js function* foo() {   yield 'a';   yield 'b'; }  function* bar() {   yield 'x';   foo();   yield 'y'; }  for (let v of bar()) {   console.log(v); } // \"x\" // \"y\" ```  这个就需要用到 yield\\*表达式，用来在一个 Generator 函数里面执行另一个 Generator 函数。  ```js function* bar() {   yield 'x';   yield* foo();   yield 'y'; } // 等同于 function* bar() {   yield 'x';   yield 'a';   yield 'b';   yield 'y'; } // 等同于 function* bar() {   yield 'x';   for (let v of foo()) {     yield v;   }   yield 'y'; } for (let v of bar()) {   console.log(v); } // \"x\" // \"a\" // \"b\" // \"y\" ```  yield\\*后面的 Generator 函数（没有 return 语句时），等同于在 Generator 函数内部，部署一个 for...of 循环。  ```js function* concat(iter1, iter2) {   yield* iter1;   yield* iter2; }  // 等同于  function* concat(iter1, iter2) {   for (var value of iter1) {     yield value;   }   for (var value of iter2) {     yield value;   } } ```  实际上，任何数据结构只要有 Iterator 接口，就可以被 yield\\*遍历。  ```js let read = (function*() {   yield 'hello';   yield* 'hello'; })();  read.next().value; // \"hello\" read.next().value; // \"h\" ```  如果被代理的 Generator 函数有 return 语句，那么就可以向代理它的 Generator 函数返回数据。  ```js function* genFuncWithReturn() {   yield 'a';   yield 'b';   return 'The result'; } function* logReturned(genObj) {   let result = yield* genObj;   console.log(result); }  [...logReturned(genFuncWithReturn())]; //输出 The result // 值为 [ 'a', 'b' ] ```  yield\\*命令可以很方便地取出嵌套数组的所有成员。  ```js function* iterTree(tree) {   if (Array.isArray(tree)) {     for (let i = 0; i < tree.length; i++) {       yield* iterTree(tree[i]);     }   } else {     yield tree;   } }  const tree = ['a', ['b', 'c'], ['d', 'e']];  for (let x of iterTree(tree)) {   console.log(x); } // a // b // c // d // e ```  ## 把 Generator 函数改为构造函数  Generator 函数总是返回一个遍历器，ES6 规定这个遍历器是 Generator 函数的实例，也继承了 Generator 函数的 prototype 对象上的方法。  ```js function* g() {}  g.prototype.hello = function() {   return 'hi!'; };  let obj = g();  obj instanceof g; // true obj.hello(); // 'hi!' ```  但是，如果把 g 当作普通的构造函数，并不会生效，因为 g 返回的总是遍历器对象，而不是 this 对象。Generator 函数也不能跟 new 命令一起用，会报错。   让 Generator 函数返回一个正常的对象实例，既可以用 next 方法，又可以获得正常的 this,下面是一个变通方法。首先，生成一个空对象，使用 call 方法绑定 Generator 函数内部的 this。这样，构造函数调用以后，这个空对象就是 Generator 函数的实例对象了。  ```js function* F() {   this.a = 1;   yield (this.b = 2);   yield (this.c = 3); } var obj = {}; var f = F.call(obj);  f.next(); // Object {value: 2, done: false} f.next(); // Object {value: 3, done: false} f.next(); // Object {value: undefined, done: true}  obj.a; // 1 obj.b; // 2 obj.c; // 3 ```  上面代码中，执行的是遍历器对象 f，但是生成的对象实例是 obj，有没有办法将这两个对象统一呢？一个办法就是将 obj 换成 F.prototype。  ```js function* F() {   this.a = 1;   yield (this.b = 2);   yield (this.c = 3); } var f = F.call(F.prototype);  f.next(); // Object {value: 2, done: false} f.next(); // Object {value: 3, done: false} f.next(); // Object {value: undefined, done: true}  f.a; // 1 f.b; // 2 f.c; // 3 ```  再将 F 改成构造函数，就可以对它执行 new 命令了。  ```js function* gen() {   this.a = 1;   yield (this.b = 2);   yield (this.c = 3); }  function F() {   return gen.call(gen.prototype); }  var f = new F();  f.next(); // Object {value: 2, done: false} f.next(); // Object {value: 3, done: false} f.next(); // Object {value: undefined, done: true}  f.a; // 1 f.b; // 2 f.c; // 3 ```  ## 应用  ### Generator 与状态机  Generator 是实现状态机的最佳结构。比如，下面的 clock 函数就是一个状态机。  ```js var ticking = true; var clock = function() {   if (ticking) console.log('Tick!');   else console.log('Tock!');   ticking = !ticking; }; ```  上面代码的 clock 函数一共有两种状态（Tick 和 Tock），每运行一次，就改变一次状态。这个函数如果用 Generator 实现，就是下面这样。  ```js var clock = function*() {   while (true) {     console.log('Tick!');     yield;     console.log('Tock!');     yield;   } }; ```  ### 异步操作的同步化表达  #### 协程  ##### 概念  协程（coroutine）是一种程序运行的方式，可以理解成“协作的线程”或“协作的函数”。协程既可以用单线程实现，也可以用多线程实现。前者是一种特殊的子例程，后者是一种特殊的线程。  ##### 协程与子例程(单线程)的差异  运行方式:  - 传统的“子例程”（subroutine）采用堆栈式“后进先出”的执行方式，只有当调用的子函数完全执行完毕，才会结束执行父函数。 - 协程与其不同，多个线程（单线程情况下，即多个函数）可以并行执行，但是只有一个线程（或函数）处于正在运行的状态，其他线程（或函数）都处于暂停态（suspended），线程（或函数）之间可以交换执行权。也就是说，一个线程（或函数）执行到一半，可以暂停执行，将执行权交给另一个线程（或函数），等到稍后收回执行权的时候，再恢复执行。这种可以并行执行、交换执行权的线程（或函数），就称为协程。  内存:  - 子例程只使用一个栈（stack）. - 而协程是同时存在多个栈，但只有一个栈是在运行状态，也就是说，协程是以多占用内存为代价，实现多任务的并行。  ##### 协程与普通线程的差异  - 同一时间可以有多个线程处于运行状态，但是运行的协程只能有一个，其他协程都处于暂停状态。 - 此外，普通的线程是抢先式的，到底哪个线程优先得到资源，必须由运行环境决定，但是协程是合作式的，执行权由协程自己分配。  ##### Generator 与协程  由于 JavaScript 是单线程语言，只能保持一个调用栈。引入协程以后，每个任务可以保持自己的调用栈。这样做的最大好处，就是抛出错误的时候，可以找到原始的调用栈。不至于像异步操作的回调函数那样，一旦出错，原始的调用栈早就结束。  Generator 函数是 ES6 对协程的实现，但属于不完全实现。Generator 函数被称为“半协程”（semi-coroutine），意思是只有 Generator 函数的调用者，才能将程序的执行权还给 Generator 函数。如果是完全执行的协程，任何函数都可以让暂停的协程继续执行。  如果将 Generator 函数当作协程，完全可以将多个需要互相协作的任务写成 Generator 函数，它们之间使用 yield 表达式交换控制权。  #### Generator 与上下文  JavaScript 代码运行时，会产生一个全局的上下文环境（context，又称运行环境），包含了当前所有的变量和对象。然后，执行函数（或块级代码）的时候，又会在当前上下文环境的上层，产生一个函数运行的上下文，变成当前（active）的上下文，由此形成一个上下文环境的堆栈（context stack）。  这个堆栈是“后进先出”的数据结构，最后产生的上下文环境首先执行完成，退出堆栈，然后再执行完成它下层的上下文，直至所有代码执行完成，堆栈清空。  Generator 函数不是这样，它执行产生的上下文环境，一旦遇到 yield 命令，就会暂时退出堆栈，但是并不消失，里面的所有变量和对象会冻结在当前状态。等到对它执行 next 命令时，这个上下文环境又会重新加入调用栈，冻结的变量和对象恢复执行。  #### 控制流管理  如果有一个多步操作非常耗时，采用回调函数，可能会写成下面这样。  ```js step1(function(value1) {   step2(value1, function(value2) {     step3(value2, function(value3) {       step4(value3, function(value4) {         // Do something with value4       });     });   }); }); ```  采用 Promise 改写上面的代码。  ```js Promise.resolve(step1)   .then(step2)   .then(step3)   .then(step4)   .then(     function(value4) {       // Do something with value4     },     function(error) {       // Handle any error from step1 through step4     }   )   .done(); ```  Generator 函数可以进一步改善代码运行流程。  ```js let steps = [step1Func, step2Func, step3Func];  function* iterateSteps(steps) {   for (var i = 0; i < steps.length; i++) {     var step = steps[i];     yield step();   } } ```  然后，使用一个函数，按次序自动执行所有步骤。  ```js scheduler(iterateSteps(initialValue));  function scheduler(task) {   var taskObj = task.next(task.value);   // 如果Generator函数未结束，就继续调用   if (!taskObj.done) {     task.value = taskObj.value;     scheduler(task);   } } ```  注意，上面这种做法，只适合同步操作，即所有的 task 都必须是同步的，不能有异步操作。因为这里的代码一得到返回值，就继续往下执行，没有判断异步操作何时完成。  ### 部署 Iterator 接口  利用 Generator 函数，可以在任意对象上部署 Iterator 接口。  ```js function* iterEntries(obj) {   let keys = Object.keys(obj);   for (let i = 0; i < keys.length; i++) {     let key = keys[i];     yield [key, obj[key]];   } }  let myObj = { foo: 3, bar: 7 };  for (let [key, value] of iterEntries(myObj)) {   console.log(key, value); }  // foo 3 // bar 7 ```  ### 作为数据结构  Generator 可以看作是数据结构，更确切地说，可以看作是一个数组结构，因为 Generator 函数可以返回一系列的值，这意味着它可以对任意表达式，提供类似数组的接口。  ```js function* doStuff() {   yield fs.readFile.bind(null, 'hello.txt');   yield fs.readFile.bind(null, 'world.txt');   yield fs.readFile.bind(null, 'and-such.txt'); } ```  上面代码就是依次返回三个函数，但是由于使用了 Generator 函数，导致可以像处理数组那样，处理这三个返回的函数。  ```js for (task of doStuff()) {   // task是一个函数，可以像回调函数那样使用它 } ``` "},{title:"【读书笔记】ES6之Iterator 和 for...of 循环",path:"/posts/%E3%80%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%91ES6%E4%B9%8BIterator-%E5%92%8C-for-of-%E5%BE%AA%E7%8E%AF.html",strippedContent:" ## 何为 Iterator（遍历器）  JavaScript 原有的表示“集合”的数据结构，主要是数组（Array）和对象（Object），ES6 又添加了 Map 和 Set。这样就有了四种数据集合，用户还可以组合使用它们，定义自己的数据结构，比如数组的成员是 Map，Map 的成员是对象。这样就需要一种统一的接口机制，来处理所有不同的数据结构。   遍历器（Iterator）就是这样一种机制。它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。 Iterator 的作用有三个：  - 一是为各种数据结构，提供一个统一的、简便的访问接口； - 二是使得数据结构的成员能够按某种次序排列； - 三是 ES6 创造了一种新的遍历命令 for...of 循环，Iterator 接口主要供 for...of 消费。  Iterator 的遍历过程:  1. 创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。 2. 第一次调用指针对象的 next 方法，可以将指针指向数据结构的第一个成员。 3. 第二次调用指针对象的 next 方法，指针就指向数据结构的第二个成员。 4. 不断调用指针对象的 next 方法，直到它指向数据结构的结束位置。 5. 每一次调用 next 方法，next 方法返回一个对象，表示当前数据成员的信息。这个对象具有 value 和 done 两个属性，value 属性返回当前位置的成员，done 属性是一个布尔值，表示遍历是否结束，即是否还有必要再一次调用 next 方法。  ## 遍历器对象的 return()，throw()  遍历器对象除了具有 next 方法，还可以具有 return 方法和 throw 方法。return 方法和 throw 方法是否部署是可选的。   return 方法的使用场合是，如果 for...of 循环提前退出（通常是因为出错，或者有 break 语句），就会调用 return 方法。如果一个对象在完成遍历前，需要清理或释放资源，就可以部署 return 方法。 注意，return 方法必须返回一个对象，这是 Generator 规格决定的。  ```js function readLinesSync(file) {   return {     [Symbol.iterator]() {       return {         next() {           return { done: false };         },         return() {           file.close();           return { done: true };         }       };     }   }; } ```  下面的两种情况，都会触发执行 return 方法。  ```js // 情况一 for (let line of readLinesSync(fileName)) {   console.log(line);   break; }  // 情况二 for (let line of readLinesSync(fileName)) {   console.log(line);   throw new Error(); } ```  throw 方法主要是配合 Generator 函数使用，一般的遍历器对象用不到这个方法。下一章会讲.  ## 默认 Iterator 接口  Iterator 接口的目的，就是为所有数据结构，提供了一种统一的访问机制，即 for...of 循环。当使用 for...of 循环遍历某种数据结构时，该循环会自动去寻找 Iterator 接口。一种数据结构只要部署了 Iterator 接口，我们就称这种数据结构是“可遍历的”（iterable）。   ES6 规定，默认的 Iterator 接口部署在数据结构的 Symbol.iterator 属性，或者说，一个数据结构只要具有 Symbol.iterator 属性，就可以认为是“可遍历的”（iterable）。Symbol.iterator 属性本身是一个函数，就是当前数据结构默认的遍历器生成函数。执行这个函数，就会返回一个遍历器。至于属性名 Symbol.iterator，它是一个表达式，返回 Symbol 对象的 iterator 属性，这是一个预定义好的、类型为 Symbol 的特殊值，所以要放在方括号内.   ES6 的有些数据结构原生具备 Iterator 接口（比如数组），即不用任何处理，就可以被 for...of 循环遍历。原因在于，这些数据结构原生部署了 Symbol.iterator 属性，另外一些数据结构没有（比如对象）。凡是部署了 Symbol.iterator 属性的数据结构，就称为部署了遍历器接口。调用这个接口，就会返回一个遍历器对象。   原生具备 Iterator 接口的数据结构如下。  - Array - Map - Set - String - TypedArray - 函数的 arguments 对象 - NodeList 对象  ```js let arr = ['a', 'b', 'c']; let iter = arr[Symbol.iterator]();  iter.next(); // { value: 'a', done: false } iter.next(); // { value: 'b', done: false } iter.next(); // { value: 'c', done: false } iter.next(); // { value: undefined, done: true } ```  ## 自定义 Iterator 接口  一个对象如果要具备可被 for...of 循环调用的 Iterator 接口，就必须在 Symbol.iterator 的属性上部署遍历器生成方法（原型链上的对象具有该方法也可）。  ```js class RangeIterator {   constructor(start, stop) {     this.value = start;     this.stop = stop;   }    [Symbol.iterator]() {     return this;   }    next() {     var value = this.value;     if (value < this.stop) {       this.value++;       return { done: false, value: value };     }     return { done: true, value: undefined };   } }  function range(start, stop) {   return new RangeIterator(start, stop); }  for (var value of range(0, 3)) {   console.log(value); // 0, 1, 2 } ```  如果 Symbol.iterator 方法对应的不是遍历器生成函数（即会返回一个遍历器对象），解释引擎将会报错。  ```js var obj = {};  obj[Symbol.iterator] = () => 1;  [...obj]; // TypeError: [] is not a function ```  ## 哪些会调用 Iterator 接口  ### 解构赋值  对数组和 Set 结构进行解构赋值时，会默认调用 Symbol.iterator 方法。  ```js let set = new Set()   .add('a')   .add('b')   .add('c');  let [x, y] = set; // x='a'; y='b'  let [first, ...rest] = set; // first='a'; rest=['b','c']; ```  ### 扩展运算符  扩展运算符内部就调用 Iterator 接口.  ```js // 例一 var str = 'hello'; [...str]; //  ['h','e','l','l','o']  // 例二 let arr = ['b', 'c']; ['a', ...arr, 'd']; // ['a', 'b', 'c', 'd'] ```  ### yield\\*  yield\\*后面跟的是一个可遍历的结构，它会调用该结构的遍历器接口。  ```js let generator = function*() {   yield 1;   yield* [2, 3, 4];   yield 5; };  var iterator = generator();  iterator.next(); // { value: 1, done: false } iterator.next(); // { value: 2, done: false } iterator.next(); // { value: 3, done: false } iterator.next(); // { value: 4, done: false } iterator.next(); // { value: 5, done: false } iterator.next(); // { value: undefined, done: true } ```  ### 任何接受数组作为参数的场合  由于数组的遍历会调用遍历器接口，所以任何接受数组作为参数的场合，其实都调用了遍历器接口。  - for...of - Array.from() - Map(), Set(), WeakMap(), WeakSet()（比如 new Map([['a',1],['b',2]])） - Promise.all() - Promise.race()  ## Iterator 接口与 Generator 函数  Symbol.iterator 方法的最简单实现，还是使用 Generator 函数。  ```js let myIterable = {   [Symbol.iterator]: function* () {     yield 1;     yield 2;     yield 3;   } } [...myIterable] // [1, 2, 3]  // 或者采用下面的简洁写法  let obj = {   * [Symbol.iterator]() {     yield 'hello';     yield 'world';   } };  for (let x of obj) {   console.log(x); } // \"hello\" // \"world\" ```  ## for...of 循环  一个数据结构只要部署了 Symbol.iterator 属性，就被视为具有 iterator 接口，就可以用 for...of 循环遍历它的成员。也就是说，for...of 循环内部调用的是数据结构的 Symbol.iterator 方法。  ### 数组  JavaScript 原有的 for...in 循环，只能获得对象的键名，不能直接获取键值。ES6 提供 for...of 循环，允许遍历获得键值。  ```js var arr = ['a', 'b', 'c', 'd'];  for (let a in arr) {   console.log(a); // 0 1 2 3 }  for (let a of arr) {   console.log(a); // a b c d } ```  for...of 循环调用遍历器接口，数组的遍历器接口只返回具有数字索引的属性。这一点跟 for...in 循环也不一样。  ```js let arr = [3, 5, 7]; arr.foo = 'hello';  for (let i in arr) {   console.log(i); // \"0\", \"1\", \"2\", \"foo\" }  for (let i of arr) {   console.log(i); //  \"3\", \"5\", \"7\" } ```  ### Set 和 Map 结构  ```js var engines = new Set(['Gecko', 'Trident', 'Webkit', 'Webkit']); for (var e of engines) {   console.log(e); } // Gecko // Trident // Webkit  var es6 = new Map(); es6.set('edition', 6); es6.set('committee', 'TC39'); es6.set('standard', 'ECMA-262'); for (var [name, value] of es6) {   console.log(name + ': ' + value); } // edition: 6 // committee: TC39 // standard: ECMA-262 ```  值得注意的地方有两个，首先，遍历的顺序是按照各个成员被添加进数据结构的顺序。其次，Set 结构遍历时，返回的是一个值，而 Map 结构遍历时，返回的是一个数组，该数组的两个成员分别为当前 Map 成员的键名和键值。  ### 类似数组的对象  下面是 for...of 循环用于字符串、DOM NodeList 对象、arguments 对象的例子。  ```js // 字符串 let str = 'hello';  for (let s of str) {   console.log(s); // h e l l o }  // DOM NodeList对象 let paras = document.querySelectorAll('p');  for (let p of paras) {   p.classList.add('test'); }  // arguments对象 function printArgs() {   for (let x of arguments) {     console.log(x);   } } printArgs('a', 'b'); // 'a' // 'b' ```  对于字符串来说，for...of 循环还有一个特点，就是会正确识别 32 位 UTF-16 字符。  ```js for (let x of 'a\\uD83D\\uDC0A') {   console.log(x); } // 'a' // '\\uD83D\\uDC0A' ```  并不是所有类似数组的对象都具有 Iterator 接口，一个简便的解决方法，就是使用 Array.from 方法将其转为数组。  ```js let arrayLike = { length: 2, 0: 'a', 1: 'b' };  // 报错 for (let x of arrayLike) {   console.log(x); }  // 正确 for (let x of Array.from(arrayLike)) {   console.log(x); } ```  ### 对象  对于普通的对象，for...of 结构不能直接使用，会报错，必须部署了 Iterator 接口后才能使用。但是可以用 for...in 循环来遍历键名。   一种解决方法是，使用 Object.keys 方法将对象的键名生成一个数组，然后遍历这个数组。  ```js for (var key of Object.keys(someObject)) {   console.log(key + ': ' + someObject[key]); } ```  另一个方法是使用 Generator 函数将对象重新包装一下。  ```js function* entries(obj) {   for (let key of Object.keys(obj)) {     yield [key, obj[key]];   } }  for (let [key, value] of entries(obj)) {   console.log(key, '->', value); } // a -> 1 // b -> 2 // c -> 3 ```  ### 与其他遍历语法的比较  for 循环写法麻烦,数组的 foeEach 方法不能中途跳出循环,break 命令和 return 命令都不奏效.   for...in 循环有几个缺点。  - 数组的键名是数字，但是 for...in 循环是以字符串作为键名“0”、“1”、“2”等等。 - for...in 循环不仅遍历数字键名，还会遍历手动添加的其他键，甚至包括原型链上的键。 - 某些情况下，for...in 循环会以任意顺序遍历键名。  总之，for...in 循环主要是为遍历对象而设计的，不适用于遍历数组。   for...of 循环相比上面几种做法，有一些显著的优点。  - 有着同 for...in 一样的简洁语法，但是没有 for...in 那些缺点。 - 不同于 forEach 方法，它可以与 break、continue 和 return 配合使用。 - 提供了遍历所有数据结构的统一操作接口。 "},{title:"【读书笔记】ES6之Promise对象",path:"/posts/%E3%80%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%91ES6%E4%B9%8BPromise%E5%AF%B9%E8%B1%A1.html",strippedContent:" ## Promise 基础  ### Promise 简介  Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了 Promise 对象。   从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。  ### Promise 的生命周期  每个 Promise 都会经历一个短暂的生命周期,共三个状态:pending（进行中）、fulfilled（已成功）和 rejected（已失败）。  - 初始为挂起态（pending state），这表示异步操作尚未结束。一旦异步操作结束，Promise 就会被认为是已决的（settled），并进入两种可能状态之一： - 已完成（fulfilled）：Promise 的异步操作已成功结束； - 已拒绝（rejected）：Promise 的异步操作未成功结束，可能是一个错误，或由其他原因导致。  状态的特点:  - 只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。 - 一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise 对象的状态改变，只有两种可能：从 pending 变为 fulfilled 和从 pending 变为 rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对 Promise 对象添加回调函数，也会立即得到这个结果。  ## 创建 pending 的 Promise  新的 Promise 使用 Promise 构造器来创建。此构造器接受单个参数：一个被称为执行器（executor）的函数，包含初始化 Promise 的代码。该执行器会被传递两个名为 resolve()与 reject()的函数作为参数。resolve()函数在执行器成功结束时被调用，用于示意该 Promise 已经准备好被决议（resolved），而 reject()函数则表明执行器的操作已失败。  ``` const promise = new Promise(function(resolve, reject) {   // ... some code    if (/* 异步操作成功 */){     resolve(value);   } else {     reject(error);   } }); ```  - resolve 函数的作用是，将 Promise 对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去； - reject 函数的作用是，将 Promise 对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。  Promise 的执行器会立即执行，早于源代码中在其之后的任何代码。  ``` let promise = new Promise(function(resolve, reject) {   console.log('Promise');   resolve(); });  promise.then(function() {   console.log('resolved.'); });  console.log('Hi!');  // Promise // Hi! // resolved ```  ### resolve()和 reject()的细节  如果调用 resolve 函数和 reject 函数时带有参数，那么它们的参数会被传递给回调函数。reject 函数的参数通常是 Error 对象的实例，表示抛出的错误；resolve 函数的参数除了正常的值以外，还可能是另一个 Promise 实例，  ``` const p1 = new Promise(function (resolve, reject) {   // ... });  const p2 = new Promise(function (resolve, reject) {   // ...   resolve(p1); }) ```  注意，这时 p1 的状态就会传递给 p2，也就是说，p1 的状态决定了 p2 的状态。如果 p1 的状态是 pending，那么 p2 的回调函数就会等待 p1 的状态改变；如果 p1 的状态已经是 resolved 或者 rejected，那么 p2 的回调函数将会立刻执行。  ``` const p1 = new Promise(function (resolve, reject) {   setTimeout(() => reject(new Error('fail')), 3000) })  const p2 = new Promise(function (resolve, reject) {   setTimeout(() => resolve(p1), 1000) })  p2   .then(result => console.log(result))   .catch(error => console.log(error)) // Error: fail ```  上面代码中，p1 是一个 Promise，3 秒之后变为 rejected。p2 的状态在 1 秒之后改变，resolve 方法返回的是 p1。由于 p2 返回的是另一个 Promise，导致 p2 自己的状态无效了，由 p1 的状态决定 p2 的状态。所以，后面的 then 语句都变成针对后者（p1）。又过了 2 秒，p1 变为 rejected，导致触发 catch 方法指定的回调函数。   注意，调用 resolve 或 reject 并不会终结 Promise 的参数函数的执行。  ``` new Promise((resolve, reject) => {   resolve(1);   console.log(2); }).then(r => {   console.log(r); }); // 2 // 1 ```  一般来说，调用 resolve 或 reject 以后，Promise 的使命就完成了，后继操作应该放到 then 方法里面，而不应该直接写在 resolve 或 reject 的后面。所以，最好在它们前面加上 return 语句，这样就不会有意外。  ``` new Promise((resolve, reject) => {   return resolve(1);   // 后面的语句不会执行   console.log(2); }) ```  ### then()的细节  Promise 实例具有 then 方法，也就是说，then 方法是定义在原型对象 Promise.prototype 上的。它的作用是为 Promise 实例添加状态改变时的回调函数。前面说过，then 方法的第一个参数是 resolved 状态的回调函数，第二个参数是 rejected 状态的回调函数。   传递给 then()的两个参数都是可选的，因此你可以监听完成与拒绝的任意组合形式。例如，研究这组 then()调用：  ``` let\tpromise\t=\treadFile(\"example.txt\");  promise.then(function(contents)\t{ \t//\t完成 \tconsole.log(contents); },\tfunction(err)\t{ \t//\t拒绝 \tconsole.error(err.message); });  promise.then(function(contents)\t{ \t//\t完成 \tconsole.log(contents); });  promise.then(null,\tfunction(err)\t{ \t//\t拒绝 \tconsole.error(err.message); }); ```  then 方法返回的是一个新的 Promise 实例（注意，不是原来那个 Promise 实例）。因此可以采用链式写法，即 then 方法后面再调用另一个 then 方法。  ``` getJSON(\"/posts.json\").then(function(json) {   return json.post; }).then(function(post) {   // ... }); ```  这时，前一个回调函数，有可能返回的还是一个 Promise 对象（即有异步操作），这时后一个回调函数，就会等待该 Promise 对象的状态发生变化，才会被调用。  ``` getJSON(\"/post/1.json\").then(function(post) {   return getJSON(post.commentURL); }).then(function funcA(comments) {   console.log(\"resolved: \", comments); }, function funcB(err){   console.log(\"rejected: \", err); }); ```  上面代码中，第一个 then 方法指定的回调函数，返回的是另一个 Promise 对象。这时，第二个 then 方法指定的回调函数，就会等待这个新的 Promise 对象状态发生变化。如果变为 resolved，就调用 funcA，如果状态变为 rejected，就调用 funcB。  ### catch()的细节  Promis 也具有一个 catch()方法，其行为等同于只传递拒绝处理函数给 then()。Promise.prototype.catch 方法是.then(null, rejection)的别名，用于指定发生错误时的回调函数。catch 方法返回的还是一个 Promise 对象，因此后面还可以接着调用 then 方法。  ``` p.then((val) => console.log('fulfilled:', val))   .catch((err) => console.log('rejected', err));  // 等同于 p.then((val) => console.log('fulfilled:', val))   .then(null, (err) => console.log(\"rejected:\", err)); ```  reject 方法的作用，等同于抛出错误。如果 Promise 状态已经变成 resolved，再抛出错误是无效的。  ``` const promise = new Promise(function(resolve, reject) {   resolve('ok');   throw new Error('test'); }); promise   .then(function(value) { console.log(value) })   .catch(function(error) { console.log(error) }); // ok ```  Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个 catch 语句捕获。   一般来说，不要在 then 方法里面定义 Reject 状态的回调函数（即 then 的第二个参数），总是使用 catch 方法。   跟传统的 try/catch 代码块不同的是，如果没有使用 catch 方法指定错误处理的回调函数，Promise 对象抛出的错误不会传递到外层代码，会打印出错误提示，但是不会退出进程、终止脚本执行。  ``` const promise = new Promise(function (resolve, reject) {   resolve('ok');   setTimeout(function () { throw new Error('test') }, 0) }); promise.then(function (value) { console.log(value) }); // ok // Uncaught Error: test ```  上面代码中，Promise 指定在下一轮“事件循环”再抛出错误。到了那个时候，Promise 的运行已经结束了，所以这个错误是在 Promise 函数体外抛出的，会冒泡到最外层，成了未捕获的错误。   catch 方法抛出一个错误，因为后面没有别的 catch 方法了，导致这个错误不会被捕获，也不会传递到外层。  ### finally()的细节  finally 方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。该方法是 ES2018 引入标准的.  ``` promise .then(result => {···}) .catch(error => {···}) .finally(() => {···}); ```  ## 创建已决的 Promise  ### 使用 Promise.resolve()  Promise.resolve()方法接受单个参数并会返回一个处于完成态的 Promise。这意味着没有任何作业调度会发生，并且你需要向 Promise 添加一个或更多的完成处理函数来提取这个参数值。  ``` let\tpromise = Promise.resolve(42); promise.then(function (value) { \tconsole.log(value);\t//\t42 }); ```  需要注意的是，立即 resolve 的 Promise 对象，是在本轮“事件循环”（event loop）的结束时，而不是在下一轮“事件循环”的开始时。  ``` setTimeout(function () {   console.log('three'); }, 0); Promise.resolve().then(function () {   console.log('two'); }); console.log('one'); // one // two // three ```  #### Promise.resolve 方法的参数  1. 参数是一个 Promise 实例,如果参数是 Promise 实例，那么 Promise.resolve 将不做任何修改、原封不动地返回这个实例。 2. 参数是一个 thenable 对象,thenable 对象指的是具有 then 方法的对象,Promise.resolve 方法会将这个对象转为 Promise 对象，然后就立即执行 thenable 对象的 then 方法。  ``` let thenable = {   then: function(resolve, reject) {     resolve(42);   } };  let p1 = Promise.resolve(thenable); p1.then(function(value) {   console.log(value);  // 42 }); ```  3. 参数不是具有 then 方法的对象，或根本就不是对象,如果参数是一个原始值，或者是一个不具有 then 方法的对象，则 Promise.resolve 方法返回一个新的 Promise 对象，状态为 resolved。  ```js const p = Promise.resolve('Hello');  p.then(function(s) {   console.log(s); }); // Hello ```  4. 不带有任何参数,Promise.resolve 方法允许调用时不带参数，直接返回一个 resolved 状态的 Promise 对象  ### 使用 Promise.reject()  Promise.reject(reason)方法也会返回一个新的 Promise 实例，该实例的状态为 rejected。  ```js const p = Promise.reject('出错了'); // 等同于 const p = new Promise((resolve, reject) => reject('出错了'));  p.then(null, function(s) {   console.log(s); }); // 出错了 ```  #### Promise.reject()方法的参数  注意，Promise.reject()方法的参数，会原封不动地作为 reject 的理由，变成后续方法的参数。这一点与 Promise.resolve 方法不一致。  ```js const thenable = {   then(resolve, reject) {     reject('出错了');   } }; Promise.reject(thenable).catch(e => {   console.log(e === thenable); }); // true ```  ## 执行器错误的处理  如果在执行器内部抛出了错误，那么 Promise 的拒绝处理函数就会被调用。例如：  ```js let promise = new Promise(function(resolve, reject) {   throw new Error('Explosion!'); }); promise.catch(function(error) {   console.log(error.message); //\"Explosion!\" }); ```  执行器处理程序捕捉了抛出的任何错误，以简化这种常见处理。但在执行器内抛出的错误仅当存在拒绝处理函数时才会被报告，否则这个错误就会被隐瞒。  ## 响应多个 Promise  ### Promise.all()方法  Promise.all()方法接收单个可迭代对象（如数组）作为参数，并返回一个 Promise。这个可迭代对象的元素都是 Promise，只有在它们都完成后，所返回的 Promise 才会被完成。  ```js // 生成一个Promise对象的数组 const promises = [2, 3, 5, 7, 11, 13].map(function(id) {   return getJSON('/post/' + id + '.json'); });  Promise.all(promises)   .then(function(posts) {     // ...   })   .catch(function(reason) {     // ...   }); ```  p 的状态由 p1、p2、p3 决定，分成两种情况。  1. 只有 p1、p2、p3 的状态都变成 fulfilled，p 的状态才会变成 fulfilled，此时 p1、p2、p3 的返回值组成一个数组，传递给 p 的回调函数。 2. 只要 p1、p2、p3 之中有一个被 rejected，p 的状态就变成 rejected，此时第一个被 reject 的实例的返回值，会传递给 p 的回调函数。  注意，如果作为参数的 Promise 实例，自己定义了 catch 方法，那么它一旦被 rejected，并不会触发 Promise.all()的 catch 方法。  ```js const p1 = new Promise((resolve, reject) => {   resolve('hello'); })   .then(result => result)   .catch(e => e);  const p2 = new Promise((resolve, reject) => {   throw new Error('报错了'); })   .then(result => result)   .catch(e => e);  Promise.all([p1, p2])   .then(result => console.log(result))   .catch(e => console.log(e)); // [\"hello\", Error: 报错了] ```  拒绝处理函数总会接收到单个值，而不是一个数组，该值就是被拒绝的 Promise 所返回的拒绝值。  ### Promise.race()方法  此方法也接受一个包含需监视的 Promise 的可迭代对象，并返回一个新的 Promise，但一旦来源 Promise 中有一个被解决，所返回的 Promise 就会立刻被解决。与等待所有 Promise 完成的 Promise.all()方法不同，在来源 Promise 中任意一个被完成时，Promise.race()方法所返回的 Promise 就能作出响应。  ```js const p = Promise.race([p1, p2, p3]); ```  传递给 Promise.race()的 Promise 确实在进行赛跑，看哪一个首先被解决。若胜出的 Promise 是被完成，则返回的新 Promise 也会被完成；而胜出的 Promise 若是被拒绝，则新 Promise 也会被拒绝。  ## Promise.try()  实际开发中，经常遇到一种情况：不知道或者不想区分，函数 f 是同步函数还是异步操作，但是想用 Promise 来处理它。因为这样就可以不管 f 是否包含异步操作，都用 then 方法指定下一步流程，用 catch 方法处理 f 抛出的错误。一般就会采用下面的写法。  ```js Promise.resolve().then(f); ```  上面的写法有一个缺点，就是如果 f 是同步函数，那么它会在本轮事件循环的末尾执行。  ```js const f = () => console.log('now'); Promise.resolve().then(f); console.log('next'); // next // now ```  使用 new Promise()让同步函数同步执行，异步函数异步执行，并且让它们具有统一的 API.  ```js const f = () => console.log('now'); (() => new Promise(resolve => resolve(f())))(); console.log('next'); // now // next ```  鉴于这是一个很常见的需求，所以现在有一个提案，提供 Promise.try 方法替代上面的写法。  ```js const f = () => console.log('now'); Promise.try(f); console.log('next'); // now // next ```  由于 Promise.try 为所有操作提供了统一的处理机制，所以如果想用 then 方法管理流程，最好都用 Promise.try 包装一下。这样有许多好处，其中一点就是可以更好地管理异常。  ```js function getUsername(userId) {   return database.users.get({ id: userId }).then(function(user) {     return user.name;   }); } ```  database.users.get()可能会抛出同步错误（比如数据库连接错误，具体要看实现方法），这时你就不得不用 try...catch 去捕获。  ```js try {   database.users.get({id: userId})   .then(...)   .catch(...) } catch (e) {   // ... } ```  这时就可以统一用 promise.catch()捕获所有同步和异步的错误。  ```js Promise.try(database.users.get({id: userId}))   .then(...)   .catch(...) ```  ## 应用  ### 加载图片  ```js const preloadImage = function(path) {   return new Promise(function(resolve, reject) {     const image = new Image();     image.onload = resolve;     image.onerror = reject;     image.src = path;   }); }; ```  ### Generator 函数的自动执行器  ```js unction getFoo () {   return new Promise(function (resolve, reject){     resolve('foo');   }); }  const g = function* () {   try {     const foo = yield getFoo();     console.log(foo);   } catch (e) {     console.log(e);   } };  function run (generator) {   const it = generator();    function go(result) {     if (result.done) return result.value;      return result.value.then(function (value) {       return go(it.next(value));     }, function (error) {       return go(it.throw(error));     });   }    go(it.next()); }  run(g); ``` "},{title:"【读书笔记】ES6之对象的扩展",path:"/posts/%E3%80%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%91ES6%E4%B9%8B%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%89%A9%E5%B1%95.html",strippedContent:" ## 对象字面量语法的扩展  ### 属性初始化器的速记法  ES6 允许直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。ES6 允许在对象之中，直接写变量。这时，属性名为变量名, 属性值为变量的值。  ```js const foo = 'bar'; const baz = { foo }; baz; // {foo: \"bar\"}  // 等同于 const baz = { foo: foo }; ```  ```js function f(x, y) {   return { x, y }; }  // 等同于  function f(x, y) {   return { x: x, y: y }; }  f(1, 2); // Object {x: 1, y: 2} ```  ### 方法简写  除了属性简写，方法也可以简写。  ```js const o = {   method() {     return 'Hello!';   } };  // 等同于  const o = {   method: function() {     return 'Hello!';   } }; ```  ```js let birth = '2000/01/01';  const Person = {   name: '张三',    //等同于birth: birth   birth,    // 等同于hello: function ()...   hello() {     console.log('我的名字是', this.name);   } }; ```  CommonJS 模块输出一组变量，就非常合适使用简洁写法。  ```js let ms = {};  function getItem(key) {   return key in ms ? ms[key] : null; }  function setItem(key, value) {   ms[key] = value; }  function clear() {   ms = {}; }  module.exports = { getItem, setItem, clear }; // 等同于 module.exports = {   getItem: getItem,   setItem: setItem,   clear: clear }; ```  如果某个方法的值是一个 Generator 函数，前面需要加上星号。  ```js const obj = {   *m() {     yield 'hello world';   } }; ```  注意，简洁写法的属性名总是字符串，这会导致一些看上去比较奇怪的结果。class 是字符串，所以不会因为它属于关键字，而导致语法解析报错。  ```js const obj = {   class() {} };  // 等同于  var obj = {   class: function() {} }; ```  ### 需计算属性名  但是，如果使用字面量方式定义对象（使用大括号），在 ES5 中只能使用标识符定义属性。  ```js var obj = {   foo: true,   abc: 123 }; ```  ES6 允许字面量定义对象时，用方法二（表达式）作为对象的属性名，即把表达式放在方括号内。  ```js let propKey = 'foo';  let obj = {   [propKey]: true,   ['a' + 'bc']: 123 }; ```  ```js let lastWord = 'last word';  const a = {   'first word': 'hello',   [lastWord]: 'world' };  a['first word']; // \"hello\" a[lastWord]; // \"world\" a['last word']; // \"world\" ```  注意，属性名表达式与简洁表示法，不能同时使用，会报错。  ```js // 报错 const foo = 'bar'; const bar = 'abc'; const baz = { [foo] };  // 正确 const foo = 'bar'; const baz = { [foo]: 'abc'}; ```  注意，属性名表达式如果是一个对象，默认情况下会自动将对象转为字符串[object Object]，这一点要特别小心。  ```js const keyA = { a: 1 }; const keyB = { b: 2 };  const myObject = {   [keyA]: 'valueA',   [keyB]: 'valueB' };  myObject; // Object {[object Object]: \"valueB\"} ```  ## 重复的对象字面量属性  ES5 严格模式为重复的对象字面量属性引入了一个检查，若找到重复的属性名，就会抛出错误。例如，以下代码就有问题。   但 ES6 移除了重复属性的检查，严格模式与非严格模式都不再检查重复的属性。当存在重复属性时，排在后面的属性的值会成为该属性的实际值，如下所示：  ```js 'use strict';  var person = {   name: 'Nicholas',   name: 'Greg' //在ES6严格模式中不会出错 };  console.log(person.name); //\t\"Greg\" ```  ## 属性的可枚举性和遍历  ### 可枚举性  描述对象的 enumerable 属性，称为”可枚举性“，如果该属性为 false，就表示某些操作会忽略当前属性。 目前，有四个操作会忽略 enumerable 为 false 的属性。  - for...in 循环：只遍历对象自身的和继承的可枚举的属性。 - Object.keys()：返回对象自身的所有可枚举的属性的键名。 - JSON.stringify()：只串行化对象自身的可枚举的属性。 - Object.assign()： 忽略 enumerable 为 false 的属性，只拷贝对象自身的可枚举的属性。  ```js Object.getOwnPropertyDescriptor(Object.prototype, 'toString').enumerable; // false  Object.getOwnPropertyDescriptor([], 'length').enumerable; // false ```  ES6 规定，所有 Class 的原型的方法都是不可枚举的。  ```js Object.getOwnPropertyDescriptor(   class {     foo() {}   }.prototype,   'foo' ).enumerable; // false ```  总的来说，操作中引入继承的属性会让问题复杂化，大多数时候，我们只关心对象自身的属性。所以，尽量不要用 for...in 循环，而用 Object.keys()代替。  ### 属性的遍历  ES6 一共有 5 种方法可以遍历对象的属性。  #### for...in  for...in 循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）。  #### Object.keys(obj)  Object.keys 返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名。  #### Object.getOwnPropertyNames(obj)  Object.getOwnPropertyNames 返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名。  #### Object.getOwnPropertySymbols(obj)  Object.getOwnPropertyNames 返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名。  #### Reflect.ownKeys(obj)  Reflect.ownKeys 返回一个数组，包含对象自身的所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举。  ### 自有属性的枚举顺序  - 首先遍历所有数值键，按照数值升序排列。 - 其次遍历所有字符串键，按照加入时间升序排列。 - 最后遍历所有 Symbol 键，按照加入时间升序排列。  ```js Reflect.ownKeys({ [Symbol()]: 0, b: 0, 10: 0, 2: 0, a: 0 }); // ['2', '10', 'b', 'a', Symbol()] ```  ## super 关键字  ES6 又新增了另一个类似的关键字 super，指向当前对象的原型对象。  ```js const proto = {   foo: 'hello' };  const obj = {   foo: 'world',   find() {     return super.foo;   } };  Object.setPrototypeOf(obj, proto); obj.find(); // \"hello ```  注意，super 关键字表示原型对象时，只能用在对象的方法之中，用在其他地方都会报错。  ```js // 报错 const obj = {   foo: super.foo };  // 报错 const obj = {   foo: () => super.foo };  // 报错 const obj = {   foo: function() {     return super.foo;   } }; ```  上面三种 super 的用法都会报错，因为对于 JavaScript 引擎来说，这里的 super 都没有用在对象的方法之中。第一种写法是 super 用在属性里面，第二种和第三种写法是 super 用在一个函数里面，然后赋值给 foo 属性。目前，只有对象方法的简写法可以让 JavaScript 引擎确认，定义的是对象的方法。   super 是指向当前对象的原型的一个指针，实际上就是 Object.getPrototypeOf(this)的值。  ```js const proto = {   x: 'hello',   foo() {     console.log(this.x);   } };  const obj = {   x: 'world',   foo() {     super.foo();   } };  Object.setPrototypeOf(obj, proto);  obj.foo(); // \"world\" ```  ## 正式的“方法”定义  在 ES6 之前，“方法”的概念从未被正式定义，它此前仅指对象的函数属性（而非数据属性）。ES6 则正式做出了定义：方法是一个拥有[[Homeobject]]内部属性的函数，此内部属性指向该方法所属的对象。   任何对 super 的引用都会使用[[Homeobject]]属性来判断要做什么。第一步是在[[Homeobject]]上调用 Object.getPrototypeof（）来获取对原型的引用；接下来，在该原型上查找同名函数；最后，创建 this 绑定并调用该方法。这里有个例子：  ```js let person = {   getGreeting() {     return 'Hello';   } };  //\t原型为\tperson let friend = {   getGreeting() {     return super.getGreeting() + ',\thi!';   } }; Object.setPrototypeOf(friend, person);  console.log(friend.getGreeting()); //\"Hello,\thi!\" ```  调用 friend.getsreeting（）返回了一个字符串，也就是 person.getoreeting（）的返回值与\"，hi！”的合并结果。此时 friend.getGreeting（）的[[Homeobject]]值是 friend，并且 friend 的原型是 person，因此 super.getGreeting（）就等价于 person.getGreeting.call（this）。  ## 对象的新增方法  ES 从 ES5 开始就有一个设计意图：避免创建新的全局函数，避免在 object 对象的原型上添加新方法，而是尝试寻找哪些对象应该被添加新方法。因此，对其他对象不适用的新方法就被添加到全局的 Object 对象上。ES6 在 Object 对象上引入了两个新方法:Object.is()方法和 Object.assign()方法，以便让特定任务更易完成。  ### Object .is()真正的两个值是否相等  ES5 比较两个值是否相等，只有两个运算符：相等运算符（\\=\\=）和严格相等运算符（\\=\\=\\=）。它们都有缺点，前者会自动转换数据类型，后者的 NaN 不等于自身，以及+0 等于-0。JavaScript 缺乏一种运算，在所有环境中，只要两个值是一样的，它们就应该相等。   ES6 提出“Same-value equality”（同值相等）算法，用来解决这个问题。Object.is 就是部署这个算法的新方法。它用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致。  ```js Object.is('foo', 'foo'); // true Object.is({}, {}); // false ```  不同之处只有两个：一是+0 不等于-0，二是 NaN 等于自身。  ```js +0 === -0; //true NaN === NaN; // false  Object.is(+0, -0); // false Object.is(NaN, NaN); // true ```  ES5 可以通过下面的代码，部署 Object .is()。  ```js Object.defineProperty(Object, 'is', {   value: function(x, y) {     if (x === y) {       // 针对+0 不等于 -0的情况       return x !== 0 || 1 / x === 1 / y;     }     // 针对NaN的情况     return x !== x && y !== y;   },   configurable: true,   enumerable: false,   writable: true }); ```  ### Object.assign()用于对象的合并  混入（Mixin）是在 JS 中组合对象时最流行的模式。在一次混入中，一个对象会从另一个对象中接收属性与方法。很多 JS 的库中都有类似下面的混入方法：  ```js function mixin(receiver, supplier) {   Object.keys(supplier).forEach(function(key) {     receiver[key] = supplier[key];   });    return receiver; } ```  Object.assign 方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。  ```js const target = { a: 1 };  const source1 = { b: 2 }; const source2 = { c: 3 };  Object.assign(target, source1, source2); target; // {a:1, b:2, c:3} ```  注意，如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。  ```js const target = { a: 1, b: 1 };  const source1 = { b: 2, c: 2 }; const source2 = { c: 3 };  Object.assign(target, source1, source2); target; // {a:1, b:2, c:3} ```  如果该参数不是对象，则会先转成对象，然后返回。  ```js typeof Object.assign(2); // \"object\" ```  由于 undefined 和 null 无法转成对象，所以如果它们作为参数，就会报错。  ```js Object.assign(undefined); // 报错 Object.assign(null); // 报错 ```  如果非对象参数出现在源对象的位置（即非首参数），那么处理规则有所不同。首先，这些参数都会转成对象，如果无法转成对象，就会跳过。这意味着，如果 undefined 和 null 不在首参数，就不会报错。  ```js let obj = { a: 1 }; Object.assign(obj, undefined) === obj; // true Object.assign(obj, null) === obj; // true ```  属性名为 Symbol 值的属性，也会被 Object.assign 拷贝。  ```js Object.assign({ a: 'b' }, { [Symbol('c')]: 'd' }); // { a: 'b', Symbol(c): 'd' } ```  Object.assign 可以用来处理数组，但是会把数组视为对象。  ```js Object.assign([1, 2, 3], [4, 5]); // [4, 5, 3] ```  取值函数的处理  ```js const source = {   get foo() {     return 1;   } }; const target = {};  Object.assign(target, source); // { foo: 1 } ```  其他类型的值（即数值、字符串和布尔值）不在首参数，也不会报错。但是，除了字符串会以数组形式，拷贝入目标对象，其他值都不会产生效果。  ```js const v1 = 'abc'; const v2 = true; const v3 = 10;  const obj = Object.assign({}, v1, v2, v3); console.log(obj); // { \"0\": \"a\", \"1\": \"b\", \"2\": \"c\" } ```  ```js Object(true); // {[[PrimitiveValue]]: true} Object(10); //  {[[PrimitiveValue]]: 10} Object('abc'); // {0: \"a\", 1: \"b\", 2: \"c\", length: 3, [[PrimitiveValue]]: \"abc\"} ```  上面代码中，布尔值、数值、字符串分别转成对应的包装对象，可以看到它们的原始值都在包装对象的内部属性[[PrimitiveValue]]上面，这个属性是不会被 Object.assign 拷贝的。只有字符串的包装对象，会产生可枚举的实义属性，那些属性则会被拷贝。   Object.assign 拷贝的属性是有限制的，只拷贝源对象的自身属性（不拷贝继承属性），也不拷贝不可枚举的属性（enumerable: false）。  ```js Object.assign(   { b: 'c' },   Object.defineProperty({}, 'invisible', {     enumerable: false,     value: 'hello'   }) ); // { b: 'c' } ```  #### 常见用途  ##### 为对象添加属性  ```js class Point {   constructor(x, y) {     Object.assign(this, { x, y });   } } ```  ##### 为对象添加方法  ```js Object.assign(SomeClass.prototype, {   someMethod(arg1, arg2) {     ···   },   anotherMethod() {     ···   } });  // 等同于下面的写法 SomeClass.prototype.someMethod = function (arg1, arg2) {   ··· }; SomeClass.prototype.anotherMethod = function () {   ··· }; ```  ##### 克隆对象  ```js function clone(origin) {   return Object.assign({}, origin); } ```  不过，采用这种方法克隆，只能克隆原始对象自身的值，不能克隆它继承的值。如果想要保持继承链，可以采用下面的代码。  ```js function clone(origin) {   let originProto = Object.getPrototypeOf(origin);   return Object.assign(Object.create(originProto), origin); } ```  ##### 合并多个对象  将多个对象合并到某个对象。  ```js const merge = (target, ...sources) => Object.assign(target, ...sources); ```  如果希望合并后返回一个新对象，可以改写上面函数，对一个空对象合并。  ```js const merge = (...sources) => Object.assign({}, ...sources); ```  ##### 为属性指定默认值  ```js const DEFAULTS = {   logLevel: 0,   outputFormat: 'html' };  function processContent(options) {   options = Object.assign({}, DEFAULTS, options);   console.log(options);   // ... } ```  注意，由于存在浅拷贝的问题，DEFAULTS 对象和 options 对象的所有属性的值，最好都是简单类型，不要指向另一个对象。否则，DEFAULTS 对象的该属性很可能不起作用。  ```js const DEFAULTS = {   url: {     host: 'example.com',     port: 7070   } };  processContent({ url: { port: 8000 } }); // { //   url: {port: 8000} // } ```  ### Object.getOwnPropertyDescriptors()返回所有自身属性（非继承属性）的描述对象  ES5 的 Object.getOwnPropertyDescriptor()方法会返回某个对象属性的描述对象（descriptor）。ES2017 引入了 Object.getOwnPropertyDescriptors()方法，返回指定对象所有自身属性（非继承属性）的描述对象。  ```js const obj = {   foo: 123,   get bar() {     return 'abc';   } };  Object.getOwnPropertyDescriptors(obj); // { foo: //    { value: 123, //      writable: true, //      enumerable: true, //      configurable: true }, //   bar: //    { get: [Function: get bar], //      set: undefined, //      enumerable: true, //      configurable: true } } ```  模拟一个：  ```js function getOwnPropertyDescriptors(obj) {   const result = {};   for (let key of Reflect.ownKeys(obj)) {     result[key] = Object.getOwnPropertyDescriptor(obj, key);   }   return result; } ```  该方法的引入目的，主要是为了解决 Object.assign()无法正确拷贝 get 属性和 set 属性的问题。  ```js const source = {   set foo(value) {     console.log(value);   } };  const target1 = {}; Object.assign(target1, source);  Object.getOwnPropertyDescriptor(target1, 'foo'); // { value: undefined, //   writable: true, //   enumerable: true, //   configurable: true } ```  上面代码中，source 对象的 foo 属性的值是一个赋值函数，Object.assign 方法将这个属性拷贝给 target1 对象，结果该属性的值变成了 undefined。这是因为 Object.assign 方法总是拷贝一个属性的值，而不会拷贝它背后的赋值方法或取值方法。   这时，Object.getOwnPropertyDescriptors()方法配合 Object.defineProperties()方法，就可以实现正确拷贝。  ```js const source = {   set foo(value) {     console.log(value);   } };  const target2 = {}; Object.defineProperties(target2, Object.getOwnPropertyDescriptors(source)); Object.getOwnPropertyDescriptor(target2, 'foo'); // { get: undefined, //   set: [Function: set foo], //   enumerable: true, //   configurable: true } ```  ### Object.setPrototypeOf()设置对象的原型对象  \\_\\_proto\\_\\_属性（前后各两个下划线），用来读取或设置当前对象的 prototype 对象。目前，所有浏览器（包括 IE11）都部署了这个属性。   该属性没有写入 ES6 的正文，而是写入了附录，原因是\\_\\_proto\\_\\_前后的双下划线，说明它本质上是一个内部属性，而不是一个正式的对外的 API，只是由于浏览器广泛支持，才被加入了 ES6。标准明确规定，只有浏览器必须部署这个属性，其他运行环境不一定需要部署，而且新的代码最好认为这个属性是不存在的。因此，无论从语义的角度，还是从兼容性的角度，都不要使用这个属性，而是使用下面的 Object.setPrototypeOf()（写操作）、Object.getPrototypeOf()（读操作）、Object.create()（生成操作）代替。  Object.setPrototypeOf 方法的作用\\_\\_proto\\_\\_相同，用来设置一个对象的 prototype 对象，返回参数对象本身。它是 ES6 正式推荐的设置原型对象的方法。  ```js // 格式 Object.setPrototypeOf(object, prototype);  // 用法 const o = Object.setPrototypeOf({}, null); let proto = {}; let obj = { x: 10 }; Object.setPrototypeOf(obj, proto);  proto.y = 20; proto.z = 40;  obj.x; // 10 obj.y; // 20 obj.z; // 40 ```  如果第一个参数不是对象，会自动转为对象。但是由于返回的还是第一个参数，所以这个操作不会产生任何效果。  ```js Object.setPrototypeOf(1, {}) === 1; // true Object.setPrototypeOf('foo', {}) === 'foo'; // true Object.setPrototypeOf(true, {}) === true; // true ```  由于 undefined 和 null 无法转为对象，所以如果第一个参数是 undefined 或 null，就会报错。  ### Object.getPrototypeOf()读取对象的原型对象  ```js function Rectangle() {   // ... }  const rec = new Rectangle();  Object.getPrototypeOf(rec) === Rectangle.prototype; // true  Object.setPrototypeOf(rec, Object.prototype); Object.getPrototypeOf(rec) === Rectangle.prototype; // false ```  如果参数不是对象，会被自动转为对象。  ```js // 等同于 Object.getPrototypeOf(Number(1)) Object.getPrototypeOf(1); // Number {[[PrimitiveValue]]: 0}  // 等同于 Object.getPrototypeOf(String('foo')) Object.getPrototypeOf('foo'); // String {length: 0, [[PrimitiveValue]]: \"\"}  // 等同于 Object.getPrototypeOf(Boolean(true)) Object.getPrototypeOf(true); // Boolean {[[PrimitiveValue]]: false}  Object.getPrototypeOf(1) === Number.prototype; // true Object.getPrototypeOf('foo') === String.prototype; // true Object.getPrototypeOf(true) === Boolean.prototype; // true ```  如果参数是 undefined 或 null，它们无法转为对象，所以会报错。  ### Object.keys()返回自身属性的键名的数组  ES5 引入了 Object.keys 方法，返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键名。  ```js var obj = { foo: 'bar', baz: 42 }; Object.keys(obj); // [\"foo\", \"baz\"] ```  ES2017 引入了跟 Object.keys 配套的 Object.values 和 Object.entries，作为遍历一个对象的补充手段，供 for...of 循环使用。  ```js let { keys, values, entries } = Object; let obj = { a: 1, b: 2, c: 3 };  for (let key of keys(obj)) {   console.log(key); // 'a', 'b', 'c' }  for (let value of values(obj)) {   console.log(value); // 1, 2, 3 }  for (let [key, value] of entries(obj)) {   console.log([key, value]); // ['a', 1], ['b', 2], ['c', 3] } ```  ### Object.values()返回自身属性的键值的数组  Object.values 方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值。  ```js const obj = { foo: 'bar', baz: 42 }; Object.values(obj); // [\"bar\", 42] ```  Object.values 只返回对象自身的可遍历属性。  ```js const obj = Object.create({}, { p: { value: 42 } }); Object.values(obj); // [] ```  Object.values 会过滤属性名为 Symbol 值的属性。  ```js Object.values({ [Symbol()]: 123, foo: 'abc' }); // ['abc'] ```  如果 Object.values 方法的参数是一个字符串，会返回各个字符组成的一个数组。  ```js Object.values('foo'); // ['f', 'o', 'o'] ```  如果参数不是对象，Object.values 会先将其转为对象。由于数值和布尔值的包装对象，都不会为实例添加非继承的属性。所以，Object.values 会返回空数组。  ```js Object.values(42); // [] Object.values(true); // [] ```  ### Object.entries()返回自身属性的键值对数组  Object.entries()方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值对数组。  ```js const obj = { foo: 'bar', baz: 42 }; Object.entries(obj); // [ [\"foo\", \"bar\"], [\"baz\", 42] ] ```  ```js let obj = { one: 1, two: 2 }; for (let [k, v] of Object.entries(obj)) {   console.log(`${JSON.stringify(k)}: ${JSON.stringify(v)}`); } // \"one\": 1 // \"two\": 2 ```  Object.entries 方法的另一个用处是，将对象转为真正的 Map 结构。  ```js const obj = { foo: 'bar', baz: 42 }; const map = new Map(Object.entries(obj)); map; // Map { foo: \"bar\", baz: 42 } ```  自己实现 Object.entries 方法，非常简单。  ```js // Generator函数的版本 function* entries(obj) {   for (let key of Object.keys(obj)) {     yield [key, obj[key]];   } }  // 非Generator函数的版本 function entries(obj) {   let arr = [];   for (let key of Object.keys(obj)) {     arr.push([key, obj[key]]);   }   return arr; } ```  ### Object.fromEntries()将键值对数组转为对象  ```js Object.fromEntries([['foo', 'bar'], ['baz', 42]]); // { foo: \"bar\", baz: 42 } ```  该方法的主要目的，是将键值对的数据结构还原为对象，因此特别适合将 Map 结构转为对象。  ```js // 例一 const entries = new Map([['foo', 'bar'], ['baz', 42]]);  Object.fromEntries(entries); // { foo: \"bar\", baz: 42 }  // 例二 const map = new Map().set('foo', true).set('bar', false); Object.fromEntries(map); // { foo: true, bar: false } ```  该方法的一个用处是配合 URLSearchParams 对象，将查询字符串转为对象。  ```js Object.fromEntries(new URLSearchParams('foo=bar&baz=qux')); // { foo: \"bar\", baz: \"qux\" } ```  参考文章[ECMAScript 6 入门](http://es6.ruanyifeng.com/) "},{title:"【读书笔记】ES6之数组的扩展",path:"/posts/%E3%80%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%91ES6%E4%B9%8B%E6%95%B0%E7%BB%84%E7%9A%84%E6%89%A9%E5%B1%95.html",strippedContent:" ## 扩展运算符  扩展运算符（spread）是三个点（...）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。该运算符主要用于函数调用。  ```js console.log(...[1, 2, 3]) // 1 2 3 console.log(1, ...[2, 3, 4], 5) // 1 2 3 4 5 [...document.querySelectorAll('div')] // [<div>, <div>, <div>] ```  ```js function push(array, ...items) {   array.push(...items); }  function add(x, y) {   return x + y; }  const numbers = [4, 38]; add(...numbers); // 42 ```  如果扩展运算符后面是一个空数组，则不产生任何效果。  ```js [...[], 1]; // [1] ```  注意，扩展运算符如果放在括号中，JavaScript 引擎就会认为这是函数调用，否则就会报错。  ```js (...[1,2]) // Uncaught SyntaxError: Unexpected number console.log((...[1,2])) // Uncaught SyntaxError: Unexpected number ```  ### 使用要求  #### 实现了 Iterator 接口的对象  任何 Iterator 接口的对象），都可以用扩展运算符转为真正的数组。  ```js let nodeList = document.querySelectorAll('div'); let array = [...nodeList]; ```  上面代码中，querySelectorAll 方法返回的是一个 nodeList 对象。它不是数组，而是一个类似数组的对象。这时，扩展运算符可以将其转为真正的数组，原因就在于 NodeList 对象实现了 Iterator 。   对于那些没有部署 Iterator 接口的类似数组的对象，扩展运算符就无法将其转为真正的数组。在数组或函数参数中使用展开语法时, 该语法只能用于可迭代对象：  ```js let arrayLike = {   '0': 'a',   '1': 'b',   '2': 'c',   length: 3 };  // TypeError: Cannot spread non-iterable object. let arr = [...arrayLike]; ```  上面代码中，arrayLike 是一个类似数组的对象，但是没有部署 Iterator 接口，扩展运算符就会报错。这时，可以改为使用 Array.from 方法将 arrayLike 转为真正的数组。   扩展运算符内部调用的是数据结构的 Iterator 接口，因此只要具有 Iterator 接口的对象，都可以使用扩展运算符，比如 Map 结构。  ```js let map = new Map([[1, 'one'], [2, 'two'], [3, 'three']]);  let arr = [...map.keys()]; // [1, 2, 3] ```  Generator 函数运行后，返回一个遍历器对象，因此也可以使用扩展运算符。  ```js const go = function*() {   yield 1;   yield 2;   yield 3; };  [...go()]; // [1, 2, 3] ```  #### 构造字面量对象时使用展开语法  不过最新提议对字面量对象增加了展开特性。其行为是, 将已有对象的所有可枚(enumerable)属性拷贝到新构造的对象中.浅拷贝(Shallow-cloning, 不包含 prototype) 和对象合并, 可以使用更简短的展开语法。而不必再使用 Object.assign() 方式. Object.assign() 函数会触发 setters，而展开语法则不会。  ```js var obj1 = { foo: 'bar', x: 42 }; var obj2 = { foo: 'baz', y: 13 };  var clonedObj = { ...obj1 }; // 克隆后的对象: { foo: \"bar\", x: 42 }  var mergedObj = { ...obj1, ...obj2 }; // 合并后的对象: { foo: \"baz\", x: 42, y: 13 } ```  ### 用途  #### 用来替代函数的 apply 方法  由于扩展运算符可以展开数组，所以不再需要 apply 方法，将数组转为函数的参数了。  ```js // ES5 的写法 function f(x, y, z) {   // ... } var args = [0, 1, 2]; f.apply(null, args);  // ES6的写法 function f(x, y, z) {   // ... } let args = [0, 1, 2]; f(...args); ```  ```js // ES5 的写法 Math.max.apply(null, [14, 3, 77]);  // ES6 的写法 Math.max(...[14, 3, 77]);  // 等同于 Math.max(14, 3, 77); ```  #### 数组深拷贝  数组是复合的数据类型，直接复制的话，只是复制了指向底层数据结构的指针，而不是克隆一个全新的数组。ES5 只能用变通方法来复制数组。  ```js const a1 = [1, 2]; const a2 = a1.concat();  a2[0] = 2; a1; // [1, 2] ```  上面代码中，a1 会返回原数组的克隆，再修改 a2 就不会对 a1 产生影响。扩展运算符提供了复制数组的简便写法。  ```js const a1 = [1, 2]; // 写法一 const a2 = [...a1]; // 写法二 const [...a2] = a1; ```  #### 合并数组（浅拷贝）  扩展运算符提供了数组合并的新写法。  ```js const arr1 = ['a', 'b']; const arr2 = ['c']; const arr3 = ['d', 'e'];  // ES5 的合并数组 arr1.concat(arr2, arr3); // [ 'a', 'b', 'c', 'd', 'e' ]  // ES6 的合并数组 [...arr1, ...arr2, ...arr3]; // [ 'a', 'b', 'c', 'd', 'e' ] ```  #### 与解构赋值结合  ```js const [first, ...rest] = [1, 2, 3, 4, 5]; first; // 1 rest; // [2, 3, 4, 5]  const [first, ...rest] = []; first; // undefined rest; // []  const [first, ...rest] = ['foo']; first; // \"foo\" rest; // [] ```  如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。  ```js const [...butLast, last] = [1, 2, 3, 4, 5]; // 报错  const [first, ...middle, last] = [1, 2, 3, 4, 5]; // 报错 ```  #### 将字符串转为数组和正确返回字符串长度  ```js [...'hello']; // [ \"h\", \"e\", \"l\", \"l\", \"o\" ] ```  上面的写法，有一个重要的好处，那就是能够正确识别四个字节的 Unicode 字符。  ```js 'x\\uD83D\\uDE80y'.length // 4 [...'x\\uD83D\\uDE80y'].length // 3 ```  因此，正确返回字符串长度的函数，可以像下面这样写。  ```js function length(str) {   return [...str].length; }  length('x\\uD83D\\uDE80y'); // 3 ```  ## Array.from()将伪数组对象或可遍历对象转换为真数组  Array.from 方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括 ES6 新增的数据结构 Set 和 Map）。  ```js let arrayLike = {   '0': 'a',   '1': 'b',   '2': 'c',   length: 3 };  // ES5的写法 var arr1 = [].slice.call(arrayLike); // ['a', 'b', 'c']  // ES6的写法 let arr2 = Array.from(arrayLike); // ['a', 'b', 'c'] ```  只要是部署了 Iterator 接口的数据结构，Array.from 都能将其转为数组。  ```js Array.from('hello'); // ['h', 'e', 'l', 'l', 'o']  let namesSet = new Set(['a', 'b']); Array.from(namesSet); // ['a', 'b'] ```  如果参数是一个真正的数组，Array.from 会返回一个一模一样的新数组。  ```js Array.from([1, 2, 3]); // [1, 2, 3] ```  Array.from 方法还支持类似数组的对象。所谓类似数组的对象，本质特征只有一点，即必须有 length 属性。因此，任何有 length 属性的对象，都可以通过 Array.from 方法转为数组，而此时扩展运算符就无法转换。  ```js Array.from({ length: 3 }); // [ undefined, undefined, undefined ] ```  Array.from 还可以接受第二个参数，作用类似于数组的 map 方法，用来对每个元素进行处理，将处理后的值放入返回的数组。Array.from 的第三个参数，用来绑定 this。  ```js Array.from(arrayLike, x => x * x); // 等同于 Array.from(arrayLike).map(x => x * x);  Array.from([1, 2, 3], x => x * x); // [1, 4, 9] ```  Array.from()的另一个应用是，将字符串转为数组，然后返回字符串的长度。因为它能正确处理各种 Unicode 字符，可以避免 JavaScript 将大于\\uFFFF 的 Unicode 字符，算作两个字符的 bug。  ```js function countSymbols(string) {   return Array.from(string).length; } ```  ## Array.of() 将一组值转换为数组  ES6 为数组新增创建方法的目的之一，是帮助开发者在使用 Array 构造器时避开 JS 语言的一个怪异点。调用 new Array（）构造器时，根据传入参数的类型与数量的不同，实际上会导致一些不同的结果。  ```js Array.of(3, 11, 8); // [3,11,8] Array.of(3); // [3] Array.of(3).length; // 1 ```  Array.of 总是返回参数值组成的数组。如果没有参数，就返回一个空数组。Array.of 方法可以用下面的代码模拟实现。  ```js function ArrayOf() {   return [].slice.call(arguments); } ```  ## fill()使用给定值填充指定数组  fi11（）方法能使用特定值填充数组中的一个或多个元素。当只使用一个参数的时候，该方法会用该参数的值填充整个数组，例如：  ```js ['a', 'b', 'c'].fill(7); // [7, 7, 7]  new Array(3).fill(7); // [7, 7, 7] ```  fill 方法还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置。  ```js ['a', 'b', 'c'].fill(7, 1, 2); // ['a', 7, 'c'] ```  注意，如果填充的类型为对象，那么被赋值的是同一个内存地址的对象，而不是深拷贝对象。  ```js let arr = new Array(3).fill({ name: 'Mike' }); arr[0].name = 'Ben'; arr; // [{name: \"Ben\"}, {name: \"Ben\"}, {name: \"Ben\"}]  let arr = new Array(3).fill([]); arr[0].push(5); arr; // [[5], [5], [5]] ```  ## copyWithin()将指定位置的成员复制到其他位置  数组实例的 copyWithin 方法，在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。也就是说，使用这个方法，会修改当前数组。   它接受三个参数。  - target（必需）：从该位置开始替换数据。如果为负值，表示倒数。 - start（可选）：从该位置开始读取数据，默认为 0。如果为负值，表示倒数。 - end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数。  这三个参数都应该是数值，如果不是，会自动转为数值。  ```js [1, 2, 3, 4, 5].copyWithin(0, 3) // [4, 5, 3, 4, 5]  // 将3号位复制到0号位 [1, 2, 3, 4, 5].copyWithin(0, 3, 4) // [4, 2, 3, 4, 5]  // -2相当于3号位，-1相当于4号位 [1, 2, 3, 4, 5].copyWithin(0, -2, -1) // [4, 2, 3, 4, 5]  // 将3号位复制到0号位 [].copyWithin.call({length: 5, 3: 1}, 0, 3) // {0: 1, 3: 1, length: 5}  // 将2号位到数组结束，复制到0号位 let i32a = new Int32Array([1, 2, 3, 4, 5]); i32a.copyWithin(0, 2); // Int32Array [3, 4, 5, 4, 5]  // 对于没有部署 TypedArray 的 copyWithin 方法的平台 // 需要采用下面的写法 [].copyWithin.call(new Int32Array([1, 2, 3, 4, 5]), 0, 3, 4); // Int32Array [4, 2, 3, 4, 5] ```  ## find() 和 findIndex()查找返回 true 的元素或下值  数组实例的 find 方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为 true 的成员，然后返回该成员。如果没有符合条件的成员，则返回 undefined。  ```js [1, 4, -5, 10].find(n => n < 0); // -5 ```  ```js [1, 5, 10, 15].find(function(value, index, arr) {   return value > 9; }); // 10 ```  上面代码中，find 方法的回调函数可以接受三个参数，依次为当前的值、当前的位置和原数组。   数组实例的 findIndex 方法的用法与 find 方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。  ```js [1, 5, 10, 15].findIndex(function(value, index, arr) {   return value > 9; }); // 2  function f(v) {   return v > this.age; } let person = { name: 'John', age: 20 }; [10, 12, 26, 15].find(f, person); // 26 ```  另外，这两个方法都可以发现 NaN，弥补了数组的 indexOf 方法的不足。  ```js [NaN]   .indexOf(NaN)   // -1    [NaN].findIndex(y => Object.is(NaN, y)); // 0 ```  ## entries()，keys() 和 values()遍历数组返回可迭代对象  ES6 提供三个新的方法——entries()，keys()和 values()——用于遍历数组。它们都返回一个遍历器对象可以用 for...of 循环进行遍历，唯一的区别是 keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历。  ```js for (let index of ['a', 'b'].keys()) {   console.log(index); } // 0 // 1  for (let elem of ['a', 'b'].values()) {   console.log(elem); } // 'a' // 'b'  for (let [index, elem] of ['a', 'b'].entries()) {   console.log(index, elem); } // 0 \"a\" // 1 \"b\" ```  如果不使用 for...of 循环，可以手动调用遍历器对象的 next 方法，进行遍历。  ```js let letter = ['a', 'b', 'c']; let entries = letter.entries(); console.log(entries.next().value); // [0, 'a'] console.log(entries.next().value); // [1, 'b'] console.log(entries.next().value); // [2, 'c'] ```  ## includes()数组是否包含给定的值  Array.prototype.includes 方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的 includes 方法类似。ES2016 引入了该方法。  ```js [1, 2, 3]   .includes(2) // true   [(1, 2, 3)].includes(4) // false   [(1, 2, NaN)].includes(NaN); // true ```  该方法的第二个参数表示搜索的起始位置，默认为 0。如果第二个参数为负数，则表示倒数的位置，如果这时它大于数组长度（比如第二个参数为-4，但数组长度为 3），则会重置为从 0 开始。  ```js [1, 2, 3].includes(3, 3); // false [1, 2, 3].includes(3, -1); // true ```  indexOf 方法有两个缺点，一是不够语义化，它的含义是找到参数值的第一个出现位置，所以要去比较是否不等于-1，表达起来不够直观。二是，它内部使用严格相等运算符（===）进行判断，这会导致对 NaN 的误判。  ```js [NaN].indexOf(NaN); // -1 ```  下面代码用来检查当前环境是否支持该方法，如果不支持，部署一个简易的替代版本。  ```js const contains = (() =>   Array.prototype.includes     ? (arr, value) => arr.includes(value)     : (arr, value) => arr.some(el => el === value))(); contains(['foo', 'bar'], 'baz'); // => false ```  ## flat()，flatMap()将数组“拉平”  ### flat()  数组的成员有时还是数组，Array.prototype.flat()用于将嵌套的数组“拉平”，变成一维的数组。该方法返回一个新数组，对原数据没有影响。  ```js [1, 2, [3, 4]].flat(); // [1, 2, 3, 4] ```  lat()默认只会“拉平”一层，如果想要“拉平”多层的嵌套数组，可以将 flat()方法的参数写成一个整数，表示想要拉平的层数，默认为 1。  ```js [1, 2, [3, [4, 5]]].flat()[   // [1, 2, 3, [4, 5]]    (1, 2, [3, [4, 5]]) ].flat(2); // [1, 2, 3, 4, 5] ```  如果不管有多少层嵌套，都要转成一维数组，可以用 Infinity 关键字作为参数。  ```js [1, [2, [3]]].flat(Infinity); // [1, 2, 3] ```  如果原数组有空位，flat()方法会跳过空位。  ```js [1, 2, , 4, 5].flat(); // [1, 2, 4, 5] ```  ### flatMap()  flatMap()方法对原数组的每个成员执行一个函数（相当于执行 Array.prototype.map()），然后对返回值组成的数组执行 flat()方法。该方法返回一个新数组，不改变原数组。  ```js // 相当于 [[2, 4], [3, 6], [4, 8]].flat() [2, 3, 4].flatMap(x => [x, x * 2]); // [2, 4, 3, 6, 4, 8] ```  flatMap()只能展开一层数组。  ```js // 相当于 [[[2]], [[4]], [[6]], [[8]]].flat() [1, 2, 3, 4].flatMap(x => [[x * 2]]); // [[2], [4], [6], [8]] ```  flatMap()方法的参数是一个遍历函数，该函数可以接受三个参数，分别是当前数组成员、当前数组成员的位置（从零开始）、原数组。  ```js arr.flatMap(function callback(currentValue[, index[, array]]) {   // ... }[, thisArg]) ```  flatMap()方法还可以有第二个参数，用来绑定遍历函数里面的 this。  ## 数组的空位  数组的空位指，数组的某一个位置没有任何值。比如，Array 构造函数返回的数组都是空位。  ```js Array(3); // [, , ,] ```  注意，空位不是 undefined，一个位置的值等于 undefined，依然是有值的。空位是没有任何值，in 运算符可以说明这一点。  ```js 0 in [undefined, undefined, undefined]; // true 0 in [, , ,]; // false ```  ### ES5  - forEach(), filter(), reduce(), every() 和 some()都会跳过空位。 - map()会跳过空位，但会保留这个值 - join()和 toString()会将空位视为 undefined，而 undefined 和 null 会被处理成空字符串。  ```js // forEach方法 [,'a'].forEach((x,i) => console.log(i)); // 1  // filter方法 ['a',,'b'].filter(x => true) // ['a','b']  // every方法 [,'a'].every(x => x==='a') // true  // reduce方法 [1,,2].reduce((x,y) => x+y) // 3  // some方法 [,'a'].some(x => x !== 'a') // false  // map方法 [,'a'].map(x => 1) // [,1]  // join方法 [,'a',undefined,null].join('#') // \"#a##\"  // toString方法 [,'a',undefined,null].toString() // \",a,,\" ```  ### ES6  明确将空位转为 undefined，Array.from 方法会将数组的空位，转为 undefined，也就是说，这个方法不会忽略空位。  ```js Array.from(['a', , 'b']); // [ \"a\", undefined, \"b\" ] ```  扩展运算符（...）也会将空位转为 undefined  ```js [...['a', , 'b']]; // [ \"a\", undefined, \"b\" ] ```  copyWithin()会连空位一起拷贝。  ``` [,'a','b',,].copyWithin(2,0) // [,\"a\",,\"a\"] ```  fill()会将空位视为正常的数组位置。  ```js new Array(3).fill('a'); // [\"a\",\"a\",\"a\"] ```  for...of 循环也会遍历空位。  ```js let arr = [, ,]; for (let i of arr) {   console.log(1); } // 1 // 1 ```  entries()、keys()、values()、find()和 findIndex()会将空位处理成 undefined。  ```js // entries() [...[,'a'].entries()] // [[0,undefined], [1,\"a\"]]  // keys() [...[,'a'].keys()] // [0,1]  // values() [...[,'a'].values()] // [undefined,\"a\"]  // find() [,'a'].find(x => true) // undefined  // findIndex() [,'a'].findIndex(x => true) // 0 ``` "},{title:"【读书笔记】ES6之函数的扩展",path:"/posts/%E3%80%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%91ES6%E4%B9%8B%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A9%E5%B1%95.html",strippedContent:" ## 函数参数的默认值  ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面。   ES6 之前：  ```js function makeRequest(url, timeout, callback) {   timeout = typeof timeout !== 'undefined' ? timeout : 2000;   callback = typeof callback !== 'undefined' ? callback : function() {};   //\t函数的剩余部分 } ```  ```js //ES6 function log(x, y = 'World') {   console.log(x, y); }  log('Hello'); // Hello World log('Hello', 'China'); // Hello China log('Hello', ''); // Hello ```  参数变量是默认声明的，所以不能用 let 或 const 再次声明。  ```js function foo(x = 5) {   let x = 1; // error   const x = 2; // error } ```  使用参数默认值时，函数不能有同名参数。  ```js // 不报错 function foo(x, x, y) {   // ... }  // 报错 function foo(x, x, y = 1) {   // ... } // SyntaxError: Duplicate parameter name not allowed in this context ```  参数默认值不是传值的，而是每次都重新计算默认值表达式的值。也就是说，参数默认值是惰性求值的。  ```js let x = 99; function foo(p = x + 1) {   console.log(p); }  foo(); // 100  x = 100; foo(); // 101 ```  在函数声明中能指定任意一个参数的默认值，即使该参数排在未指定默认值的参数之前也是可以的。  ```js function makeRequest（ur1，timeout=2000，callback）{ //函数的剩余部分 } //\t使用默认的\ttimeout makeRequest(\"/foo\",\tundefined,\tfunction(body)\t{ \tdoSomething(body); }); //\t使用默认的\ttimeout makeRequest(\"/foo\"); //\t不使用默认值 makeRequest(\"/foo\",\tnull,\tfunction(body)\t{ \tdoSomething(body); }); ```  在本例中，只有在未传递第二个参数、或明确将第二个参数值指定为 undefined 时，timeout 的默认值才会被使用。  ### 与解构赋值默认值结合使用  ```js function foo({ x, y = 5 }) {   console.log(x, y); }  foo({}); // undefined 5 foo({ x: 1 }); // 1 5 foo({ x: 1, y: 2 }); // 1 2 foo(); // TypeError: Cannot read property 'x' of undefined ```  上面代码只使用了对象的解构赋值默认值，没有使用函数参数的默认值。只有当函数 foo 的参数是一个对象时，变量 x 和 y 才会通过解构赋值生成。如果函数 foo 调用时没提供参数，变量 x 和 y 就不会生成，从而报错。通过提供函数参数的默认值，就可以避免这种情况。  ```js function foo({ x, y = 5 } = {}) {   console.log(x, y); } foo(); // undefined 5  function fetch(url, { body = '', method = 'GET', headers = {} }) {   console.log(method); } fetch('http://example.com', {}); // \"GET\" fetch('http://example.com'); // 报错  function fetch(url, { body = '', method = 'GET', headers = {} } = {}) {   console.log(method); } fetch('http://example.com'); // \"GET\" ```  ### 会影响函数的 length 属性  指定了默认值以后，函数的 length 属性，将返回没有指定默认值的参数个数。也就是说，指定了默认值后，length 属性将失真。  ```js (function(a) {}   .length(     // 1     function(a = 5) {}   )   .length(     // 0     function(a, b, c = 5) {}   ).length); // 2 ```  上面代码中，length 属性的返回值，等于函数的参数个数减去指定了默认值的参数个数。比如，上面最后一个函数，定义了 3 个参数，其中有一个参数 c 指定了默认值，因此 length 属性等于 3 减去 1，最后得到 2。   这是因为 length 属性的含义是，该函数预期传入的参数个数。某个参数指定默认值以后，预期传入的参数个数就不包括这个参数了。同理，后文的 rest 参数也不会计入 length 属性。  ```js (function(...args) {}.length); // 0 ```  如果设置了默认值的参数不是尾参数，那么 length 属性也不再计入后面的参数了  ```js (function(a = 0, b, c) {}.length(   // 0   function(a, b = 1, c) {} ).length); // 1 ```  ### 参数默认值的作用域  一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域（context）。等到初始化结束，这个作用域就会消失。这种语法行为，在不设置参数默认值时，是不会出现的。  ```js var x = 1; function f(x, y = x) {   console.log(y); } f(2); // 2 ```  ```js let x = 1;  function f(y = x) {   let x = 2;   console.log(y); }  f(); // 1 ```  参数初始化会在函数被调用时进行，无论是给参数传递了一个值、还是使用了参数的默认值。   上面代码中，函数 f 调用时，参数 y = x 形成一个单独的作用域。这个作用域里面，变量 x 本身没有定义，所以指向外层的全局变量 x。函数调用时，函数体内部的局部变量 x 影响不到默认值变量 x。如果此时，全局变量 x 不存在，就会报错。  ```js var x = 1; function foo(   x,   y = function() {     x = 2;   } ) {   var x = 3;   y();   console.log(x); }  foo(); // 3 x; // 1 ```  上面代码中，函数 foo 的参数形成一个单独作用域。这个作用域里面，首先声明了变量 x，然后声明了变量 y，y 的默认值是一个匿名函数。这个匿名函数内部的变量 x，指向同一个作用域的第一个参数 x。函数 foo 内部又声明了一个内部变量 x，该变量与第一个参数 x 由于不是同一个作用域，所以不是同一个变量，因此执行 y 后，内部变量 x 和外部全局变量 x 的值都没变。   如果将 var x =3 的 var 去除，函数 foo 的内部变量 x 就指向第一个参数 x，与匿名函数内部的 x 是一致的，所以最后输出的就是 2，而外层的全局变量 x 依然不受影响。  ```js var x = 1; function foo(   x,   y = function() {     x = 2;   } ) {   x = 3;   y();   console.log(x); }  foo(); // 2 x; // 1 ```  ### 参数默认值的暂时性死区  与 1et 声明相似，函数每个参数都会创建一个新的标识符绑定，它在初始化之前不允许被访问，否则会抛出错误。参数初始化会在函数被调用时进行，无论是给参数传递了一个值、还是使用了参数的默认值。  ```js function getValue(value) {   return value + 5; } function add(first, second = getValue(first)) {   return first + second; } console.log(add(1, 1)); //\t2 console.log(add(1)); //\t7 ```  调用 add(1, 1)和 add(1)事实上执行了以下代码来创建 first 与 second 的参数值：  ```js //JS调用add(1,1)可表示为 let first = 1; let second = 1; //JS调用add(1)可表示为 let first = 1; let second = getValue(first); ```  改写一下  ```js function add(first = second, second) {   return first + second; }  console.log(add(1, 1)); //\t2 console.log(add(undefined, 1)); //\t抛出错误 ```  本例中调用 add(1, 1) 与 add(undefined, 1) 对应着以下的后台代码：  ``` //\tJS\t调用\tadd(1,\t1)\t可表示为 let\tfirst\t=\t1; let\tsecond\t=\t1;  //\tJS\t调用\tadd(1)\t可表示为 let\tfirst\t=\tsecond; let\tsecond\t=\t1; ```  本例中调用 add（undefined，1）抛出了错误，是因为在 first 被初始化时 second 尚未被初始化。此处的 second 存在于暂时性死区内，对于 second 的引用就抛出了错误。   函数参数拥有各自的作用域和暂时性死区，与函数体的作用域相分离，这意味着参数的默认值不允许访问在函数体内部声明的任意变量。  ### 应用  利用参数默认值，可以指定某一个参数不得省略，如果省略就抛出一个错误。  ```js function throwIfMissing() {   throw new Error('Missing parameter'); } function foo(mustBeProvided = throwIfMissing()) {   return mustBeProvided; } foo(); // Error: Missing parameter ```  ## rest 参数  ES6 引入 rest 参数（形式为...变量名），用于获取函数的多余参数，这样就不需要使用 arguments 对象了。rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。rest 参数就是一个真正的数组，数组特有的方法都可以使用。  ```js function add(...values) {   let sum = 0;   for (var val of values) {     sum += val;   }   return sum; } add(2, 5, 3); // 10 ```  ```js // arguments变量的写法 function sortNumbers() {   return Array.prototype.slice.call(arguments).sort(); } // rest参数的写法 const sortNumbers = (...numbers) => numbers.sort(); ```  ### rest 参数的限制条件  一是函数只能有一个剩余参数，并且它必须被放在最后。  ```js // 报错 function f(a, ...b, c) {   // ... } ```  第二个限制是剩余参数不能在对象字面量的 setter 属性中使用，这意味着如下代码同样会导致语法错误：  ```js 1et object={ //语法错误：不能在setter中使用剩余参数 set name（...value）{ //一些操作 }； ```  存在此限制的原因是：对象字面量的 setter 被限定只能使用单个参数；而剩余参数按照定义是不限制参数数量的，因此它在此处不被许可。   前面有讲函数的 length 属性，不包括 rest 参数。  ```js (function(a) {}   .length(     // 1     function(...a) {}   )   .length(     // 0     function(a, ...b) {}   ).length); // 1 ```  ## 严格模式  从 ES5 开始，函数内部可以设定为严格模式。  ```js function doSomething(a, b) {   'use strict';   // code } ```  ES2016 做了一点修改，规定只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错。  ```js // 报错 function doSomething(a, b = a) {   'use strict';   // code } // 报错 const doSomething = function ({a, b}) {   'use strict';   // code }; // 报错 const doSomething = (...a) => {   'use strict';   // code }; const obj = {   // 报错   doSomething({a, b}) {     'use strict';     // code   } }; ```  这样规定的原因是，函数内部的严格模式，同时适用于函数体和函数参数。但是，函数执行的时候，先执行函数参数，然后再执行函数体。这样就有一个不合理的地方，只有从函数体之中，才能知道参数是否应该以严格模式执行，但是参数却应该先于函数体执行。   把函数包在一个无参数的立即执行函数里面可以规避这种限制。  ```js const doSomething = (function() {   'use strict';   return function(value = 42) {     return value;   }; })(); ```  ## 在代码块中声明函数  在 ES3 或更早版本中，在代码块中声明函数（即块级函数）严格来说应当是一个语法错误，但所有的浏览器却都支持该语法。可惜的是，每个支持该语法的浏览器都有轻微的行为差异，所以最佳实践就是不要在代码块中声明函数（更好的选择是使用函数表达式）。  ### 严格模式下  为了控制这种不兼容行为，ES5 的严格模式为代码块内部的函数声明引入了一个错误。   然而 ES6 会将 doSomething()函数视为块级声明，并允许它在定义所在的代码块内部被访问。块级函数与 let 函数表达式相似，在执行流跳出定义所在的代码块之后，函数定义就会被移除。关键区别在于：块级函数会被提升到所在代码块的顶部；而使用 let 的函数表达式则不会 。  ```js 'use\tstrict'; if (true) {   console.log(typeof doSomething); //\"function\"   function doSomething() {     //\t...   }   doSomething(); } console.log(typeof doSomething); //\t\"undefined ```  ### 非严格模式下  ES6 在非严格模式下同样允许使用块级函数，但行为有细微不同。块级函数的作用域会被提升到所在函数或全局环境的顶部，而不是代码块的顶部。  ```js //\tES6\tbehavior if (true) {   console.log(typeof doSomething); //\"function\"   function doSomething() {     //\t...   }   doSomething(); } console.log(typeof doSomething); //\t\"function\" ```  ## name 属性  函数的 name 属性，返回该函数的函数名。  ```js function foo() {} foo.name; // \"foo\" ```  getter 函数，因此它的名称是 \"get firstName\" ，以标明它的特征；同样，setter 函数也会带有\"set\"的前缀（getter 与 setter 函数都必须用 Object.getOwnPropertyDescriptor()来检索）。另外，使用 bind（）创建的函数会在名称属性值之前带有\"bound”前缀；而使用 Function 构造器创建的函数，其名称属性则会有“anonymous”前缀，如果将一个匿名函数赋值给一个变量，ES5 的 name 属性，会返回空字符串，而 ES6 的 name 属性会返回实际的函数名。  ```js var f = function() {};  // ES5 f.name; // \"\"  // ES6 f.name; // \"f\" ```  ## new.target 元属性  JS 为函数提供了两个不同的内部方法：[[Call]]与[[Construct]]。当函数未使用 new 进行调用时，[[Call]]方法会被执行，运行的是代码中显示的函数体。而当函数使用 new 进行调用时，[[Construct]]方法则会被执行，负责创建一个被称为新目标的新的对象，并且使用该新目标作为 this 去执行函数体。拥有[[Construct]] 方法的函数被称为构造器。记住并不是所有函数都拥有[[Construct]]方法，因此不是所有函数都可以用 new 来调用。  ### 在 ES5 中判断函数如何被调用  在 ES5 中判断函数是不是使用了 new 来调用（即作为构造器），最流行的方式是使用 instanceof，例如：  ```js function\tPerson(name)\t{ \tif\t(this\tinstanceof\tPerson)\t{ \t\t\tthis.name\t=\tname;//\t使用new \t}\telse\t{ \t\t\tthrow\tnew\tError(\"You\tmust\tuse\tnew\twith\tPerson \t} }  var\tperson\t=\tnew\tPerson(\"Nicholas\"); var\tnotAPerson\t=\tPerson(\"Nicholas\");//抛出错误 ```  可惜的是，该方法并不绝对可靠，因为在不使用 new 的情况下 this 仍然可能是 Person 的实例。  ```js var notAPerson = Person.call(person, 'Michael'); //\t奏效了！ ```  ### 在 ES6 中判断函数如何被调用  为了解决这个问题，ES6 引入了 new.target 元属性。元属性指的是“非对象”（例如 new）上的一个属性，并提供关联到它的目标的附加信息。当函数的[[Construct]]方法被调用时，new.target 会被填入 new 运算符的作用目标，该目标通常是新创建的对象实例的构造器，并且会成为函数体内部的 this 值。而若[[Call]]被执行，new.target 的值则会是 undefined。   通过检查 new.target 是否被定义，这个新的元属性就让你能安全地判断函数是否被使用 new 进行了调用。  ```js function\tPerson(name)\t{ \tif\t(typeof new.target\t!==\t\"undefined\")\t{ \t\t\tthis.name\t=\tname;//\t使用new \t}\telse\t{ \t\t\tthrow\tnew\tError(\"You\tmust\tuse\tnew\twith\tPerson \t} } var\tperson\t=\tnew\tPerson(\"Nicholas\"); var\tnotAPerson\t=\tPerson(\"Nicholas\");//抛出错误 ```  警告：在函数之外使用 new.target 会有语法错误。  ## 箭头函数  ES6 允许使用“箭头”（=>）定义函数。但它的行为在很多重要方面与传统的 JS 函数不同：  ### 区别  - 没有 this、super、arguments，也没有 new.target 绑定：this、super、arguments、以及函数内部的 new.target 的值由所在的、最靠近的非箭头函数来决定。 - 不能被使用 new 调用：箭头函数没有[[Construct]]方法，因此不能被用为构造函数，使用 new 调用箭头函数会抛出错误。 - 没有原型：既然不能对箭头函数使用 new，那么它也不需要原型，也就是没有 prototype 属性。 - 不能更改 this：this 的值在函数内部不能被修改，在函数的整个生命周期内其值会保持不变。 - 没有 arguments 对象：既然箭头函数没有 arguments 绑定，你必须依赖于具名参数或剩余参数来访问函数的参数。 - 不允许重复的具名参数：箭头函数不允许拥有重复的具名参数，无论是否在严格模式下；而相对来说，传统函数只有在严格模式下才禁止这种重复。 - 不可以使用 yield 命令，因此箭头函数不能用作 Generator 函数。  ```js var f = () => 5; // 等同于 var f = function() {   return 5; };  var sum = (num1, num2) => num1 + num2; // 等同于 var sum = function(num1, num2) {   return num1 + num2; }; ```  如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用 return 语句返回。  ```js var sum = (num1, num2) => {   return num1 + num2; }; ```  由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号，否则会报错。  ```js // 报错 let getTempItem = id => { id: id, name: \"Temp\" };  // 不报错 let getTempItem = id => ({ id: id, name: \"Temp\" }); ```  下面是一种特殊情况，虽然可以运行，但会得到错误的结果。  ```js let foo = () => {   a: 1; }; foo(); // undefined ```  上面代码中，原始意图是返回一个对象{a:1}，但是由于引擎认为大括号是代码块，所以执行了一行语句 a: 1。这时，a 可以被解释为语句的标签，因此实际执行的语句是 1;，然后函数就结束了，没有返回值。   如果箭头函数只有一行语句，且不需要返回值，可以采用下面的写法，就不用写大括号了。  ```js let fn = () => void doesNotReturn(); ```  this 指向的固定化，并不是因为箭头函数内部有绑定 this 的机制，实际原因是箭头函数根本没有自己的 this，导致内部的 this 就是外层代码块的 this。正是因为它没有 this，所以也就不能用作构造函数。   所以，箭头函数转成 ES5 的代码如下。  ```js // ES6 function foo() {   setTimeout(() => {     console.log('id:', this.id);   }, 100); } // ES5 function foo() {   var _this = this;    setTimeout(function() {     console.log('id:', _this.id);   }, 100); } ```  ### 箭头函数的 this 看外层的是否有函数  如果有，外层函数的 this 就是内部箭头函数的 this。  ```js function Person() {   this.obj = {     showThis: () => {       console.log(this); //person     }   }; } let fun5 = new Person(); fun5.obj.showThis(); ```  如果没有，this 值就会是全局对象（在浏览器中是 window，在 nodejs 中是 global）。  ```js let obj = {   name: 'kobe',   age: 39,   getName: () => {     btn2.onclick = () => {       console.log(this); //window     };   } }; obj.getName(); ```  ### 不适用的场合  由于箭头函数使得 this 从“动态”变成“静态”，下面两个场合不应该使用箭头函数。   第一个场合是定义函数的方法，且该方法内部包括 this。  ```js const cat = {   lives: 9,   jumps: () => {     this.lives--;   } }; ```  第二个场合是需要动态 this 的时候，也不应使用箭头函数。  ```js var button = document.getElementById('press'); button.addEventListener('click', () => {   this.classList.toggle('on'); }); ```  上面代码运行时，点击按钮会报错，因为 button 的监听函数是一个箭头函数，导致里面的 this 就是全局对象。如果改成普通函数，this 就会动态指向被点击的按钮对象。   另外，如果函数体很复杂，有许多行，或者函数内部有大量的读写操作，不单纯是为了计算值，这时也不应该使用箭头函数，而是要使用普通函数，这样可以提高代码可读性。  ## 双冒号运算符  箭头函数可以绑定 this 对象，大大减少了显式绑定 this 对象的写法（call、apply、bind）。但是，箭头函数并不适用于所有场合，所以现在有一个提案，提出了“函数绑定”（function bind）运算符，用来取代 call、apply、bind 调用。   函数绑定运算符是并排的两个冒号（::），双冒号左边是一个对象，右边是一个函数。该运算符会自动将左边的对象，作为上下文环境（即 this 对象），绑定到右边的函数上面。  ```js foo::bar; // 等同于 bar.bind(foo);  foo::bar(...arguments); // 等同于 bar.apply(foo, arguments);  const hasOwnProperty = Object.prototype.hasOwnProperty; function hasOwn(obj, key) {   return obj::hasOwnProperty(key); } ```  如果双冒号左边为空，右边是一个对象的方法，则等于将该方法绑定在该对象上面。  ```js var method = obj::obj.foo; // 等同于 var method = ::obj.foo;  let log = ::console.log; // 等同于 var log = console.log.bind(console); ```  参考文章：[ECMAScript6 入门](http://es6.ruanyifeng.com/#docs/function) "},{title:"【读书笔记】ES6之字符串的扩展",path:"/posts/%E3%80%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%91ES6%E4%B9%8B%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%89%A9%E5%B1%95.html",strippedContent:" ## 更好的 Unicode 表示法  在 ES6 之前，JS 的字符串以 16 位字符编码（UCS-2）为基础。每个 16 位序列都是一个码元（code unit），用于表示一个字符。字符串所有的属性与方法（像是 length 属性与 charAt()方法）都是基于 16 位的码元。当然，16 位曾经足以容纳任何字符，然而由于 Unicode 引入了扩展字符集，这就不再够用了。这种表示法只限于码点在\\u0000~\\uFFFF 之间的字符。超出这个范围的字符，必须用两个双字节的形式表示。  ```js '\\uD842\\uDFB7'; // \"𠮷\"  '\\u20BB7'; // \" 7\" ```  上面代码表示，如果直接在\\u 后面跟上超过 0xFFFF 的数值（比如\\u20BB7），JavaScript 会理解成\\u20BB+7。由于\\u20BB 是一个不可打印字符，所以只会显示一个空格，后面跟着一个 7。   Unicode 的明确目标是给世界上所有的字符提供全局唯一标识符，而 16 位的字符长度限制已不能满足这种需求。这些全球唯一标识符被称为代码点（ code points ），是从 0 开始的简单数字。   在 ES5 中，所有字符串操作都基于 16 位码元，这表示在处理包含代理对的 UTF-16 字符时会出现预期外的结果，就像这个例子：  ```js var text = '𠮷';  console.log(text.length); //\t2 console.log(/^.$/.test(text)); //false console.log(text.charAt(0)); //\t\"\" console.log(text.charAt(1)); //\t\"\" console.log(text.charCodeAt(0)); //\t55362 console.log(text.charCodeAt(1)); //\t57271 ```  - text 的长度属性值是 2，而不是应有的 1。 - 意图匹配单个字符的正则表达式匹配失败了，因为它认为这里有两个字符。 - charAt()方法无法返回一个有效的字符，因为这里每 16 位代码点都不是一个可打印字符。  ES6 对这一点做出了改进，只要将码点放入大括号，就能正确解读该字符。  ```js '\\u{20BB7}'; // \"𠮷\"  '\\u{41}\\u{42}\\u{43}'; // \"ABC\"  let hello = 123; hello; // 123  '\\u{1F680}' === '\\uD83D\\uDE80'; // true ```  ## codePointAt()返回一个字符的码点  JavaScript 内部，字符以 UTF-16 的格式储存，每个字符固定为 2 个字节。对于那些需要 4 个字节储存的字符（Unicode 码点大于 0xFFFF 的字符），JavaScript 会认为它们是两个字符。  ```js var s = '𠮷';  s.length; // 2 s.charAt(0); // '' s.charAt(1); // '' s.charCodeAt(0); // 55362 s.charCodeAt(1); // 57271 ```  上面代码中，汉字“𠮷”（注意，这个字不是“吉祥”的“吉”）的码点是 0x20BB7，UTF-16 编码为 0xD842 0xDFB7（十进制为 55362 57271），需要 4 个字节储存。对于这种 4 个字节的字符，JavaScript 不能正确处理，字符串长度会误判为 2，而且 charAt 方法无法读取整个字符，charCodeAt 方法只能分别返回前两个字节和后两个字节的值。   ES6 提供了 codePointAt 方法，能够正确处理 4 个字节储存的字符，返回一个字符的码点。它可以在给定字符串中按位置提取 Unicode 代码点。该方法接受的是码元位置而非字符位置，并返回一个整数值。  ```js let s = '𠮷a'; s.codePointAt(0); // 134071 s.codePointAt(1); // 57271 s.codePointAt(2); // 97 ```  上面代码中，JavaScript 将“𠮷 a”视为三个字符，codePointAt 方法在第一个字符上，正确地识别了“𠮷”，返回了它的十进制码点 134071（即十六进制的 20BB7）。在第二个字符（即“𠮷”的后两个字节）和第三个字符“a”上，codePointAt 方法的结果与 charCodeAt 方法相同。   codePointAt 方法返回的是码点的十进制值，如果想要十六进制的值，可以使用 toString 方法转换一下。  ```js let s = '𠮷a'; s.codePointAt(0).toString(16); // \"20bb7\" s.codePointAt(2).toString(16); // \"61\" ```  你可能注意到了，codePointAt 方法的参数，仍然是不正确的。比如，上面代码中，字符 a 在字符串 s 的正确位置序号应该是 1，但是必须向 codePointAt 方法传入 2。解决这个问题的一个办法是使用 for...of 循环，因为它会正确识别 32 位的 UTF-16 字符。  ```js let s = '𠮷a'; for (let ch of s) {   console.log(ch.codePointAt(0).toString(16)); } // 20bb7 // 61 ```  判断字符包含了一个还是两个码元，对该字符调用 codePointAt()方法就是最简单的方法。可以照下面的函数这么写：  ```js function is32Bit(c) {   return c.codePointAt(0) > 0xffff; }  is32Bit('𠮷'); // true is32Bit('a'); // false ```  16 位字符的上边界用十六进制表示就是 FFFF，因此任何大于该数字的代码点必须用两个码元（共 32 位）来表示。  ## String.fromCodePoint()从码点返回对应字符  String.fromCharCode 方法，用于从码点返回对应字符，,但是这个方法不能识别 32 位的 UTF-16 字符（Unicode 编号大于 0xFFFF）。例如：  ```js String.fromCharCode(0x20bb7); // \"ஷ\" ```  上面代码中，String.fromCharCode 不能识别大于 0xFFFF 的码点，所以 0x20BB7 就发生了溢出，最高位 2 被舍弃了，最后返回码点 U+0BB7 对应的字符，而不是码点 U+20BB7 对应的字符。   当 ECMAScript 提供了某种方法时，它一般也会给出方法来处理相反的操作。你可以使用 codePointAt()来提取字符串内中某个字符的代码点，也可以借助 String.fromCodePoint()用给定的代码点来产生包含单个字符的字符串。   可以将 String.fromCodePoint()视为 String.fromCharCode()的完善版本。两者处理 BMP 字符时会返回相同结果，只有处理 BMP 范围之外的字符时才会有差异.  ````js String.fromCodePoint(0x20BB7) // \"𠮷\" String.fromCodePoint(0x78, 0x1f680, 0x79) === 'x\\uD83D\\uDE80y' // true ```js 如果String.fromCodePoint方法有多个参数，则它们会被合并成一个字符串返回。 注意，fromCodePoint方法定义在String对象上，而codePointAt方法定义在字符串的实例对象上。 ## 字符串的遍历器接口 ES6 为字符串添加了遍历器接口（详见Iterator），使得字符串可以被for...of循环遍历。 ```js for (let codePoint of 'foo') {   console.log(codePoint) } // \"f\" // \"o\" // \"o\" ````  除了遍历字符串，这个遍历器最大的优点是可以识别大于 0xFFFF 的码点，传统的 for 循环无法识别这样的码点。  ```js let text = String.fromCodePoint(0x20bb7);  for (let i = 0; i < text.length; i++) {   console.log(text[i]); } // \" \" // \" \"  for (let i of text) {   console.log(i); } // \"𠮷\" ```  上面代码中，字符串 text 只有一个字符，但是 for 循环会认为它包含两个字符（都不可打印），而 for...of 循环会正确识别出这一个字符。  ## normalize()标准化字符串  Unicode 另一个有趣之处是，不同的字符在排序或其它一些比较操作中可能会被认为是相同的。有两种方式可以定义这种关联性：第一种是规范相等（canonical equivalence），意味着两个代码点序列在所有方面都被认为是可互换的。例如，两个字符的组合可以按规范等同于另一个字符。第二种关联性是兼容性（compatibility），两个兼容的代码点序列看起来有差别，但在特定条件下可互换使用。   例如，字符\"æ\"与双字符的字符串\"ae\"或许能互换使用，但它们并不严格相等，除非使用某种手段来标准化。  ```js '\\u01D1' === '\\u004F\\u030C'; //false  '\\u01D1'.length; // 1 '\\u004F\\u030C'.length; // 2 ```  ES6 提供字符串实例的 normalize()方法，用来将字符的不同表示方法统一为同样的形式，这称为 Unicode 正规化。  ```js '\\u01D1'.normalize() === '\\u004F\\u030C'.normalize(); // true ```  该方法接受单个可选的字符串参数，用于指示需要使用下列哪种 Unicode 标准形式：  - NFC，默认参数，表示“标准等价合成”（Normalization Form Canonical Composition），返回多个简单字符的合成字符。所谓“标准等价”指的是视觉和语义上的等价。 - NFD，表示“标准等价分解”（Normalization Form Canonical Decomposition），即在标准等价的前提下，返回合成字符分解的多个简单字符。 - NFKC，表示“兼容等价合成”（Normalization Form Compatibility Composition），返回合成字符。所谓“兼容等价”指的是语义上存在等价，但视觉上不等价，比如“囍”和“喜喜”。（这只是用来举例，normalize 方法不能识别中文。） - NFKD，表示“兼容等价分解”（Normalization Form Compatibility Decomposition），即在兼容等价的前提下，返回合成字符分解的多个简单字符。  ```js '\\u004F\\u030C'.normalize('NFC').length; // 1 '\\u004F\\u030C'.normalize('NFD').length; // 2 ```  不过，normalize 方法目前不能识别三个或三个以上字符的合成。这种情况下，还是只能使用正则表达式，通过 Unicode 编号区间判断。   只需记住，当比较字符串时，它们必须被标准化为同一种形式。 如果你之前从未担心过 Unicode 标准化方面的问题，那么可能暂时还不太会用到这个方法。然而若你曾经开发过国际化的应用，你就一定会发现 normalize() 方法非常有用。   将 values 数组中的字符串转换为一种标准形式，以便让转换后的数组可以被正确排序。  ```js values.sort(function(first, second) {   var firstNormalized = first.normalize(),     secondNormalized = second.normalize();    if (firstNormalized < secondNormalized) {     return -1;   } else if (firstNormalized === secondNormalized) {     return 0;   } else {     return 1;   } }); ```  ## includes(), startsWith(), endsWith() 检查字符串是否在另一字符串中  传统上，JavaScript 只有 indexOf 方法，可以用来确定一个字符串是否包含在另一个字符串中。ES6 又提供了三种新方法。  - includes()：返回布尔值，表示是否找到了参数字符串。 - startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。 - endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。  ```js let s = 'Hello world!';  s.startsWith('Hello'); // true s.endsWith('!'); // true s.includes('o'); // true ```  这三个方法都支持第二个参数，表示开始搜索的位置。  ```js let s = 'Hello world!';  s.startsWith('world', 6); // true s.endsWith('Hello', 5); // true s.includes('Hello', 6); // false ```  上面代码表示，使用第二个参数 n 时，endsWith 的行为与其他两个方法有所不同。它针对前 n 个字符，而其他两个方法针对从第 n 个位置直到字符串结束。  ## repeat()将原字符串重复 n 次，返回新字符串  ES6 还为字符串添加了一个 repeat（）方法，它接受一个参数作为字符串的重复次数，返回一个将初始字符串重复指定次数的新字符串。例如：  ```js 'x'.repeat(3); // \"xxx\" 'hello'.repeat(2); // \"hellohello\" 'na'.repeat(0); // \"\" ```  参数如果是小数，会被取整。  ```js 'na'.repeat(2.9); // \"nana\" ```  如果 repeat 的参数是负数或者 Infinity，会报错。  ```js 'na'.repeat(Infinity); // RangeError 'na'.repeat(-1); // RangeError ```  但是，如果参数是 0 到-1 之间的小数，则等同于 0，这是因为会先进行取整运算。0 到-1 之间的小数，取整以后等于-0，repeat 视同为 0。  ```js 'na'.repeat(-0.9); // \"\" ```  参数 NaN 等同于 0。  ```js 'na'.repeat(NaN); // \"\" ```  如果 repeat 的参数是字符串，则会先转换成数字。  ```js 'na'.repeat('na'); // \"\" 'na'.repeat('3'); // \"nanana\" ```  此方法比相同目的的其余方法更加方便，在操纵文本时特别有用，尤其是在需要产生缩进的代码格式化工具中，像这样：  ```js //\tindent\t使用了一定数量的空格 var indent = '\t'.repeat(4),   indentLevel = 0;  //\t每当你增加缩进 var newIndent = indent.repeat(++indentLevel); ```  第一次调用 repeat（）创建了一个包含四个空格的字符串，而 indentLeve1 变量会持续追踪缩进的级别。此后，你可以仅通过增加 indentLeve1 的值来调用 repeat（）方法，便可以改变空格数量。  ## padStart()，padEnd() 字符串补全长度  ES2017 引入了字符串补全长度的功能。如果某个字符串不够指定长度，会在头部或尾部补全。padStart()用于头部补全，padEnd()用于尾部补全。  ```js 'x'.padStart(5, 'ab'); // 'ababx' 'x'.padStart(4, 'ab'); // 'abax'  'x'.padEnd(5, 'ab'); // 'xabab' 'x'.padEnd(4, 'ab'); // 'xaba' ```  如果原字符串的长度，等于或大于指定的目标长度，则返回原字符串。  ```js 'xxx'.padStart(2, 'ab'); // 'xxx' 'xxx'.padEnd(2, 'ab'); // 'xxx' ```  如果用来补全的字符串与原字符串，两者的长度之和超过了指定的目标长度，则会截去超出位数的补全字符串。  ```js 'abc'.padStart(10, '0123456789'); // '0123456abc' ```  如果省略第二个参数，默认使用空格补全长度。  ```js 'x'.padStart(4); // '   x' 'x'.padEnd(4); // 'x   ' ```  padStart()的常见用途是为数值补全指定位数。下面代码生成 10 位的数值字符串。  ```js '1'.padStart(10, '0'); // \"0000000001\" '12'.padStart(10, '0'); // \"0000000012\" '123456'.padStart(10, '0'); // \"0000123456\" ```  另一个用途是提示字符串格式。  ```js '12'.padStart(10, 'YYYY-MM-DD'); // \"YYYY-MM-12\" '09-12'.padStart(10, 'YYYY-MM-DD'); // \"YYYY-09-12\" ```  ## 模板字符串  模板字符串（template string）是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。   实际上，模板字面量是 ES6 针对 JS 直到 ES5 依然完全缺失的如下功能的回应：  - 多行字符串：针对多行字符串的形式概念； - 基本的字符串格式化：将字符串部分替换为已存在的变量值的能力； - HTML 转义：能转换字符串以便将其安全插入到 HTML 中的能力。  ```js // 普通字符串 `In JavaScript '\\n' is a line-feed.`// 多行字符串 `In JavaScript this is  not legal.`;  console.log(`string text line 1 string text line 2`);  // 字符串中嵌入变量 let name = 'Bob',   time = 'today'; `Hello ${name}, how are you ${time}?`; ```  上面代码中的模板字符串，都是用反引号表示。如果在模板字符串中需要使用反引号，则前面要用反斜杠转义。  ```js let greeting = `\\`Yo\\` World!`; ```  如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中。  ```js //ES6之前的权宜之计 var message =   'Multiline\t\\ string'; console.log(message); /*message字符串打印输出时不会有换行， 因为反斜线被视为续延符号而不是新行的符号。 为了在输出中显示换行，你需要手动包含它：*/ var message =   'Multiline\t\\n\\ string';  console.log(message); //\t\"Multiline //\t\tstring\" //模板字符串 //\t\"Multiline\tstring\" $('#list').html(   ` <ul>   <li>first</li>   <li>second</li> </ul> `.trim() ); let a = ` <ul>   <li>first</li>   <li>second</li> </ul> `.trim(); /*此代码从第一行开始创建模板字面量， 但在第二行之前并没有包含任何文本。 HTML标签的缩进增强了可读性， 之后再调用trim（）方法移除了起始的空行。 */ ```  模板字符串中嵌入变量，需要将变量名写在\\${}之中。  ```js function authorize(user, action) {   if (!user.hasPrivilege(action)) {     throw new Error(       // 传统写法为       // 'User '       // + user.name       // + ' is not authorized to do '       // + action       // + '.'       `User ${user.name} is not authorized to do ${action}.`     );   } } ```  大括号内部可以放入任意的 JavaScript 表达式，可以进行运算，以及引用对象属性。  ```js let x = 1; let y = 2;  `${x} + ${y} = ${x + y}`// \"1 + 2 = 3\"  `${x} + ${y * 2} = ${x + y * 2}`; // \"1 + 4 = 5\"  let obj = { x: 1, y: 2 }; `${obj.x + obj.y}`; // \"3\" ```  模板字符串之中还能调用函数。  ```js function fn() {   return 'Hello World'; }  `foo ${fn()} bar`; // foo Hello World bar ```  如果大括号中的值不是字符串，将按照一般的规则转为字符串。比如，大括号中是一个对象，将默认调用对象的 toString 方法。   如果模板字符串中的变量没有声明，将报错。  ```js // 变量place没有声明 let msg = `Hello, ${place}`; // 报错 ```  模板字符串甚至还能嵌套。  ```js const tmpl = addrs => `   <table>   ${addrs     .map(       addr => `     <tr><td>${addr.first}</td></tr>     <tr><td>${addr.last}</td></tr>   `     )     .join('')}   </table> `;  const data = [   { first: '<Jane>', last: 'Bond' },   { first: 'Lars', last: '<Croft>' } ];  console.log(tmpl(data)); // <table> // //   <tr><td><Jane></td></tr> //   <tr><td>Bond</td></tr> // //   <tr><td>Lars</td></tr> //   <tr><td><Croft></td></tr> // // </table> ```  如果需要引用模板字符串本身，在需要时执行，可以像下面这样写。  ```js // 写法一 let str = 'return ' + '`Hello ${name}!`'; let func = new Function('name', str); func('Jack'); // \"Hello Jack!\"  // 写法二 let str = '(name) => `Hello ${name}!`'; let func = eval.call(null, str); func('Jack'); // \"Hello Jack!\" ```  ## 标签化模板,函数调用的一种特殊形式  模板字面量真正的力量来源于标签化模板。一个模板标签（template tag）能对模板字面量进行转换并返回最终的字符串值，标签在模板的起始处被指定，即在第一个之前，如下所示：  ```js let message = tag`Hello\tworld`;  alert`123`; // 等同于 alert(123); ```  标签模板其实不是模板，而是函数调用的一种特殊形式。“标签”指的就是函数，紧跟在后面的模板字符串就是它的参数。   但是，如果模板字符里面有变量，就不是简单的调用了，而是会将模板字符串先处理成多个参数，再调用函数。  ```js let a = 5; let b = 10;  tag`Hello ${a + b} world ${a * b}`; // 等同于 tag(['Hello ', ' world ', ''], 15, 50); ```  一个标签（tag）仅是一个函数，它被调用时接收需要处理的模板字面量数据。标签所接收的数据被划分为独立片段，并且必须将它们组合起来以创建结果。第一个参数是个数组，包含被 JS 解释过的字面量字符串，随后的参数是每个替换位的解释值。   标签函数的参数一般定义为剩余参数形式，以便更容易处理数据，如下：  ```js function tag(stringArr, value1, value2) {   // ... }  // 等同于  function tag(stringArr, ...values) {   // ... } ```  “标签模板”的一个重要应用，就是过滤 HTML 字符串，防止用户输入恶意内容。  ```js let message = SaferHTML`<p>${sender} has sent you a message.</p>`;  function SaferHTML(templateData) {   let s = templateData[0];   for (let i = 1; i < arguments.length; i++) {     let arg = String(arguments[i]);      // Escape special characters in the substitution.     s += arg       .replace(/&/g, '&amp;')       .replace(/</g, '&lt;')       .replace(/>/g, '&gt;');      // Don't escape special characters in the template.     s += templateData[i];   }   return s; } ```  上面代码中，sender 变量往往是用户提供的，经过 SaferHTML 函数处理，里面的特殊字符都会被转义。  ```js let sender = '<script>alert(\"abc\")<\/script>'; // 恶意代码 let message = SaferHTML`<p>${sender} has sent you a message.</p>`;  message; // <p>&lt;script&gt;alert(\"abc\")&lt;/script&gt; has sent you a message.</p> ```  标签模板的另一个应用，就是多语言转换（国际化处理）。  ```js i18n`Welcome to ${siteName}, you are visitor number ${visitorNumber}!`; // \"欢迎访问xxx，您是第xxxx位访问者！\" ```  除此之外，你甚至可以使用标签模板，在 JavaScript 语言之中嵌入其他语言。  ```js jsx`   <div>     <input       ref='input'       onChange='${this.handleChange}'       defaultValue='${this.state.value}' />       ${this.state.value}    </div> `; ```  上面的代码通过 jsx 函数，将一个 DOM 字符串转为 React 对象。你可以在 Github 找到 jsx 函数的具体实现。  ## String.raw()返回模板字面量中的原始值  String.raw 方法，往往用来充当模板字符串的处理函数，返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串，对应于替换变量后的模板字符串。  ```js String.raw`Hi\\n${2 + 3}!`; // 返回 \"Hi\\\\n5!\"  String.raw`Hi\\u000A!`; // 返回 \"Hi\\\\u000A!\" ```  如果原字符串的斜杠已经转义，那么 String.raw 会进行再次转义。  ```js String.raw`Hi\\\\n`; // 返回 \"Hi\\\\\\\\n\" ```  String.raw 方法也可以作为正常的函数使用。这时，它的第一个参数，应该是一个具有 raw 属性的对象，且 raw 属性的值应该是一个数组。  ```js String.raw({ raw: 'test' }, 0, 1, 2); // 't0e1s2t'  // 等同于 String.raw({ raw: ['t', 'e', 's', 't'] }, 0, 1, 2); ```  为函数，String.raw 的代码实现基本如下。  ```js String.raw = function(strings, ...values) {   let output = '';   let index;   for (index = 0; index < values.length; index++) {     output += strings.raw[index] + values[index];   }    output += strings.raw[index];   return output; }; ``` "},{title:"【读书笔记】ES6之解构赋值",path:"/posts/%E3%80%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%91ES6%E4%B9%8B%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC.html",strippedContent:" ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。  ## 谁可以解构  数组可以用数组解构，对于 Set 结构，也可以使用数组的解构赋值。   解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。  ```js let [x, y, z] = new Set(['a', 'b', 'c']); x; // \"a\" ```  事实上，只要某种数据结构具有 Iterator 接口，都可以采用数组形式的解构赋值。  ```js function* fibs() {   let a = 0;   let b = 1;   while (true) {     yield a;     [a, b] = [b, a + b];   } }  let [first, second, third, fourth, fifth, sixth] = fibs(); sixth; // 5 ```  上面代码中，fibs 是一个 Generator 函数（参见 Generator 函数），原生具有 Iterator 接口。解构赋值会依次从这个接口获取值。 上面的语句都会报错，因为等号右边的值，要么转为对象以后不具备 Iterator 接口（前五个表达式），要么本身就不具备 Iterator 接口（最后一个表达式）。   当解构赋值表达式的右侧（=后面的表达式）的计算结果为 null 或 undefined 时，会抛出错误。因为任何读取 null 或 undefined 的企图都会导致“运行时”错误（runtime error）。  ## 解构缺少初始化报错  当使用解构来配合 var 、let 或 const 来声明变量时，必须提供初始化器（即等号右边的值）。下面的代码都会因为缺失初始化器而抛出错误：  ```js //\t语法错误！ var\t{type,name}; //\t语法错误！ let\t{type,name}; //\t语法错误！ const {type,name}; ```  与对象解构相似，在使用 var 、let 、const 进行数组解构时，你必须提供初始化器。  ## 已声明变量用于解构赋值  ### 对象  ```js // 错误的写法 let x; {x} = {x: 1}; // SyntaxError: syntax error ```  上面代码的写法会报错，因为 JavaScript 引擎会将{x}理解成一个代码块，从而发生语法错误。只有不将大括号写在行首，避免 JavaScript 将其解释为代码块，才能解决这个问题。  ```js // 正确的写法 let x; ({ x } = { x: 1 }); ```  ### 数组  你可以在赋值表达式中使用数组解构，但是与对象解构不同，不必将表达式包含在圆括号内，例如：  ```js let\tcolors=[\"red\",\"green\",\"blue\"\t], let\tfirstColor\t=\t\"black\", let\tsecondColor\t=\t\"purple\"; [firstColor,secondColor\t]\t=\tcolors; console.log(firstColor);//\t\"red\" console.log(secondColor);//\t\"green\" ```  ## 解构赋值表达式的值  解构赋值表达式的值为表达式右侧（在 = 之后）的值。也就是说在任何期望有个值的位置都可以使用解构赋值表达式。例如，传递值给函数：  ```js let\tnode={type:\t\"Identifier\",name:\t\"foo\"}, let type = \"Literal\", let name = 5; function\toutputInfo(value)\t{ \tconsole.log(value\t===\tnode);\t//\ttrue }  outputInfo({type,name}=node);  console.log(type);//\t\"Identifier\" console.log(name);//\t\"foo\" ```  ## 数组的解构赋值  ### 数组解构赋值表达式的右值报错  如果等号的右边不是数组（或者严格地说，不是可遍历的结构，参见 Iterator），那么将会报错。   如果左边是用{}来解构，会把右值转为对象，除了 null 和 undefined 以外都不会报错。  ```js // 报错 let [foo] = 1; let [foo] = false; let [foo] = NaN; let [foo] = undefined; let [foo] = null; let [foo] = {}; ```  ### 一维数组的解构  ```js let [a, b, c] = [1, 2, 3]; ```  上面代码表示，可以从数组中提取值，按照对应位置，对变量赋值。  ### 嵌套数组的解构  ```js let [firstColor, [secondColor]] = ['red', ['green', 'lightgreen'], 'blue']; console.log(firstColor); //\t\"red\" console.log(secondColor); //\t\"green\"  let [foo, [[bar], baz]] = [1, [[2], 3]]; foo; // 1 bar; // 2 baz; // 3 ```  ### 不完全解构  ```js let [, , third] = ['foo', 'bar', 'baz']; third; // \"baz\"  let [x, , y] = [1, 2, 3]; x; // 1 y; // 3  let [a, [b], d] = [1, [2, 3], 4]; a; // 1 b; // 2 d; // 4  let [, firstColor, [secondColor]] = ['red', 'blue', ['green', 'lightgreen']]; firstColor; //blue secondColor; //[\"green\",\"lightgreen\"] ```  ### 解构不成功  当指定位置的项不存在、或其值为 undefined ，则解构不成功，变量的值就等于 undefined。  ```js let [foo] = []; let [bar, foo] = [1]; ```  ### 默认值  当指定位置的项解构不成功时，那么该默认值就会被使用。   注意，ES6 内部使用严格相等运算符（===），判断一个位置是否有值。所以，只有当一个数组成员严格等于 undefined，默认值才会生效。   如果一个数组成员是 null，默认值就不会生效，因为 null 不严格等于 undefined。  ```js let colors = ['red']; let [firstColor, secondColor = 'green'] = colors; console.log(firstColor); //\"red\" console.log(secondColor); //\t\"green\"  let [foo = true] = []; foo; // true ```  如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候，才会求值。  ```js function f() {   console.log('aaa'); }  let [x = f()] = [1]; ```  上面代码中，因为 x 能取到值，所以函数 f 根本不会执行。上面的代码其实等价于下面的代码。   默认值可以引用解构赋值的其他变量，但该变量必须已经声明。  ```js let [x = 1, y = x] = []; // x=1; y=1 let [x = 1, y = x] = [2]; // x=2; y=2 let [x = 1, y = x] = [1, 2]; // x=1; y=2 let [x = y, y = 1] = []; // ReferenceError: y is not defined ```  ### 剩余项解构  数组解构有个类似的、名为剩余项（ rest items ）的概念，它使用...语法来将剩余的项目赋值给一个指定的变量。  ```js let [head, ...tail] = [1, 2, 3, 4]; head; // 1 tail; // [2, 3, 4] ```  但它还有另一个有用的功能。方便地克隆数组在 JS 中是个明显被遗漏的功能。在 ES5 中开发者往往使用的是一个简单的方式，也就是用 concat() 方法来克隆数组。  ```js var colors = ['red', 'green', 'blue']; var clonedColors = colors.concat(); console.log(clonedColors); //\"[red,green,blue]\" ```  而在 ES6 中，你可以使用剩余项的语法来达到同样效果。实现如下：  ```js let colors = ['red', 'green', 'blue']; let [...clonedColors] = colors; console.log(clonedColors); //\"[red,green,blue]\" ```  注意！剩余项必须是数组解构模式中最后的部分，之后不能再有逗号，否则就是语法错误。  ## 对象的解构赋值  解构不仅可以用于数组，还可以用于对象。对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。   对象的解构赋值的解构和数组的差不多，只是[]换为了{}，嵌套对象多了个：，还有对象不在乎属性的顺序，所以对象的不完全解构是不必要像数组那样的，想要哪个属性直接写属性名就行了，同时还多了个别名的设置。  ```js //普通对象的解构 let { foo, bar } = { foo: 'aaa', bar: 'bbb' }; foo; // \"aaa\" bar; // \"bbb\"  //嵌套对象的解构 let obj = {   p: ['Hello', { y: 'World' }] }; let {   p: [x, { y }] } = obj; //注意，这时p是模式，不是变量，因此不会被赋值。 //如果p也要作为变量赋值，可以写成下 //let { p, p: [x, { y }] } = obj; x; // \"Hello\" y; // \"World\" //另一个例子 const node = {   loc: {     start: {       line: 1,       column: 5     }   } }; let {   loc,   loc: { start },   loc: {     start: { line }   } } = node; line; // 1 loc; // Object {start: Object} start; // Object {line: 1, column: 5} //注意，最后一次对line属性的解构赋值之中，只有line是变量，loc和start都是模式，不是变量。  //默认值 var { x = 3 } = {}; x; // 3 var { x, y = 5 } = { x: 1 }; x; // 1 y; // 5 //默认值生效的条件是，对象的属性值严格等于undefined var { x = 3 } = { x: undefined }; x; // 3 var { x = 3 } = { x: null }; x; // null  //解构不成功，变量的值等于undefined。 let { foo } = { bar: 'baz' }; foo; // undefined // foo这时等于undefined，再取子属性就会报错 let {   foo: { bar } } = { baz: 'baz' };  //由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构。 let arr = [1, 2, 3]; let { 0: first, [arr.length - 1]: last } = arr; first; // 1 last; // 3 //length属性 let { length: len } = [1, 2, 3]; len; //3 ```  ### 设置别名  ES6 有一个扩展语法，允许你在给本地变量赋值时使用一个不同的名称。  ```js let { foo: baz } = { foo: 'aaa', bar: 'bbb' }; baz; // \"aaa\"  let obj = { first: 'hello', last: 'world' }; let { first: f, last: l } = obj; f; // 'hello' l; // 'world' ```  ## 字符串的解构赋值  字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。  ```js const [a, b, c, d, e] = 'hello'; a; // \"h\" b; // \"e\" c; // \"l\" d; // \"l\" e; // \"o\" ```  类似数组的对象都有一个 length 属性，因此还可以对这个属性解构赋值。  ```js let { length: len } = 'hello'; len; // 5 ```  ## 数值和布尔值的解构赋值  解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。  ```js let {toString: s} = 123; s === Number.prototype.toString // true  let {toString: s} = true; s === Boolean.prototype.toString // true  let {toString} = NaN； toString === Number.prototype.toString//true ```  ## 函数参数的解构赋值  函数的参数也可以使用解构赋值。  ```js function add([x, y]) {   return x + y; }  add([1, 2]); // 3 ```  上面代码中，函数 add 的参数表面上是一个数组，但在传入参数的那一刻，数组参数就被解构成变量 x 和 y。对于函数内部的代码来说，它们能感受到的参数就是 x 和 y。   函数参数的解构也可以使用默认值。  ```js function move({ x = 0, y = 0 } = {}) {   return [x, y]; }  move({ x: 3, y: 8 }); // [3, 8] move({ x: 3 }); // [3, 0] move({}); // [0, 0] move(); // [0, 0] ```  上面代码中，函数 move 的参数是一个对象，通过对这个对象进行解构，得到变量 x 和 y 的值。如果解构失败，x 和 y 等于默认值。当 JS 的函数接收大量可选参数时，一个常用模式是创建一个 options 对象，其中包含了附加的参数。  ```js function move({ x, y } = { x: 0, y: 0 }) {   return [x, y]; }  move({ x: 3, y: 8 }); // [3, 8] move({ x: 3 }); // [3, undefined] move({}); // [undefined, undefined] move(); // [0, 0] ```  js 会先把实参传进形参的右值，代替左值，如果没传，默认用形参的右值。   undefined 就会触发函数参数的默认值。  ```js [1, undefined, 3].map((x = 'yes') => x); // [ 1, 'yes', 3 ] ```  ## 用途  ### 交换变量的值  ```js let x = 1; let y = 2;  [x, y] = [y, x]; ```  ### 取出从函数返回的值  函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。有了解构赋值，取出这些值就非常方便。  ```js // 返回一个数组  function example() {   return [1, 2, 3]; } let [a, b, c] = example();  // 返回一个对象  function example() {   return {     foo: 1,     bar: 2   }; } let { foo, bar } = example(); ```  ### 函数无次序参数的传入  解构赋值可以方便地将一组参数与变量名对应起来。  ```js // 参数是一组无次序的值 function f({x, y, z}) { ... } f({z: 3, y: 2, x: 1}); ```  ### 提取 JSON 数据  ```js let jsonData = {   id: 42,   status: 'OK',   data: [867, 5309] };  let { id, status, data: number } = jsonData;  console.log(id, status, number); // 42, \"OK\", [867, 5309] ```  ### 函数参数的默认值  ```js jQuery.ajax = function(   url,   {     async = true,     beforeSend = function() {},     cache = true,     complete = function() {},     crossDomain = false,     global = true     // ... more config   } = {} ) {   // ... do stuff }; ```  指定参数的默认值，就避免了在函数体内部再写 var foo = config.foo || 'default foo';这样的语句。  ### 遍历 Map 结构  任何部署了 Iterator 接口的对象，都可以用 for...of 循环遍历。Map 结构原生支持 Iterator 接口，配合变量的解构赋值，获取键名和键值就非常方便。  ```js const map = new Map(); map.set('first', 'hello'); map.set('second', 'world');  for (let [key, value] of map) {   console.log(key + ' is ' + value); } // first is hello // second is world ```  如果只想获取键名，或者只想获取键值，可以写成下面这样。  ```js // 获取键名 for (let [key] of map) {   // ... }  // 获取键值 for (let [, value] of map) {   // ... } ```  ### 输入模块的指定方法  加载模块时，往往需要指定输入哪些方法。解构赋值使得输入语句非常清晰。  ```js const { SourceMapConsumer, SourceNode } = require('source-map'); ```  参考文章： [ECMAScript 6 入门](http://es6.ruanyifeng.com/#docs/destructuring) "},{title:"【读书笔记】ES6之用let,const和用var来声明变量的区别",path:"/posts/%E3%80%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%91ES6%E4%B9%8B%E7%94%A8let-const%E5%92%8C%E7%94%A8var%E6%9D%A5%E5%A3%B0%E6%98%8E%E5%8F%98%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB.html",strippedContent:" ## var(掌握)  ### 不区分变量和常量  用 var 声明的变量都是变量，都是可变的，我们可以随便对它进行运算操作。这样当多个人进行同一个项目时，区分变量和常量会越来越难，一不小心就会把设计为常量的数据更改了。  ### 允许重新声明  在相同作用域下用 var 声明的一个变量，当再次声明时，程序不会报错，并且会把该变量重新赋值。  ### 存在变量提升  变量在声明它们的脚本或函数中都是有定义的，变量声明语句会被“提前”至脚本或者函数的顶部。但是初始化的操作则还在原来 var 语句的位置执行，在声明语句之前变量的值是 undefined。   需要注意的是，var 语句同样可以作为 for 循环或者 for/in 循环的组成部分（和在循环之外声明的变量声明一样，这里声明的变量也会“提前”）。  ```js console.log('a:', a); //undefined var a = 2; function b() {   console.log('c:', c); //undefined   var c = 3;   console.log('c:', c); //3 } console.log('a:', a); //2 ```  ### 没有块级作用域  只有全局作用域和函数作用域，所有函数外的全局变量在程序的任何地方都是可见的，函数内部的变量只在函数内部可见，函数外无法访问该变量。  ### 是顶层对象的属性  JavaScript 全局变量是全局对象的属性，这是在 ECMAScript 规范中强制规定的。对于局部变量则没有如此规定，但我们可以想象得到，局部变量当做跟函数调用相关的某个对象的属性。ECMAScript 5 规范称为“声明上下文对象”（declarative environment record）。  ## let 声明变量（掌握）  ### 不存在变量提升  let 命令改变了语法行为，它所声明的变量一定要在声明后使用，否则报错。  ```js console.log(bar); // 报错ReferenceError let bar = 2; ```  但是真的不存在变量提升吗？请看这些篇文章：  - [let 深入理解---let 存在变量提升吗？](https://note.youdao.com/) - [我用了两个月的时间才理解 let](https://note.youdao.com/)  看完这些文章，最后总结到：  - let 的「创建」过程被提升了，但是初始化没有提升。 - var 的「创建」和「初始化」都被提升了。 - function 的「创建」「初始化」和「赋值」都被提升了。  ### 暂时性死区  ES6 明确规定，如果区块中存在 let 和 const 命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。   总之，在代码块内，使用 let 命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。 从块顶部到该变量的初始化语句，这块区域叫做 TDZ（临时死区）  ```js if (true) {   // TDZ开始   tmp = 'abc'; // ReferenceError   console.log(tmp); // ReferenceError    let tmp; // TDZ结束   console.log(tmp); // undefined    tmp = 123;   console.log(tmp); // 123 } ```  所谓暂时死区，就是不能在初始化之前，使用变量。  ### 不允许重复声明  let 不允许在相同作用域内，重复声明同一个变量。  ```js // 报错 function func() {   let a = 10;   var a = 1; } // 报错 function func() {   let a = 10;   let a = 1; }  function func(arg) {   let arg; // 报错 } function func(arg) {   {     let arg; // 不报错   } } ```  ### 块作用域  它的用法类似于 var，但是所声明的变量，只在 let 命令所在的代码块内有效。{}包裹就是一个作用域，用 let 声明的变量在{}中可见，在{}外面不可见。  ```js function f1() {   let n = 5;   if (true) {     let n = 10;   }   console.log(n); // 5 } ```  for 循环的计数器，就很合适使用 let 命令  ```js for (let i = 0; i < 10; i++) {   // ... }  console.log(i); // ReferenceError: i is not defined  var a = []; for (let i = 0; i < 10; i++) {   a[i] = function() {     console.log(i);   }; } a[6](); // 6 ```  for 循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。  ```js for (let i = 0; i < 3; i++) {   let i = 'abc';   console.log(i); } // abc // abc // abc /* for( let i = 0; i< 5; i++) 这句话的圆括号之间，有一个隐藏的作用域 for( let i = 0; i< 5; i++) { 循环体 } 在每次执行循环体之前，JS 引擎会把 i 在循环体的上下文中重新声明及初始化一次。 其他细节就不说了，太细碎了*/ ```  ES6 允许块级作用域的任意嵌套  ```js {   {     {       {         {           let insane = 'Hello World';         }         console.log(insane); // 报错       }     }   } } // 内层作用;  {   {     {       {         let insane = 'Hello World';         {           let insane = 'Hello World';         }       }     }   } } ```  最后导致 IIFE 不再必要了  ```js // IIFE 写法 (function () {   var tmp = ...;   ... }());  // 块级作用域写法 {   let tmp = ...;   ... } ```  #### 扩展：块级作用域与函数声明  ES5 规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。但是，浏览器没有遵守这个规定，为了兼容以前的旧代码，还是支持在块级作用域之中声明函数，因此实际都能运行，不会报错。  ES6 引入了块级作用域，明确允许在块级作用域之中声明函数。ES6 规定，块级作用域之中，函数声明语句的行为类似于 let，在块级作用域之外不可引用。  ```js function f() {   console.log('I am outside!'); }  (function() {   if (false) {     // 重复声明一次函数f     function f() {       console.log('I am inside!');     }   }    f(); })(); //ES5 环境会得到“I am inside!” //ES6 环境会得到“I am outside!” ```  为了减轻因此产生的不兼容问题，ES6 在附录 B 里面规定，浏览器的实现可以不遵守上面的规定，有自己的行为方式。  - 允许在块级作用域内声明函数。 - 函数声明类似于 var，即会提升到全局作用域或函数作用域的头部。 - 同时，函数声明还会提升到所在的块级作用域的头部。  允许在块级作用域内声明函数。 函数声明类似于 var，即会提升到全局作用域或函数作用域的头部。 同时，函数声明还会提升到所在的块级作用域的头部。上面的代码在符合 ES6 的浏览器中，都会报错，因为实际运行的是下面的代码。  ```js // 浏览器的 ES6 环境 function f() {   console.log('I am outside!'); } (function() {   var f = undefined;   if (false) {     function f() {       console.log('I am inside!');     }   }    f(); })(); // Uncaught TypeError: f is not a function ```  考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。  ### 不是顶层对象的属性  顶层对象的属性与全局变量挂钩，被认为是 JavaScript 语言最大的设计败笔之一。这样的设计带来了几个很大的问题，首先是没法在编译时就报出变量未声明的错误，只有运行时才能知道（因为全局变量可能是顶层对象的属性创造的，而属性的创造是动态的）；其次，程序员很容易不知不觉地就创建了全局变量（比如打字出错）；最后，顶层对象的属性是到处可以读写的，这非常不利于模块化编程。另一方面，window 对象有实体含义，指的是浏览器的窗口对象，顶层对象是一个有实体含义的对象，也是不合适的。 用 let 命令声明的全局变量，不属于顶层对象的属性。  ## const 声明常量（掌握）  ### 值不能改变  const 声明一个只读的常量。一旦声明，常量的值就不能改变。  ```js const PI = 3.1415; PI; // 3.1415  PI = 3; // TypeError: Assignment to constant variable. ```  const 声明的变量不得改变值，这意味着，const 一旦声明变量，就必须立即初始化，不能留到以后赋值。  ```js const foo; // SyntaxError: Missing initializer in const declaration ```  #### 本质  const 实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，const 只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。  ```js const foo = {};  // 为 foo 添加一个属性，可以成功 foo.prop = 123; foo.prop; // 123  // 将 foo 指向另一个对象，就会报错 foo = {}; // TypeError: \"foo\" is read-only ```  上面代码中，常量 foo 储存的是一个地址，这个地址指向一个对象。不可变的只是这个地址，即不能把 foo 指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。   下面是一个将对象彻底冻结的函数  ```js var constantize = obj => {   Object.freeze(obj);   Object.keys(obj).forEach((key, i) => {     if (typeof obj[key] === 'object') {       constantize(obj[key]);     }   }); }; // 常规模式时，下面一行不起作用； // 严格模式时，该行会报错 ```  ### 不是顶层对象的属性（同 let）  ### 块级作用域（同 let）  ### 重复声明（同 let）  ### 不存在变量提升（同 let）  ### 暂时性死区（同 let）  其实 const 和 let 只有一个区别，那就是 const 只有「创建」和「初始化」，没有「赋值」过程。 在同一作用域中 const 的创建被提升了，初始化在 const 语句处才开始，所以有暂时性死区。   参考文章：  - [ECMAScript 6 入门](http://es6.ruanyifeng.com/) - [let 深入理解---let 存在变量提升吗？](https://www.jianshu.com/p/0f49c88cf169) "},{title:"【读书笔记】《JavaScript权威指南》第8章函数",path:"/posts/%E3%80%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%91%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B%E7%AC%AC8%E7%AB%A0%E5%87%BD%E6%95%B0.html",strippedContent:' ## 函数定义（掌握）  &emsp;&emsp;函数使用 function 关键字来定义，它可以用在函数定义表达式或者函数声明语句里。在两种形式中，函数定义都从 function 关键字开始，其后跟随这些组成部分：  - 函数名称标识符。函数名称是函数声明语句必需的部分。它的用途就像变量的名字，新定义的函数对象会赋值给这个变量。对函数定义表达式来说，这个名字是可选的：如果存在，该名字只存在于函数体中，并指代该函数对象本身。 - 一对圆括号，其中包含由 0 个或者多个用逗号隔开的标识符组成的列表。这些标识符是函数的参数名称，它们就像函数体中的局部变量一样。 - 一对花括号，其中包含 0 条或多条 JavaScript 语句。这些语句构成了函数体：一旦调用函数，就会执行这些语句。  &emsp;&emsp;函数声明语句“被提前”到外部脚本或外部函数作用域的顶部，所以以这种方式声明的函数，可以被在它定义之前出现的代码所调用。   &emsp;&emsp;不过，以表达式定义的函数就另当别论了，为了调用一个函数，必须要能引用它，而要使用一个以表达式方式定义的函数之前，必须把它赋值给一个变量。变量的声明提前了，但给变量赋值是不会提前的，所以，以表达式方式定义的函数在定义之前无法调用。  ## 函数调用（掌握）  &emsp;&emsp;构成函数主体的 JavaScript 代码在定义之时并不会执行，只有调用该函数时，它们才会执行。有 4 种方式来调用 JavaScript 函数：  - 作为函数 - 作为方法 - 作为构造函数 - 通过它们的 cal1（）和 apply（）方法间接调用  ### 函数调用  ```js printprops({ x: 1 }); var total = distance(o, 0, 2, 1) + distance(2, 1, 3, 5); var probability = factorial(5) / factorial(13); ```  &emsp;&emsp;对于普通的函数调用，函数的返回值成为调用表达式的值。如果该函数返回是因为解释器到达结尾，返回值就是 undefined。如果函数返回是因为解释器执行到一条 return 语句，返回值就是 return 之后的表达式的值，如果 return 语句没有值，则返回 undefined。   &emsp;&emsp;根据 ECMAScript3 和非严格的 ECMAScript5 对函数调用的规定，调用上下文（this 的值）是全局对象。然而，在严格模式下，调用上下文则是 undefined。   &emsp;&emsp;以函数形式调用的函数通常不使用 this 关键字。不过，“this”可以用来判断当前是否是严格模式。  ```js /定义并调用一个函数来确定当前脚本运行时是否为严格模式 var strict=（function（）{ return !this；}（））； ```  ### 方法调用  &emsp;&emsp;对方法调用的参数和返回值的处理，和上面所描述的普通函数调用完全一致。但是，方法调用和函数调用有一个重要的区别，即：调用上下文。下面是一个具体的例子：  ```js var calculator={//对象直接量 operand1：1， operand2：1， add:function（）{ //注意this关键字的用法，this指代当前对象 this.result=this.operand1+this.operandz； }； calculator.add（）；//这个方法调用计算1+1的结果 calculator.result //=>2 ```  &emsp;&emsp;需要注意的是，this 是一个关键字，不是变量，也不是属性名。JavaScript 的语法不允许给 this 赋值。   &emsp;&emsp;和变量不同，关键字 this 没有作用域的限制，嵌套的函数不会从调用它的函数中继承 this。如果嵌套函数作为方法调用，其 this 的值指向调用它的对象。如果嵌套函数作为函数调用，其 this 值不是全局对象（非严格模式下）就是 undefined（严格模式下）。很多人误以为调用嵌套函数时 this 会指向调用外层函数的上下文。如果你想访问这个外部函数的 this 值，需要将 this 的值保存在一个变量里，这个变量和内部函数都同在一个作用域内。通常使用变量 self 来保存 this。  ### 构造函数调用  &emsp;&emsp;如果函数或者方法调用之前带有关键宇 new，构造函数调用和普通的函数调用以及方法调用在实参处理、调用上下文和返回值方面都有不同。   &emsp;&emsp;构造函数调用创建一个新的空对象，这个对象继承自构造函数的 prototype 属性。构造函数试图初始化这个新创建的对象，并将这个对象用做其调用上下文，因此构造函数可以使用 this 关键字来引用这个新创建的对象。注意，尽管构造函数看起来像一个方法调用，它依然会使用这个新对象作为调用上下文。也就是说，在表达式 new o.m（）中，调用上下文并不是 o。   &emsp;&emsp;构造函数通常不使用 return 关键宇，它们通常初始化新对象，当构造函数的函数体执行完毕时，它会显式返回。在这种情况下，构造函数调用表达式的计算结果就是这个新对象的值。然而如果构造函数显式地使用 return 语句返回一个对象，那么调用表达式的值就是这个对象。如果构造函数使用 return 语句但没有指定返回值，或者返回一个原始值，那么这时将忽略返回值，同时使用这个新对象作为调用结果。  ### 间接调用  &emsp;&emsp;JavaScript 中的函数也是对象，和其他 JavaScript 对象没什么两样，函数对象也可以包含方法。其中的两个方法 ca11（）和 apply（）可以用来间接地调用函数。两个方法都允许显式指定调用所需的 this 值，也就是说，任何函数可以作为任何对象的方法来调用，哪怕这个函数不是那个对象的方法。两个方法都可以指定调用的实参。ca11（）方法使用它自有的实参列表作为函数的实参，apply（）方法则要求以数组的形式传入参数。  ## 函数的实参和形参（掌握）  ### 可选形参  &emsp;&emsp;当调用函数的时候传入的实参比函数声明时指定的形参个数要少，剩下的形参都将设置为 undefined 值。因此在调用函数时形参是否可选以及是否可以省略应当保持较好的适应性。为了做到这一点，应当给省略的参数赋一个合理的默认值。  ```js a = a || null; ```  &emsp;&emsp;需要注意的是，当用这种可选实参来实现函数时，需要将可选实参放在实参列表的最后。那些调用你的函数的程序员是没办法省略第一个实参并传入第二个实参的，它必须将 undefined 作为第一个实参显式传入。同样注意在函数定义中使用注释/\\*optional\\*/来强调形参是可选的。  ### 可变长的实参列表：实参对象  &emsp;&emsp;当调用函数的时候传入的实参个数超过函数定义时的形参个数时，没有办法直接获得未命名值的引用。参数对象解决了这个问题。在函数体内，标识符 arguments 是指向实参对象的引用，实参对象是一个类数组对象，这样可以通过数字下标就能访问传入函数的实参值，而不用非要通过名字来得到实参。  ```js function max（/*...*/）{     var max=Number.NEGATIVE_INFINITY； //遍历实参，查找并记住最天值     for（var i=0；i< arguments.length；i++）         if（arguments[i]>max）max =arguments[i]；         //返回最大值         return max； } var largest =max（1，10，100，2，3，1000，4，5，10000，6）；//=>10000 ```  &emsp;&emsp;通过实参名字来修改实参值的话，通过 arguments[]数组也可以获取到更改后的值,在 ECMAScript 5 中移除了实参对象的这个特殊特性。在严格模式下还有一点（和非严格模式下相比的）不同，在非严格模式中，函数里的 arguments 仅仅是一个标识符，在严格模式中，它变成了一个保留字。严格模式中的函数无法使用 arguments 作为形参名或局部变量名，也不能给 arguments 赋值。  ### callee 和 caller 属性  &emsp;&emsp;除了数组元素，实参对象还定义了 callee 和 caller 属性。在 ECMAScript 5 严格模式中，对这两个属性的读写操作都会产生一个类型错误。而在非严格模式下，ECMAScript 标准规范规定 callee 属性指代当前正在执行的函数。caller 是非标准的，但大多数浏览器都实现了这个属性，它指代调用当前正在执行的函数的函数。通过 caller 属性可以访问调用栈。callee 属性在某些时候会非常有用，比如在匿名函数中通过 callee 来递归地调用自身。  ```js var factorial = function(x) {   if (x <= 1) return 1;   return x * arguments.callee(x - 1); }; ```  ### 将对象属性用做实参  &emsp;&emsp;当一个函数包含超过三个形参时，对于程序员来说，要记住调用函数中实参的正确顺序实在让人头疼。最好通过名/值对的形式来传入参数，这样参数的顺序就无关紧要了。定义函数的时候，传入的实参都写入一个单独的对象之中，在调用的时候传入一个对象，对象中的名/值对是真正需要的实参数据。  ## 作为值的函数  &emsp;&emsp;在 JavaScript 中，函数不仅是一种语法，也是值，也就是说，可以将函数赋值给变量，存储在对象的属性或数组的元素中，作为参数传人另外一个函数等。  ### 自定义函数属性  &emsp;&emsp;JavaScript 中的函数并不是原始值，而是一种特殊的对象，也就是说，函数可以拥有属性。当函数需要一个“静态”变量来在调用时保持某个值不变，最方便的方式就是给函数定义属性，而不是定义全局变量，显然定义全局变量会让命名空间变得更加杂乱无章。  ```js //计算阶乘，并将结果缓存至函数的属性中 function factorial（n）{     if（isFinite（n）8& n>o 8& n==Math.round（n））{//有限的正整数         if（！（n in factorial））//如果没有缓存结果             factorial[n]=n* factorial（n-1）；//计算结果并缓存之             return factorial[n]；//返回缓存结果         }         else return NaN；//如果输入有误 } factorial[1]=1；//初始化缓存以保存这种基本情况 ```  ## 作为命名空间的函数(掌握)  &emsp;&emsp;比如，假设你写了一段 JavaScript 模块代码，假定这段代码定义了一个用以存储中间计算结果的变量。这样问题就来了，当模块代码放到不同的程序中运行时，你无法得知这个变量是否已经创建了，如果已经存在这个变量，那么将会和代码发生冲突。解决办法当然是将代码放入一个函数内，然后调用这个函数。这样全局变量就变成了函数内的局部变量。  ```js （function（）{//mymodule（）匿名的函数表达式 //模块代码     }（））；//结束函数定义并立即调用它 ```  ## 闭包（掌握）  &emsp;&emsp;和其他大多数现代编程语言一样，JavaScript 也采用词法作用域（lexical scoping），也就是说，函数的执行依赖于变量作用域，这个作用域是在函数定义时决定的，而不是函数调用时决定的。   &emsp;&emsp;为了实现这种词法作用域，JavaScript 函数对象的内部状态不仅包含函数的代码逻辑，还必须引用当前的作用域链。函数对象可以通过作用域链相互关联起来，函数体内部的变量都可以保存在函数作用域内，这种特性在计算机科学文献中称为“闭包”。  ```js var scope="global scope"；//全局变量 function checkscope（）{     var scope="local scope"；//局部变量     function f（）{ return scope；}//在作用域中返回这个值     return f（）； } checkscope（）//=>"local scope" ```  回想一下词法作用域的基本规则：JavaScript 函数的执行用到了作用域链，这个作用域链是函数定义的时候创建的。嵌套的函数 f（）定义在这个作用域链里，其中的变量 scope 一定是局部变量，不管在何时何地执行函数 f（），这种绑定在执行 f（）时依然有效。因此最后一行代码返回“local scope”，而不是“global scope”。  ### 实现闭包  &emsp;&emsp;我们将作用域链描述为一个对象列表，不是绑定的栈。每次调用 JavaScript 函数的时候，都会为之创建一个新的对象用来保存局部变量，把这个对象添加至作用域链中。   &emsp;&emsp;当函数返回的时候，就从作用域链中将这个绑定变量的对象删除。如果不存在嵌套的函数，也没有其他引用指向这个绑定对象，它就会被当做垃圾回收掉。   &emsp;&emsp;如果定义了嵌套的函数，每个嵌套的函数都各自对应一个作用域链，并且这个作用域链指向一个变量绑定对象。但如果这些嵌套的函数对象在外部函数中保存下来，那么它们也会和所指向的变量绑定对象一样当做垃圾回收。   &emsp;&emsp;但是如果这个函数定义了嵌套的函数，并将它作为返回值返回或者存储在某处的属性里，这时就会有一个外部引用指向这个嵌套的函数。它就不会被当做垃圾回收，并且它所指向的变量绑定对象也不会被当做垃圾回收。  ```js var uniqueInteger=（function（）{//定义函数并立即调用     var counter=0；//函数的私有状态     return function（）{ return counter++；}； }（））； ```  ```js function counter（）{     var n=0；     return{         count:function（）{return n++；}，         reset:function（）{n=o；}     }； } var c=counter(),d=counter()；//创建两个计数器 d.count（）//l=>0：它们互不干扰 c.reset（）//reset（）和count（）方法共享状态 C.count（）//=>0：因为我们重置了c d.count（）//=>1：而没有重置d ```  &emsp;&emsp;每次调用 counter（）都会创建一个新的作用域链和一个新的私有变量。因此，如果调用 counter（）两次，则会得到两个计数器对象，而且彼此包含不同的私有变量，调用其中一个计数器对象的 count（）或 reset（）不会影响到另外一个对象。  ```js function counter（n）{//函数参数n是一个私有变量     return{         //属性getter方法返回并给私有计数器var递增1         get count（）{return n++；}，         //属性setter不允许n递减         set count（m）{         if（m>=n）n=m；         else throw Error（"count can only be set to a larger value"）；         }     }； } var c=counter（1000）； c.count//=>1000 c.count//=>1001 c.count=2000 c.count//=>2000 c.count=2000//=>Error！ ```  &emsp;&emsp;需要注意的是，这个版本的 counter（）函数并未声明局部变量，而只是使用参数 n 来保存私有状态，属性存取器方法可以访问 n。这样的话，调用 counter（）的函数就可以指定私有变量的初始值了。  ``` //这个函数返回一个总是返回v的函数 function constfunc（v）{return function（）{return v；}；} //创建一个数组用来存储常数函数 var funcs=[]； for（var i=o；i<10；i++）funcs[i]=constfunc（i）； //在第5个位置的元素所表示的函数返回值为5 funcs[5]（）//=>5 ```  &emsp;&emsp;这段代码利用循环创建了很多个闭包，当写类似这种代码的时候往往会犯一个错误：那就是试图将循环代码移入定义这个闭包的函数之内，看一下这段代码：  ``` //返回一个函数组成的数组，它们的返回值是0～9 function constfuncs（）{     var funcs=[]；     for（vari=0；i<10；i++）         funcs[i]=function（）{ return i；}；     return funcs； } var funcs=constfuncs（）； funcs[5]（）//返回值是10 ```  &emsp;&emsp;书写闭包的时候还需注意一件事情，this 是 JavaScript 的关键字，而不是变量。正如之前讨论的，每个函数调用都包含一个 this 值，如果闭包在外部函数里是无法访问 this 的，除非外部函数将 this 转存为一个变量：  ```js var self=this；//将this保存至一个变量中，以便嵌套的函数能够访问它 ```  ## 函数属性、方法和构造函数（掌握）  ### length 属性  &emsp;&emsp;在函数体里，arguments.length 表示传入函数的实参的个数。而函数本身的 1ength 属性则有着不同含义。函数的 1ength 属性是只读属性，它代表函数实参的数量，这里的参数指的是“形参”而非“实参”，也就是在函数定义时给出的实参个数，通常也是在函数调用时期望传入函数的实参个数。  ### prototype 属性  &emsp;&emsp;每一个函数都包含一个 prototype 属性，这个属性是指向一个对象的引用，这个对象称做“原型对象”（prototype object）。每一个函数都包含不同的原型对象。当将函数用做构造函数的时候，新创建的对象会从原型对象上继承属性。  ### call（）方法和 apply（）方法  ```js function classof(o) {   if (o === null) return \'Null\';   if ((o = a = undefined)) return \'Undefined\';   return Object.prototype.tostring.call(o).slice(8, -1); } ```  &emsp;&emsp;在 ECMAScript5 的严格模式中，ca11（）和 apply（）的第一个实参都会变为 this 的值，哪怕传入的实参是原始值甚至是 null 或 undefined。在 ECMAScript3 和非严格模式中，传入的 null 和 undefined 都会被全局对象代替，而其他原始值则会被相应的包装对象（wrapper object）所替代。apply（）方法和 cal1（）类似，但传入实参的形式和 cal1（）有所不同，它的实参都放入一个数组当中：需要注意的是，传入 apply（）的参数数组可以是类数组对象也可以是真实数组。  ```js f.apply(o, [1, 2]); ```  ### bind（）方法  &emsp;&emsp;bind（）是在 ECMAScript5 中新增的方法，但在 ECMAScript3 中可以轻易模拟 bind（）。从名字就可以看出，这个方法的主要作用就是将函数绑定至某个对象。当在函数 f（）上调用 bind（）方法并传入一个对象 0 作为参数，这个方法将返回一个新的函数。（以函数调用的方式）调用新的函数将会把原始的函数 f（）当做。的方法来调用。传入新函数的任何实参都将传入原始函数，比如：  ```js function f（y）{ return this.x+y；}//这个是待绑定的函数 var o={x：1}；/将要绑定的对象 var g=f.bind（o）；//通过调用g（x）来调用o.f（x） g（2）//=>3 ```  &emsp;&emsp;ECMAScript 5 中的 bind（）方法不仅仅是将函数绑定至一个对象，它还附带一些其他应用：除了第一个实参之外，传入 bind（）的实参也会绑定至 this，这个附带的应用是一种常见的函数式编程技术，有时也被称为“柯里化”（currying）。  ```js var sum=function（x，y）{ return x+y}；//返回两个实参的和值 //创建一个类似sum的新函数，但this的值绑定到nu11 //并且第一个参数绑定到1，这个新的函数期望只传入一个实参 var succ=sum.bind（null，1）； succ（2）//=>3：x绑定到1，并传入2作为实参y function f（y，z）{ return this.x+y+z}；//另外一个做累加计算的函数 var g=f.bind（{x：1}，2）；//绑定this和y g（3）//=>6：this.x绑定到1，y绑定到2，z绑定到3 ```  &emsp;&emsp;ECMAScript3 版本的 Function.bind（）方法  ```js if（!Function.prototype.bind）{ Function.prototype.bind=function（o/*，args*/）{     //将this和arguments的值保存至变量中     //以便在后面嵌套的函数中可以使用它们     var self=this，boundArgs=arguments；     //bind（）方法的返回值是一个函数     return function（）{         //创建一个实参列表，将传入bind（）的第二个及后续的实参都传入这个函数         var args=[]，i；         for（i=1；i< boundArgs.length；i++）args.push（boundArgs[i]）；         for（i=o；i<arguments.length；i++）args.push（arguments[i]）；         //现在将self作为o的方法来调用，传入这些实参         return self.apply（o，args）；         }；     }； }； ```  &emsp;&emsp;ECMAScript5 定义的 bind（）方法也有一些特性是上述 ECMAScript3 代码无法模拟的。首先，真正的 bind（）方法返回一个函数对象，这个函数对象的 length 属性是绑定函数的形参个数减去绑定实参的个数（1ength 的值不能小于零）。   &emsp;&emsp;再者，ECMAScript5 的 bind（）方法可以顺带用做构造函数。如果 bind（）返回的函数用做构造函数，将忽略传入 bind（）的 this，原始函数就会以构造函数的形式调用，其实参也已经绑定。   &emsp;&emsp;由 bind（）方法所返回的函数并不包含 prototype 属性（普通函数固有的 prot otype 属性是不能删除的），并且将这些绑定的函数用做构造函数时所创建的对象从原始的未绑定的构造函数中继承 prototype。同样，在使用 instanceof 运算符时，绑定构造函数和未绑定构造函数并无两样。  ### toString（）方法  &emsp;&emsp;和所有的 JavaScript 对象一样，函数也有 toString（）方法，ECMAScript 规范规定这个方法返回一个字符串，这个字符串和函数声明语句的语法相关。实际上，大多数（非全部）的 toString（）方法的实现都返回函数的完整源码。内置函数往往返回一个类似 “[native code]”的字符串作为函数体。  ### Function（）构造函数  &emsp;&emsp;不管是通过函数定义语句还是函数直接量表达式，函数的定义都要使用 function 关字。但函数还可以通过 Function（）构造函数来定义，比如：  ```js var f = new Function(\'x\', \'y\', \'return x*y;\'); ```  &emsp;&emsp;Function（）构造函数可以传入任意数量的字符串实参，最后一个实参所表示的文本就是函数体；它可以包含任意的 JavaScript 语句，每两条语句之间用分号分隔。传入构造函数的其他所有的实参字符串是指定函数的形参名字的字符串。如果定义的函数不包含任何参数，只须给构造函数简单地传入一个字符串——函数体即可。   &emsp;&emsp;关于 Function（）构造函数有几点需要特别注意：  - Function（）构造函数允许 JavaScript 在运行时动态地创建并编译函数。 - 每次调用 Function（）构造函数都会解析函数体，并创建新的函数对象。如果是在一个循环或者多次调用的函数中执行这个构造函数，执行效率会受影响。相比之下，循环中的嵌套函数和函数定义表达式则不会每次执行时都重新编译。 - 最后一点，也是关于 Function（）构造函数非常重要的一点，就是它所创建的函数并不是使用词法作用域，相反，函数体代码的编译总是会在顶层函数执行，正如下面代码所示：  ```js var scope="global"；function constructFunction（）{     var scope="local"；     return new Function（"return scope"）；//无法捕获局部作用域     } //这一行代码返回global，因为通过Function（）构造函数 //所返回的函数使用的不是局部作用域 constructFunction（）（）；//=>"global" ```  &emsp;&emsp;Function（）构造函数在实际编程过程中很少会用到。  ## 函数式编程(掌握)  ### 使用函数处理数组  &emsp;&emsp;自定义 map（）和 reduce（）函数  ```js //对于每个数组元素调用函数f（），并返回一个结果数组 //如果Array.prototype.map定义了的话，就使用这个方法 var map=Array.prototype.map ？function（a，f）{ return a.map（f）；}//如果已经存在map（）方法，就直接使用它 ：function（a，f）{//否则，自己实现一个 var results=[]； for（var i=0，len=a.length；i< len；i++）{     if（i in a）results[i]=f.call（null，a[i]，i，a）； return results； }； ```  ```js //使用函数f（）和可选的初始值将数组a减至一个值 //如果Array.prototype.reduce存在的话，就使用这个方法 var reduce=Array.prototype.reduce     ？function（a，f，initial）{//如果reduce（）方法存在的话     if（arguments.1ength>2）         return a.reduce（f，initial）；//如果传人了一个初始值         else return a.reduce（f）；//否则没有初始值     }     ：function（a，f，initial）{//这个算法来自ES5规范         var i=0，len=a.length，accumulator；     //以特定的初始值开始，否则第一个值取自a     if（arguments.1ength>2）accumulator=initial；     else{//找到数组中第一个已定义的索引         if（len==o）throw TypeError（）；         while（i<len）{             if（i in a）{                 accumulator =a[i++]；                 break；             }             else i++；         }         if（i==1en）throw TypeError（）；     }     //对于数组中剩下的元素依次调用f（）     while（i<1en）{         if（i in a）             accumulator=f.call（undefined，accumulator，a[i]，i，a）；         i++；     }     return accumulator；     }； ```  ### 高阶函数  &emsp;&emsp;所谓高阶函数（higher-order function）就是操作函数的函数，它接收一个或多个函数作为参数，并返回一个新函数，这里是一个更常见的例子，它接收两个函数 f（）和 g（），并返回一个新的函数用以计算 f（g（））：：  ```js //返回一个新的可以计算f（g（...））的函数 //返回的函数h（）将它所有的实参传入g（），然后将g（）的返回值传入f（） //调用f（）和g（）时的this值和调用h（）时的this值是同一个this function compose（f，g）{     return function（）{         //需要给f（）传人一个参数，所以使用f（）的cal1（）方法         //需要给g（）传入很多参数，所以使用g（）的apply（）方法         return f.call（this，g.apply（this，arguments））；     }； } var square=function（x）{ return x*x；}； var sum=function（x，y）{ return x+y；}； var squareofsum=compose（square，sum）； squareofsum（2，3）//=>25 ```  ```js //这个高阶函数返回一个新的函数，这个新函数将它的实参传入f（） //并返回f的返回值的逻辑非 function not（f）{     return function（）{/返回一个新的函数         var result=f.apply（this，arguments）；//调用f（）         return ！result；//对结果求反     }； var even=function（x）{//判断a是否为偶数的函数     return x%2===0； }； var odd =not（even）；//一个新函数，所做的事情和even（）相反 [1，1，3，5，5].every（odd）；//=>true：每个元素都是奇数 ```  ### 不完全函数  &emsp;&emsp;作者在本节讨论的是一种函数变换技巧，即把一次完整的函数调用拆成多次函数调用，每次传入的实参都是完整实参的一部分，每个拆分开的函数叫做不完全函数（partial function），每次函数调用叫做不完全调用（partial application），这种函数变换的特点是每次调用都返回一个函数，直到得到最终运行结果为止，举一个简单的例子，将对函数 f（1，2，3，4，5，6）的调用修改为等价的 f（1，2）（3，4）（5，6），后者包含三次调用，和每次调用相关的函数就是“不完全函数”。  ### 记忆  &emsp;&emsp;定义了一个阶乘函数，它可以将上次的计算结果缓存起来。在函数式编程当中，这种缓存技巧叫做“记忆”（memorization）。下面的代码展示了一个高阶函数，memorize（）接收一个函数作为实参，并返回带有记忆能力的函数。   &emsp;&emsp;需要注意的是，记忆只是一种编程技巧，本质上是牺牲算法的空间复杂度以换取更优的时间复杂度，在客户端 JavaScript 中代码的执行时间复杂度往往成为瓶颈，因此在大多数场景下，这种牺牲空间换取时间的做法以提升程序执行效率的做法是非常可取的。  ```js //返回f（）的带有记忆功能的版本 //只有当f（）的实参的字符串表示都不相同时它才会工作 function memorize（f）{     var cache={}；//将值保存在闭包内     return function（）{     //将实参转换为字符串形式，并将其用做缓存的键         var key=arguments.length +Array.prototype.join.call（arguments，"，"）；         if（key in cache） return cache[key]；         else return cache[key]=f.apply（this，arguments）；         }；     } ```  &emsp;&emsp;memorize（）函数创建一个新的对象，这个对象被当做缓存（的宿主）并赋值给一个局部变量，因此对于返回的函数来说它是私有的（在闭包中）。所返回的函数将它的实参数组转换成字符串，并将字符串用做缓存对象的属性名。如果在缓存中存在这个值，则直接返回它。   &emsp;&emsp;否则，就调用既定的函数对实参进行计算，将计算结果缓存起来并返回，下面的代码展示了如何使用 memorize（）：  ```js //返回两个整数的最大公约数 //使用欧几里德算法：http://en.wikipedia.org/wiki/Euclidean_algorithm function gcd（a，b）{//这里省略对ab的类型检查     var t；//临时变量用来存储交换数值     if（a<b）t=b，b=a，a=t；//确保a>=b     while（bl=0）t=b，b=ab，a=t；//这是求最大公约数的欧几里德算法     return a；     } var gcdmemo=memorize（gcd）； gcdmemo（85，187）//=>17 //注意，当我们写一个递归函数时，往往需要实现记忆功能 //我们更希望调用实现了记忆功能的递归函数，而不是原递归函数 var factorial=memorize（function（n）{     return（n<=1）？1：n*factorial（n-1）； }）； factorial（5）//=>120.对于4~1的值也有缓存 ``` '},{title:"【读书笔记】《JavaScript权威指南》第7章数组",path:"/posts/%E3%80%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%91%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B%E7%AC%AC7%E7%AB%A0%E6%95%B0%E7%BB%84.html",strippedContent:' ## 数组简介（了解）  &emsp;&emsp;数组是值的有序集合。每个值叫做一个元素，而每个元素在数组中有一个位置，以数字表示，称为索引。   &emsp;&emsp;JavaScript 数组是无类型的：数组元素可以是任意类型，并且同一个数组中的不同元素也可能有不同的类型。数组的元素甚至也可能是对象或其他数组，这允许创建复杂的数据结构，如对象的数组和数组的数组。   &emsp;&emsp;JavaScript 数组的索引是基于零的 32 位数值：第一个元素的索引为 0，最大可能的索引为 4294967294（2^32-2），数组最大能容纳 4294967295 个元素。   &emsp;&emsp;JavaScript 数组是动态的：根据需要它们会增长或缩减，并且在创建数组时无须声明一个固定的大小或者在数组大小变化时无须重新分配空间。   &emsp;&emsp;JavaScript 数组可能是稀疏的：数组元素的索引不一定要连续的，它们之间可以有空缺。   &emsp;&emsp;每个 JavaScript 数组都有一个 length 属性。针对非稀疏数组，该属性就是数组元素的个数。针对稀疏数组，length 比所有元素的索引要大。  ## 创建数组（掌握）  ### 数组直接量  &emsp;&emsp;使用数组直接量是创建数组最简单的方法，在方括号中将数组元素用逗号隔开即可。  ```js var empty=[]；//没有元素的数组 var primes=[2，3，5，7，11]；//有5个数值的数组 var misc=[1.1，true，"a"，]；//3个不同类型的元素和结尾的逗号 ```  &emsp;&emsp;如果省略数组直接量中的某个值，省略的元素将被赋子予 undefined 值：  ```js var count=[1，，3]；//数组有3个元素，中间的那个元素值为undefined var undefs=[，，]；//数组有2个元素，都是undefined ```  &emsp;&emsp;数组直接量的语法允许有可选的结尾的逗号，故[，，]只有两个元素而非三个。  ### 调用构造函数 Array（）  - 调用时没有参数：  ``` var a=new Array（）； ```  &emsp;&emsp;该方法创建一个没有任何元素的空数组，等同于数组直接量[]。  - 调用时有一个数值参数，它指定长度：  ```js var a=new Array（10）； ```  &emsp;&emsp;该技术创建指定长度的数组。当预先知道所需元素个数时，这种形式的 Array（）构造函数可以用来预分配一个数组空间。注意，数组中没有存储值，甚至数组的索引属性“0”、“1”等还未定义。  - 显式指定两个或多个数组元素或者数组的一个非数值元素：  ```js var a =new Array（5，4，3，2，1，"testing，testing"）； ```  &emsp;&emsp;以这种形式，构造函数的参数将会成为新数组的元素。使用数组字面量比这样使用 Array（）构造函数要简单多了。  ## 数组元素的读和写（掌握）  &emsp;&emsp;使用[]操作符来访问数组中的一个元素。数组的引用位于方括号的左边。方括号中是一个返回非负整数值的任意表达式。使用该语法既可以读又可以写数组的一个元素。  ```js var a=["world"]；//从一个元素的数组开始 var value=a[o]；//读第0个元素 a[1]=3.14；//写第1个元素 i=2； a[i]=3；//写第2个元素 a[i+1]="hello"；//写第3个元素 a[a[i]]=a[o]；//读第0个和第2个元素，写第3个元素 ```  &emsp;&emsp;所有的索引都是属性名，但只有在 0~2^32-2 之间的整数属性名才是索引。所有的数组都是对象，可以为其创建任意名字的属性。但如果使用的属性是数组的索引，数组的特殊行为就是将根据需要更新它们的 length 属性值。   &emsp;&emsp;注意，可以使用负数或非整数来索引数组。这种情况下，数值转换为字符串，字符串作为属性名来用。如果凑巧使用了是非负整数的字符串，它就当做数组索引，而非对象属性，当使用的一个浮点数和一个整数相等时情况也是一样的：  ```js a[-1.23]=true；//这将创建一个名为“-1.23"的属性 a["1000"]=0；//这是数组的第1001个元素 a[1.000]//和a[1]相等 ```  &emsp;&emsp;既然数组是对象，那么它们可以从原型中继承元素。在 ECMAScript5 中，数组可以定义元素的 getter 和 setter 方法。如果一个数组确实继承了元素或使用了元素的 getter 和 setter 方法，你应该期望它使用非优化的代码路径：访问这种数组的元素的时间会与常规对象属性的查找时间相近。  ## 稀疏数组（掌握）  &emsp;&emsp;稀疏数组就是包含从 0 开始的不连续索引的数组。通常，数组的 length 属性值代表数组中元素的个数。如果数组是稀疏的，length 属性值大于元素的个数。可以用 Array（）构造函数或简单地指定数组的索引值大于当前的数组长度来创建稀疏数组。  ```js a=new Array（5）；//数组没有元素，但是a.length是5 a=[]；//创建一个空数组，length=o a[1000]=0；//赋值添加一个元素，但是设置1ength为1001 ```  &emsp;&emsp;注意，当在数组直接量中省略值时不会创建稀疏数组。省略的元素在数组中是存在的，其值为 undefined。这和数组元素根本不存在是有一些微妙的区别的。可以用 in 操作符检测两者之间的区别：  ```js var al=[，，，]；//数组是[undefined，undefined，undefined] var a2=new Array（3）；//该数组根本没有元素 0 in al//=>true:a1在索引0处有一个元素 0 in a2//=>false:a2在索引0处没有元素 ```  &emsp;&emsp;需要注意的是，当省略数组直接量中的值时（使用连续的逗号，比如[1，，3]），这时所得到的数组也是稀疏数组，省略掉的值是不存在的：  ```js var al=[，]；//此数组没有元素，长度是1 var a2=[undefined]；//此数组包含一个值为undefined的元素 0 in a1//=>false:al在索引0处没有元素 0 in a2//=>true:a2在索引0处有一个值为undefined的元素 ```  ## 数组长度（掌握）  &emsp;&emsp;每个数组有一个 length 属性，就是这个属性使其区别于常规的 JavaScript 对象。针对稠密（也就是非稀疏）数组，1ength 属性值代表数组中元素的个数。其值比数组中最大的索引大 1：  ```js [].length//=>0：数组没有元素 [a\'，\'b\'，\'c\'].length//=>3：最大的索引为2，length为3 ```  &emsp;&emsp;当数组是稀疏的时，1ength 属性值大于元素的个数。而且数组长度保证大于它每个元素的索引值。或者，换一种说法，在数组中（无论稀疏与否）肯定找不到一个元素的索引值大于或等于它的长度。   &emsp;&emsp;为了维持此规则不变化，数组有两个特殊的行为。第一个如同上面的描述：如果为一个数组元素赋值，它的索引 i 大于或等于现有数组的长度时，length 属性的值将设置为 i+1。   &emsp;&emsp;第二个特殊的行为就是设置 length 属性为一个小于当前长度的非负整数 n 时，当前数组中那些索引值大于或等于 n 的元素将从中删除：  ```js a=[1，2，3，4，5]；//从5个元素的数组开始 a.length=3；//现在a为[1，2，3] a.length=0；//删除所有的元素。a为[] a.length=5；//长度为5，但是没有元素，就像new Array（5） ```  &emsp;&emsp;还可以将数组的 length 属性值设置为大于其当前的长度。实际上这不会向数组中添加新的元素，它只是在数组尾部创建一个空的区域。   &emsp;&emsp;在 ECMAScript5 中，可以用 Object.defineProperty（）让数组的 length 属性变成只读的  ```js a=[1，2，3]；//从3个元素的数组开始 Object.defineProperty（a，“1ength"，                     {writable:false}）；//让length属性只读 a.length=0；//a不会改变 ```  &emsp;&emsp;类似地，如果让一个数组元素不能配置，就不能删除它。如果不能删除它，length 属性不能设置为小于不可配置元素的索引值。  ## 数组元素的添加和删除(掌握)  ### 添加  &emsp;&emsp;为新索引赋值：  ```js a=[]//开始是一个空数组 a[o]="zero"；//然后向其中添加元素 a[1]="one"； ```  &emsp;&emsp;也可以使用 push（）方法在数组末尾增加一个或多个元素：  ```js a=[]；//开始是一个空数组 a.push（"zero"）//在末尾添加一个元素。a=["zero"] a.push（"one"，"two"）//再添加两个元素。a=["zero"，"one"，"two"] ```  &emsp;&emsp;在数组尾部压入一个元素与给数组 a[a.length]赋值是一样的。可以使用 unshift（）方法在数组的首部插入一个元素，并且将其他元素依次移到更高的索引处。  ### 删除  &emsp;&emsp;可以像删除对象属性一样使用 delete 运算符来删除数组元素：  ```js a=[1，2，3]； delete a[1]；//a在索引1的位置不再有元素 1 in a//=>false：数组索引1并未在数组中定义 a.length//=>3：delete操作并不影响数组长度 ```  &emsp;&emsp;删除数组元素与为其赋 undefined 值是类似的（但有一些微妙的区别）。注意，对一个数组元素使用 delete 不会修改数组的 length 属性，也不会将元素从高索引处移下来填充已删除属性留下的空白。如果从数组中删除一个元素，它就变成稀疏数组。   &emsp;&emsp;上面我们看到，也可以简单地设置 length 属性为一个新的期望长度来删除数组尾部的元素。   &emsp;&emsp;数组有 pop（）方法，使减少长度 1 并返回被删除元素的值。还有一个 shift（）方法，从数组头部删除一个元素。和 delete 不同的是 shift（）方法将所有元素下移到比当前索引低 1 的地方。   &emsp;&emsp;最后，splice（）是一个通用的方法来插入、删除或替换数组元素。它会根据需要修改 length 属性并移动元素到更高或较低的索引处。  ## 数组遍历（掌握）  &emsp;&emsp;在嵌套循环或其他性能非常重要的上下文中，可以看到这种基本的数组遍历需要优化，数组的长度应该只查询一次而非每次循环都要查询：  ```js for（var i=o，len=keys.length；i<len；i++）{ //循环体仍然不变 } ```  &emsp;&emsp;这些例子假设数组是稠密的，并且所有的元素都是合法数据。否则，使用数组元素之前应该先检测它们。如果想要排除 nu11、undefined 和不存在的元素，代码如下：  ```js for（var i=o；i<a.length；i++）{     if（!a[i]）continue；//跳过null、undefined和不存在的元素     //循环体 } ```  &emsp;&emsp;如果只想跳过 undefined 和不存的元素，代码如下：  ```js for（var i=0；i<a.length；i++）{     if（a[i]===undefined）continue；//跳过undefined+不存在的元素     //循环体 } ```  &emsp;&emsp;最后，如果只想跳过不存在的元素而仍然要处理存在的 undefined 元素，代码如下：  ```js for（var i=o；i< a.length；i++）{     if（！（i in a））continue；//跳过不存在的元素 //循环体 } ```  &emsp;&emsp;还可以使用 for/in 循环处理稀疏数组。循环每次将一个可枚举的属性名（包括数组索引）赋值给循环变量。不存在的索引将不会遍历到：  ```js for（var index in sparseArray）{     var value=sparseArray[index]；     //此处可以使用索引和值做一些事情 } ```  &emsp;&emsp;for/in 循环能够枚举继承的属性名，如添加到 Array.prototype 中的方法。由于这个原因，在数组上不应该使用 for/in 循环，除非使用额外的检测方法来过滤不想要的属性。如下检测代码取其一即可：  ```js for（var i in a）{     if（!a.hasownProperty（i））continue；//跳过继承的属性     //循环体 } ```  ```js for（var i in a）{     //跳过不是非负整数的i     if（String （Math.floor（Math.abs（Number（i））））!==i）continue； } ```  &emsp;&emsp;ECMAScript 规范允许 for/in 循环以不同的顺序遍历对象的属性。通常数组元素的遍历实现是升序的，但不能保证一定是这样的。特别地，如果数组同时拥有对象属性和数组元素，返回的属性名很可能是按照创建的顺序而非数值的大小顺序。如何处理这个问题的实现各不相同，如果算法依赖于遍历的顺序，那么最好不要使用 for/in 而用常规的 for 循环。   &emsp;&emsp;ECMAScript5 定义了一些遍历数组元素的新方法，按照索引的顺序按个传递给定义的一个函数。这些方法中最常用的就是 forEach（）方法：  ```js   var data=[1，2，3，4，5]；//这是需要遍历的数组 var sumOfSquares=0；//要得到数据的平方和 data.forEach（function（x）{//把每个元素传递给此函数                 sumOfSquares+=x*x；//平方相加 }）； SumOf5quares //=）55：1+4+9+16+25 ```  ## 多维数组(掌握)  &emsp;&emsp;JavaScript 不支持真正的多维数组，但可以用数组的数组来模似。访问数组的数组中的元素，只要简单地使用两次[]操作符即可。这里有一个具体的例子，它使用二维数组作为一个九九乘法表：  ```js //创建一个多维数组 var table=new Array（10）；//表格有10行 for（vari=o；i<table.length；i++）{     table[i]=new Array（10）；//每行有10列 } //初始化数组 for（var row=0；row< table.length；row++）{     for（col=o；col<table[row].length；col++）{         table[row][col]=row*col；     } } //使用多维数组来计算（查询）5*7 var product=table[5][7]；//35 ```  ## 数组方法(掌握)  ### ECMAScript 3  #### join()转化为字符串  &emsp;&emsp;Array.join（）方法将数组中所有元素都转化为字符串并连接在一起，返回最后生成的字符串。可以指定一个可选的字符串在生成的字符串中来分隔数组的各个元素。如果不指定分隔符，默认使用逗号。如以下代码所示：  ```js var a=[1，2，3]；//创建一个包含三个元素的数组 a.join（）；//=>"1，2，3" a.join（""）；//=>"123" a.join（""）；//=>"123" var b=new Array（10）；//长度为10的空数组 b.join（\'-\'）//=-：9个连字号组成的字符串 ```  &emsp;&emsp;Array.join（）方法是 String.split（）方法的逆向操作，后者是将字符串分割成若干块来创建一个数组。  #### reverse()颠倒顺序  &emsp;&emsp;Array.reverse（）方法将数组中的元素颠倒顺序，返回逆序的数组。它采取了替换；换句话说，它不通过重新排列的元素创建新的数组，而是在原先的数组中重新排列它们。  ```js var a=[1，2，3]； a.reverse（）.join（）//=>"3，2，1"，并且现在的a是[3，2，1] ```  #### sort()元素排序  &emsp;&emsp;Array.sort（）方法将数组中的元素排序并返回排序后的数组。当不带参数调用 sort（）时，数组元素以字母表顺序排序（如有必要将临时转化为字符串进行比较）：  ```js var a = new Array(\'banana\', \'cherry\', \'apple\'); a.sort(); var s = a.join(\',\'); //s=="apple, banana, cherry" ```  &emsp;&emsp;如果数组包含 undefined 元素，它们会被排到数组的尾部。   &emsp;&emsp;为了按照其他方式而非字母表顺序进行数组排序，必须给 sort（）方法传递一个比较函数。该函数决定了它的两个参数在排好序的数组中的先后顺序。假设第一个参数应该在前，比较函数应该返回一个小于 0 的数值。反之，假设第一个参数应该在后，函数应该返回一个大于 0 的数值。并且，假设两个值相等（也就是说，它们的顺序无关紧要），函数应该返回 0。因此，例如，用数值大小而非字母表顺序进行数组排序，代码如下：  ```js var a=[33，4，1111，222]； a.sort（）；//字母表顺序：1111，222，33，4 a.sort（function（a，b）{//数值顺序：4，33，222，1111         return a-b；//根据顺序，返回负数、0、正数         }）； a.sort（function（a，b）{return b-a}）;//数值大小降序 ```  &emsp;&emsp;另外一个数组元素排序的例子，也许需要对一个字符串数组执行不区分大小写的字母表排序，比较函数首先将参数都转化为小写字符串（使用 toLowerCase（）方法），再开始比较：  ```js a=[\'ant\'，\'Bug\'，\'cat\'，\'Dog\'] a.sort（）；/区分大小写的排序：[\'Bug\'，\'Dog\'，\'ant\'，cat\'] a.sort（function（s，t）{//不区分大小写的排序             var a = s.tolowerCase（）；             var b=t.tolowerCase（）；             if（a<b）return-1；             if（a>b）return 1；             return o；         }）；//=>I\'ant\'，Bug\'，\'cat\'，0og\'] ```  #### concat()连接数组  &emsp;&emsp;Array.concat（）方法创建并返回一个新数组，它的元素包括调用 concat（）的原始数组的元素和 concat（）的每个参数。如果这些参数中的任何一个自身是数组，则连接的是数组的元素，而非数组本身。但要注意，concat（）不会递归扁平化数组的数组。concat（）也不会修改调用的数组。下面有一些示例：  ```js var a=[1，2，3]； a.concat（4，5）//返回[1，2，3，4，5] a.concat（[4，5]）；//返回[1，2，3，4，5] a.concat（[4，5]，[6，7]）//返回[1，2，3，4，5，6，7] a.concat（4，[5，[6，7]]）//返回[1，2，3，4，5，[6，7]] ```  #### slice()截取指定元素  &emsp;&emsp;Array.slice（）方法返回指定数组的一个片段或子数组。它的两个参数分别指定了片段的开始和结束的位置。返回的数组包含第一个参数指定的位置和所有到但不含第二个参数指定的位置之间的所有数组元素。   &emsp;&emsp;如果只指定一个参数，返回的数组将包含从开始位置到数组结尾的所有元素。如参数中出现负数，它表示相对于数组中最后一个元素的位置。例如，参数-1 指定了最后一个元素，而-3 指定了倒数第三个元素。注意，slice（）不会修改调用的数组。下面有一些示例：  ```js var a=[1，2，3，4，5]； a.slice（o，3）；//返回[1，2，3] a.slice（3）；//返回[4，5] a.slice（1，-1）；//返回[2，3，4] a.slice（-3，-2）；//返回[3] ```  #### splice()插入或删除指定元素  &emsp;&emsp;Array.splice（）方法是在数组中插入或删除元素的通用方法。不同于 slice（）和 concat（），splice（）会修改调用的数组。   &emsp;&emsp;splice（）能够从数组中删除元素、插入元素到数组中或者同时完成这两种操作。在插入或删除点之后的数组元素会根据需要增加或减小它们的索引值，因此数组的其他部分仍然保持连续的。   &emsp;&emsp;splice（）的第一个参数指定了插入和（或）删除的起始位置。第二个参数指定了应该从数组中删除的元素的个数。如果省略第二个参数，从起始点开始到数组结尾的所有元素都将被删除。splice（）返回一个由删除元素组成的数组，或者如果没有删除元素就返回一个空数组。  ```js var a=[1，2，3，4，5，6，7，8]； a.splice（4）；//返回[5，6，7，8]；a是[1，2，3，4] a.splice（1，2）；//返回[2，3]；a是[1，4] a.splice（1，1）；//返回[4]；a是[1] ```  &emsp;&emsp;splice（）的前两个参数指定了需要删除的数组元素。紧随其后的任意个数的参数指定了需要插入到数组中的元素，从第一个参数指定的位置开始插入。  ```js var a=[1，2，3，4，5]； a.splice（2，0，\'a\'，\'b\'）；//返回[]；a是[1，2，a\'，\'b\'，3，4，5] a.splice（2，2，[1，2]，3）；//返回[\'a’，\'b]；a是[1，2，[1，2]，3，3，4，5] ```  &emsp;&emsp;注意，区别于 concat（），splice（）会插入数组本身而非数组的元素。  #### push（）和 pop（）数组尾部的插入或删除  &emsp;&emsp;push（）和 pop（）方法允许将数组当做栈来使用。push（）方法在数组的尾部添加一个或多个元素，并返回数组新的长度。   &emsp;&emsp;pop（）方法则相反：它删除数组的最后一个元素，减小数组长度并返回它删除的值。注意，两个方法都修改并替换原始数组而非生成一个修改版的新数组。组合使用 push（）和 pop（）能够用 JavaScript 数组实现先进后出的栈。例如：  ```js var stack=[]；//stack:[] stack.push（1，2）；//stack:[1，2]返回2 stack.pop（）；//stack:[1]返回2 stack.push（3）；//stack:[1，3]返回2 stack.pop（）；//stack:[1]返回3 stack.push（[4，5]）；//stack:[1，[4，5]]返回2 stack.pop（）//stack:[1]返回[4，5] stack.pop（）；//stack:[]返回1 ```  #### unshift（）和 shift（）数组头部的插入或删除  &emsp;&emsp;unshift（）在数组的头部添加一个或多个元素，并将已存在的元素移动到更高索引的位置来获得足够的空间，最后返回数组新的长度。   &emsp;&emsp;shift（）删除数组的第一个元素并将其返回，然后把所有随后的元素下移一个位置来填补数组头部的空缺。  ```js var a=[]；//a:[] a.unshift（1）；//a:[1]返回：1 a.unshift（22）；//a:[22，1]返回：2 a.shift（）；//a:[1]返回：22 a.unshift（3，[4，5]）；//a:[3，[4，5]，1]返回：3 a.shift（）；//a:[[4，5]，1]返回：3 a.shift（）；//a:[1]返回：[4，5] a.shift（）；//a:[]返回：1 ```  &emsp;&emsp;注意，当使用多个参数调用 unshift（）时它的行为令人惊讶。参数是一次性插入的（就像 splice（）方法）而非一次一个地插入。这意味着最终的数组中插入的元素的顺序和它们在参数列表中的顺序一致。而假如元素是一次一个地插入，它们的顺序应该是反过来的。  #### toString（）和 toLocaleString（）  &emsp;&emsp;数组和其他 JavaScript 对象一样拥有 toString（）方法。针对数组，该方法将其每个元素转化为字符串（如有必要将调用元素的 toString（）方法）并且输出用逗号分隔的字符串列表。注意，输出不包括方括号或其他任何形式的包裹数组值的分隔符。例如：  ```js [1，2，3].toString（）//生成‘1，2，3’ ["a"，"b"，"c"].toString（）//生成‘a，b，c\' [1，[2，\'c\']].tostring（）//生成’1，2，c\' ```  &emsp;&emsp;注意，这里与不使用任何参数调用 join（）方法返回的字符串是一样的。   &emsp;&emsp;toLocaleString（）是 toString（）方法的本地化版本。它调用元素的 toLocaleString（）方法将每个数组元素转化为字符串，并且使用本地化（和自定义实现的）分隔符将这些字符串连接起来生成最终的字符串。  ### ECMAScript 5  &emsp;&emsp;在开始详细介绍之前，很有必要对 ECMAScript5 中的数组方法做一个概述。首先，大多数方法的第一个参数接收一个函数，并且对数组的每个元素（或一些元素）调用一次该函数。如果是稀疏数组，对不存在的元素不调用传递的函数。   &emsp;&emsp;在大多数情况下，调用提供的函数使用三个参数：数组元素、元素的索引和数组本身。通常，只需要第一个参数值，可以忽略后两个参数。   &emsp;&emsp;大多数 ECMAScript5 数组方法的第一个参数是一个函数，第二个参数是可选的。如果有第二个参数，则调用的函数被看做是第二个参数的方法。也就是说，在调用函数时传递进去的第二个参数作为它的 this 关键字的值来使用。被调用的函数的返回值非常重要，但是不同的方法处理返回值的方式也不一样。   &emsp;&emsp;ECMAScript5 中的数组方法都不会修改它们调用的原始数组。当然，传递给这些方法的函数是可以修改这些数组的。  #### forEach()数组遍历  &emsp;&emsp;forEach（）方法从头至尾遍历数组，为每个元素调用指定的函数。如上所述，传递的函数作为 forEach（）的第一个参数。然后 forEach（）使用三个参数调用该函数：数组元素、元素的索引和数组本身。如果只关心数组元素的值，可以编写只有一个参数的函数—一额外的参数将忽略：  ```js var data=[1，2，3，4，5]；//要求和的数组 //计算数组元素的和值 var sum=0；//初始为0 data.forEach（function（value）{ sum += value；}）；//将每个值累加到sum上 sum//=>15 //每个数组元素的值自加1 data.forEach（function（v，i，a）{ a[i]=v+1；}）； data//=>[2，3，4，5，6] ```  &emsp;&emsp;注意，forEach（）无法在所有元素都传递给调用的函数之前终止遍历。也就是说，没有像 for 循环中使用的相应的 break 语句。如果要提前终止，必须把 forEach（）方法放在一个 try 块中，并能抛出一个异常。如果 forEach（）调用的函数抛出 foreach.break 异常，循环会提前终止：  ```js function foreach(a,f,t){     try {a.forEach(f,t);}     catch(e){         if(e===foreach. break) return;         else throw e;     } foreach.break=new Error("StopIteration"); ```  #### map()遍历并返回新数组  &emsp;&emsp;map（）方法将调用的数组的每个元素传递给指定的函数，并返回一个数组，它包含该函数的返回值，例加。  ```js a=[1，2，3]； b=a.map（function（x）{return x*x；}）；//b是[1，4，9] ```  &emsp;&emsp;传递给 map（）的函数的调用方式和传递给 forEach（）的函数的调用方式一样。但传递给 map（）的函数应该有返回值。   &emsp;&emsp;注意，map（）返回的是新数组：它不修改调用的数组。如果是稀疏数组，返回的也是相同方式的稀疏数组：它具有相同的长度，相同的缺失元素。  #### filter()遍历并返回运算为 true 的元素数组  &emsp;&emsp;fliter（）方法返回的数组元素是调用的数组的一个子集。传递的函数是用来逻辑判定的：该函数返回 true 或 false。调用判定函数就像调用 forEach（）和 map（）一样。如果返回值为 true 或能转化为 true 的值，那么传递给判定函数的元素就是这个子集的成员，它将被添加到一个作为返回值的数组中。  ```js a=[5，4，3，2，1]； smallvalues =a.filter（function（x）{ return x<3}）；//[2，1] everyother=a.filter（function（x，i）{return i%2==0 }）；//[5，3，1] ```  &emsp;&emsp;注意，filter（）会跳过稀疏数组中缺少的元素，它的返回数组总是稠密的。为了压缩稀疏数组的空缺，代码如下：  ```js var dense=sparse.filter（function（）{ return true；}）； ```  &emsp;&emsp;甚至，压缩空缺并删除 undefined 和 null 元素，可以这样使用 filter（）：  ```js a=a.filter（function（x）{return x!==undefined 8& x!=null；}）； ```  #### every()和 some()遍历并判断元素返回 true 或 false  &emsp;&emsp;every（）和 some（）方法是数组的逻辑判定：它们对数组元素应用指定的函数进行判定，返回 true 或 false。   &emsp;&emsp;every（）方法就像数学中的“针对所有”的量词 V：当且仅当针对数组中的所有元素调用判定函数都返回 true，它才返回 true：  ```js a=[1，2，3，4，5]； a.every（function（x）{return x<10；}）//=>true：所有的值<10 a.every（function（x）{ returnx%2===0；}）//=>false：不是所有的值都是偶数 ```  &emsp;&emsp;some（）方法就像数学中的“存在”的量词：当数组中至少有一个元素调用判定函数返回 true，它就返回 true；并且当且仅当数值中的所有元素调用判定函数都返回 false，它才返回 false：  ```js a=[1，2，3，4，5]； a.some（function（x）{ return x%2===0；}）//=>true:a含有偶数值 a.some（isNaN）//=>false:a不包含非数值元素 ```  &emsp;&emsp;注意，一旦 every（）和 some（）确认该返回什么值它们就会停止遍历数组元素。some（）在判定函数第一次返回 true 后就返回 true，但如果判定函数一直返回 false，它将会遍历整个数组。every（）恰好相反：它在判定函数第一次返回 false 后就返回 false，但如果判定函数一直返回 true，它将会遍历整个数组。   &emsp;&emsp;注意，根据数学上的惯例，在空数组上调用时，every（）返回 true，some（）返回 false。  #### reduce()和 reduceRight()遍历元素进行组合并生成单个值  ##### reduce()  &emsp;&emsp;reduce（）和 reduceRight（）方法使用指定的函数将数组元素进行组合，生成单个值。这在函数式编程中是常见的操作，也可以称为“注入”和“折叠”。举例说明它是如何工作的：  ```js var a=[1，2，3，4，5] var sum=a.reduce（function（x，y）{ return x+y}，0）；//数组求和 var product=a.reduce（function（x，y）{return x*y}，1）；//数组求积 var max=a.reduce（function（x，y）{ return（x>y）?x:y；}）；//求最大值 ```  &emsp;&emsp;reduce（）需要两个参数。第一个是执行化简操作的函数。化简函数的任务就是用某种方法把两个值组合或化简为一个值，并返回化简后的值。在上述例子中，函数通过加法、乘法或取最大值的方法组合两个值。第二个（可选）的参数是一个传递给函数的初始值。   &emsp;&emsp;可能已经注意到了，上面第三次调用 reduce（）时只有一个参数：没有指定初始值。当不指定初始值调用 reduce（）时，它将使用数组的第一个元素作为其初始值。这意味着第一次调用化简函数就使用了第一个和第二个数组元素作为其第一个和第二个参数。在上面求和与求积的例子中，可以省略初始值参数。   &emsp;&emsp;reduce（）使用的函数与 forEach（）和 map（）使用的函数不同。比较熟悉的是，数组元素、元素的索引和数组本身将作为第 2~4 个参数传递给函数。第一个参数是到目前为止的化简操作累积的结果。   &emsp;&emsp;第一次调用函数时，第一个参数是一个初始值，它就是传递给 reduce（）的第二个参数。在接下来的调用中，这个值就是上一次化简函数的返回值。   &emsp;&emsp;在空数组上，不带初始值参数调用 reduce（）将导致类型错误异常。如果调用它的时候只有一个值——数组只有一个元素并且没有指定初始值，或者有一个空数组并且指定一个初始值—reduce（）只是简单地返回那个值而不会调用化简函数。  ##### reduceRight()  &emsp;&emsp;reduceRight（）的工作原理和 reduce（）一样，不同的是它按照数组索引从高到低（从右到左）处理数组，而不是从低到高。如果化简操作的优先顺序是从右到左，你可能想使用它，例如：  ```js var a=[2，3，4] //计算2 ^（3^4）。乘方操作的优先顺序是从右到左 var big=a.reduceRight（function（accumulator，value）{                         return Math.pow（value，accumulator）；                     }）； ```  &emsp;&emsp;注意，reduce（）和 reduceRight（）都能接收一个可选的参数，它指定了化简函数调用时的 this 关键字的值。可选的初始值参数仍然需要占一个位置。如果想让化简函数作为一个特殊对象的方法调用，请参看 Function.bind（）方法。   &emsp;&emsp;为了简单起见，到目前位置所展示的例子都是数值的，但数学计算不是 reduce（）和 reduceRight（）的唯一意图。  #### indexOf()和 lastindexOf()搜索数组返回索引  &emsp;&emsp;indexOf（）和 lastIndexOf（）搜索整个数组中具有给定值的元素，返回找到的第一个元素的索引或者如果没有找到就返回-1。indexOf（）从头至尾搜索，而 lastIndexOf（）则反向搜索。  ```js a=[o，1，2，1，0]； a.indexOf（1）//=>1：a[1]是1 a.lastIndexOf（1）//=>3：a[3]是1 a.indexOf（3）//=>-1：没有值为3的元素 ```  &emsp;&emsp;不同于本节描述的其他方法，indexOf（）和 1astIndexOf（）方法不接收一个函数作为其参数。第一个参数是需要搜索的值，第二个参数是可选的：它指定数组中的一个索引，从那里开始搜索。如果省略该参数，indexOf（）从头开始搜索，而 lastIndexOf（）从末尾开始搜索。第二个参数也可以是负数，它代表相对数组末尾的偏移量，例如，-1 指定数组的最后一个元素。   &emsp;&emsp;如下函数在一个数组中搜索指定的值并返回包含所有匹配的数组索引的一个数组。它展示了如何运用 indexof（）的第二个参数来查找除了第一个以外匹配的值。  ```js //在数组中查找所有出现的x，并返回一个包含匹配索引的数组 function findall（a，x）{     var results=[]，//将会返回的数组     len=a.length，//待搜索数组的长度     pos=0；//开始搜索的位置     while（pos<len）{//循环搜索多个元素..         pos=a.indexoOf（x，pos）；//搜索     if（pos===-1）break；//未找到，就完成搜索         results.push（pos）；//否则，在数组中存储索引         pos=pos+1；//并从下一个位置开始搜索         return results；//返回包含索引的数组     } } ```  ## 数组类型(掌握)  &emsp;&emsp;我们在本章中到处都可以看见数组是具有特殊行为的对象。给定一个未知的对象，判定它是否为数组通常非常有用。在 ECMAScript5 中，可以使用 Array.isArray（）函数来做这件事情：  ```js Array.isArray([]); //=>true Array.isArray({}); //=>false ```  &emsp;&emsp;instanceof 操作符只能用于简单的情形：使用 instanceof 的问题是在 Web 浏览器中有可能有多个窗口或窗体（frame）存在。每个窗口都有自己的 JavaScript 环境，有自己的全局对象。并且，每个全局对象有自己的一组构造函数。因此一个窗体中的对象将不可能是另外窗体中的构造函数的实例。窗体之间的混淆不常发生，但这个问题足已证明 instanceof 操作符不能视为一个可靠的数组检测方法。  ```js [] instanceof   Array(     //=>true     {}   ) instanceof   Array; //=>false ```  &emsp;&emsp;解决方案是检查对象的类属性。对数组而言该属性的值总是“Array”，因此在 ECMAScript3 中 isArray（）函数的代码可以这样书写：  ```js var isArray=Function.isArray 1| function（o）{     return typeof o==="object"8&     Object.prototype.tostring.call（o）==="[Object Array]"； }； ```  &emsp;&emsp;实际上，此处类属性的检测就是 ECMAScript5 中 Array.isArray（）函数所做的事情。获得对象类属性的技术使用了 Object.prototype.toString（）方法。  ## 类数组对象(掌握)  &emsp;&emsp;一种常常完全合理的看法把拥有一个数值 length 属性和对应非负整数属性的对象看做一种类型的数组。实践中这些“类数组”对象实际上偶尔出现，虽然不能在它们之上直接调用数组方法或者期望 length 属性有什么特殊的行为，但是仍然可以用针对真正数组遍历的代码来遍历它们。结论就是很多数组算法针对类数组对象工作得很好，就像针对真正的数组一样。如果算法把数组看成只读的或者如果它们至少保持数组长度不变，也尤其是这种情况。   &emsp;&emsp;以下代码为一个常规对象增加了一些属性使其变成类数组对象，然后遍历生成的伪数组的“元素”：  ```js var a={}；//从一个常规空对象开始 //添加一些属性，称为“类数组" var i=0； while（i<10）{     a[i]=i*i；     i++； } a.length=i； //现在，当做真正的数组遍历它 var total=0； for（varj=0；j<a.length；j++）     total+=a[j]； ```  &emsp;&emsp;Arguments 对象就是一个类数组对象。在客户端 JavaScript 中，一些 DOM 方法（如 document.getElementsByTagName（））也返回类数组对象。下面有一个函数可以用来检测类数组对象：  ```js //判定。是否是一个类数组对象 //字符串和函数有1ength属性，但是它们 //可以用typeof检测将其排除。在客户端Java5cript中，DOM文本节点 //也有1ength属性，需要用额外判断o.nodeType！=3将其排除 function isArraylike（o）{     if（o8&//o非null、undefined等         typeof o==="object"8&//o是对象isFinite（o.length）8&//o.1ength是有限数值         o.1ength>=0&&//o.length为非负值         o.1ength===Math.floor（o.1ength）&&//o.1ength是整数         o.length<4294967296）//o.length<232         return true；//o是类数组对象     else         return false；//否则它不是 } ```  &emsp;&emsp;类似上述的类数组对象的检测方法针对字符串常常返回 false——它们通常最好当做字符串处理，而非数组。   &emsp;&emsp;JavaScript 数组方法是特意定义为通用的，因此它们不仅应用在真正的数组而且在类数组对象上都能正确工作。在 ECMAScript5 中，所有的数组方法都是通用的。在 ECMAScript3 中，除了 toString（）和 tolocaleString（）以外的所有方法也是通用的。（concat（）方法是一个特例：虽然可以用在类数组对象上，但它没有将那个对象扩充进返回的数组中。）既然类数组对象没有继承自 Array.prototype，那就不能在它们上面直接调用数组方法。尽管如此，可以间接地使用 Function.cal1 方法调用：  ```js var a={"o"："a"，“1"："b"，"2"："c"，length：3}；//类数组对象 Array.prototype.join.call（a，"+"）//=>"a+b+c" Array.prototype.slice.call（a，0）//=>["a"，"b"，"c"]：真正数组的副本 Array.prototype.map.call（a，function（x）{                     return x.toUpperCase（）； }）//=>["A"，"B"，"C"]： ```  &emsp;&emsp;ECMAScript 5 数组方法是在 Firefox1.5 中引入的。由于它们的写法的一般性，Firefox 还将这些方法的版本在 Array 构造函数上直接定义为函数。使用这些方法定义的版本，上述例子就可以这样重写：  ```js var a={"o"："a"，“1"："b"，“2"："c"，length：3}；//类数组对象 Array.join（a，"+"） Array.slice（a，0） Array.map（a，function（x）{ return x.toUpperCase（）；}） ```  &emsp;&emsp;当用在类数组对象上时，数组方法的静态函数版本非常有用。但既然它们不是标准的，不能期望它们在所有的浏览器中都有定义。可以这样书写代码来保证使用它们之前是存在的：  ```js Array.join =   Array.join ||   function(a, sep) {     return Array.prototype.join.call(a, sep);   }; Array.slice =   Array.slice ||   function(a, from, to) {     return Array.prototype.slice.call(a, from, to);   }; Array.map =   Array.map ||   function(a, f, thisArg) {     return Array.prototype.map.call(a, f, thisArg);   }; ```  ## 作为数组的字符串(掌握)  &emsp;&emsp;在 ECMAScript5（在众多最近的浏览器实现——包括 IE8——早于 ECMAScript 5）中，字符串的行为类似于只读的数组。除了用 charAt（）方法来访问单个的字符以外，还可以使用方括号：  ```js var s = \'test\'; s.charAt(o); //=>"t" s[1]; //=>"e" ```  &emsp;&emsp;可索引的字符串的最大的好处就是简单，用方括号代替了 charAt（）调用，这样更加简洁、可读并且可能更高效。不仅如此，字符串的行为类似于数组的事实使得通用的数组方法可以应用到字符串上。例如：  ```js s="JavaScript" Array.prototype.join.call（s，""）//=）"JavaScript" Array.prototype.filter.call（s，//过滤字符串中的字符     function（x）{         return x.match（/[^aeiou]/）；//只匹配非元音字母     }）.join（""）//=）"jvScrpt" ```  &emsp;&emsp;请记住，字符串是不可变值，故当把它们作为数组看待时，它们是只读的。如 push（）、sort（）、reverse（）和 splice（）等数组方法会修改数组，它们在字符串上是无效的。不仅如此，使用数组方法来修改字符串会导致错误：出错的时候没有提示。 '},{title:"【读书笔记】《JavaScript权威指南》第6章对象",path:"/posts/%E3%80%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%91%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B%E7%AC%AC6%E7%AB%A0%E5%AF%B9%E8%B1%A1.html",strippedContent:' ## 对象简述（了解）  &emsp;&emsp;对象是 JavaScript 的基本数据类型。对象是一种复合值：它将很多值（原始值或者其他对象）聚合在一起，可通过名字访问这些值。对象也可看做是属性的无序集合，每个属性都是一个名/值对。属性名是字符串，因此我们可以把对象看成是从字符串到值的映射。这种基本数据结构还有很多种叫法，有些我们已然非常熟悉，比如“散列”（hash）、 “散列表”（hashtable）、“字典”（dictionary）、“关联数组”（associative array）。   &emsp;&emsp;然而对象不仅仅是字符串到值的映射，除了可以保持自有的属性，JavaScript 对象还可以从一个称为原型的对象继承属性。对象的方法通常是继承的属性。这种“原型式继承”（prototypal inheritance）是 JavaScript 的核心特征。   &emsp;&emsp;属性包括名字和值。属性名可以是包含空字符串在内的任意字符串，但对象中不能存在两个同名的属性。值可以是任意 JavaScript 值，或者（在 ECMAScript5 中）可以是一个 getter 或 setter 函数（或两者都有）。   &emsp;&emsp;除了名字和值之外，每个属性还有一些与之相关的值，称为“属性特性”（property attribute）:  - 可写（writable attribute），表明是否可以设置该属性的值。 - 可枚举（enumerable attribute），表明是否可以通过 for/in 循环返回该属性。 - 可配置（configurable attribute），表明是否可以删除或修改该属性。  &emsp;&emsp;在 ECMAScript5 之前，通过代码给对象创建的所有属性都是可写的、可枚举的和可配置的。在 ECMAScript5 中则可以对这些特性加以配置。   &emsp;&emsp;除了包含属性之外，每个对象还拥有三个相关的对象特性（object attribute）：  - 对象的原型（prototype）指向另外一个对象，本对象的属性继承自它的原型对象。 - 对象的类（class）是一个标识对象类型的字符串。 - 对象的扩展标记（extensible flag）指明了（在 ECMAScript5 中）是否可以向该对象添加新属性。  &emsp;&emsp;最后，我们用下面这些术语来对三类 JavaScript 对象和两类属性作区分：  - 内置对象（native object）是由 ECMAScript 规范定义的对象或类。例如，数组、函数、日期和正则表达式都是内置对象。 - 宿主对象（host object）是由 JavaScript 解释器所嵌入的宿主环境（比如 Web 浏览器）定义的。客户端 JavaScript 中表示网页结构的 HTMLElement 对象均是宿主对象。既然宿主环境定义的方法可以当成普通的 JavaScript 函数对象，那么宿主对象也可以当成内置对象。 - 自定义对象（user-defined object）是由运行中的 JavaScript 代码创建的对象。 - 自有属性（own property）是直接在对象中定义的属性。 - 继承属性（inherited property）是在对象的原型对象中定义的属性。  ## 创建对象（掌握）  ### 对象直接量  &emsp;&emsp;对象直接量是由若干名/值对组成的映射表，名/值对中间用冒号分隔，名/值对之间用逗号分隔，整个映射表用花括号括起来。属性名可以是 JavaScript 标识符也可以是字符串直接量（包括空字符串）。属性的值可以是任意类型的 JavaScript 表达式。  ```js var empty={}；//没有任何属性的对象 var point={x：0，y：0}；//两个属性 var pointz={x:point.x，y:point.y+1}；//更复杂的值 var book={     "main title"："Javascript"，//属性名字里有空格，必须用字符串表示     \'sub-title\'："The Definitive Guide"，//属性名字里有连字符，必须用字符串表示     "for"："all audiences"，//"for"是保留字，因此必须用引号     author:{         firstname:"David"，//注意，这里的属性名都没有引号         surname:"Flanagan"     }  }； ```  &emsp;&emsp;在 ECMAScript5（以及 ECMAScript3 的一些实现）中，保留字可以用做不带引号的属性名。然而对于 ECMAScript3 来说，使用保留字作为属性名必须使用引号引起来。   &emsp;&emsp;在 ECMAScript5 中，对象直接量中的最后一个属性后的逗号将忽略，且在 ECMAScript3 的大部分实现中也可以忽略这个逗号，但在 IE 中则报错。   &emsp;&emsp;对象直接量是一个表达式，这个表达式的每次运算都创建并初始化一个新的对象。每次计算对象直接量的时候，也都会计算它的每个属性的值。也就是说，如果在一个重复调用的函数中的循环体内使用了对象直接量，它将创建很多新对象，并且每次创建的对象的属性值也有可能不同。  ### 通过 new 创建对象  &emsp;&emsp;new 运算符创建并初始化一个新对象。关键字 new 后跟随一个函数调用。这里的函数称做构造函数（constructor），构造函数用以初始化一个新创建的对象。JavaScript 语言核心中的原始类型都包含内置构造函数。  ```js var o=new Object（）；//创建一个空对象，和{}一样 var a= new Array（）；//创建一个空数组，和[]一样 var d=new Date（）；//创建一个表示当前时间的Date对象 var r=new RegExp（"js"）；//创建一个可以进行模式匹配的EegExp对象 ```  ### Object.create()  #### 原型  &emsp;&emsp;在讲述第三种对象创建技术之前，我们应当首先解释一下原型。每一个 JavaScript 对象（nu11 除外）都和另一个对象相关联。“另一个”对象就是我们熟知的原型，每一个对象都从原型继承属性。   &emsp;&emsp;所有通过对象直接量创建的对象都具有同一个原型对象，并可以通过 JavaScript 代码 object.prototype 获得对原型对象的引用。   &emsp;&emsp;通过关键字 new 和构造函数调用创建的对象的原型就是构造函数的 prototype 属性的值。因此，同使用{}创建对象一样，通过 new Object（）创建的对象也继承自 object.prototype。同样，通过 new Array（）创建的对象的原型就是 Array.prototype，通过 new Date（）创建的对象的原型就是 Date.prototype。   &emsp;&emsp;没有原型的对象为数不多，Object.prototype 就是其中之一。它不继承任何属性。其他原型对象都是普通对象，普通对象都具有原型。   &emsp;&emsp;所有的内置构造函数（以及大部分自定义的构造函数）都具有一个继承自 object.prototype 的原型。例如，Date.prototype 的属性继承自 Object.prototype，因此由 new Date（）创建的 Date 对象的属性同时继承自 Date.prototype 和 Object.prototype。这一系列链接的原型对象就是所谓的“原型链”（prototype chain）。  #### Object.create（）  &emsp;&emsp;ECMAScript 5 定义了一个名为 Object.create（）的方法，它创建一个新对象，其中第一个参数是这个对象的原型。Object.create（）提供第二个可选参数，用以对对象的属性进行进一步描述。后面会详细讲述第二个参数。   &emsp;&emsp;Object.create（）是一个静态函数，而不是提供给某个对象调用的方法。使用它的方法很简单，只须传入所需的原型对象即可：  ```js var o1=Object.create（{x：1，y：2}）；//o1继承了属性x和y ```  &emsp;&emsp;可以通过传入参数 nu11 来创建一个没有原型的新对象，但通过这种方式创建的对象不会继承任何东西，甚至不包括基础方法，比如 toString（），也就是说，它将不能和“+” 运算符一起正常工作。   &emsp;&emsp;如果想创建一个普通的空对象（比如通过{}或 new 0bject（）创建的对象），需要传入 Object.prototype：  ```js var o3=Object.create（Object.prototype）；//o3和{}和new Object（）一样 ```  &emsp;&emsp;通过原型继承创建一个新对象  ```js //1inherit（）返回了一个继承自原型对象p的属性的新对象 //这里使用ECMAScript 5中的Object.create（）函数（如果存在的话） //如果不存在Object.create（），则退化使用其他方法 function inherit（p）{     if（p==null）throw TypeError（）；//p是一个对象，但不能是null     if（Object.create）//如果0bject.create（）存在         return Object.create（p）；//直接使用它     var t=typeof p；//否则进行进一步检测     if（t l=="object"&&t！=="function"）throw TypeError（）；     function f（）{}；//定义一个空构造函数     f.prototype=p；//将其原型属性设置为p     return new f（）；/使用f（）创建p的继承对象 } ```  &emsp;&emsp;注意，inherit（）并不能完全代替 0bject.create（），它不能通过传入 nul1 原型来创建对象，而且不能接收可选的第二个参数。   &emsp;&emsp;inherit（）函数的其中一个用途就是防止库函数无意间（非恶意地）修改那些不受你控制的对象。当函数读取继承对象的属性时，实际上读取的是继承来的值。如果给继承对象的属性赋值，则这些属性只会影响这个继承对象自身，而不是原始对象：  ## 属性的查询和设置（掌握）  &emsp;&emsp;可以通过点（.）或方括号（[]）运算符来获取属性的值,当使用方括号时，我们说方括号内的表达式必须返回字符串。其实更严格地讲，表达式必须返回字符串或返回一个可以转换为字符串的值。  ### 作为关联数组的对象.  ```js object.property; object[\'property\']; ```  &emsp;&emsp;使用方括号和一个字符串，看起来更像数组，只是这个数组元素是通过字符串索引而不是数字索引。这种数组就是我们所说的关联数组（associative array），也称做散列、映射或字典（dictionary）。JavaScript 对象都是关联数组。  ### 继承  &emsp;&emsp;JavaScript 对象具有“自有属性”（own property），也有一些属性是从原型对象继承而来的。假设要查询对象 o 的属性 x，如果 o 中不存在 x，那么将会继续在 o 的原型对象中查询属性 x。如果原型对象中也没有 x，但这个原型对象也有原型，那么继续在这个原型对象的原型上执行查询，直到找到 x 或者查找到一个原型是 nul1 的对象为止。可以看到，对象的原型属性构成了一个“链”，通过这个“链”可以实现属性的继承。   &emsp;&emsp;在 JavaScript 中，只有在查询属性时才会体会到继承的存在，而设置属性则和继承无关，这是 JavaScript 的一个重要特性，该特性让程序员可以有选择地覆盖（override）继承的属性。   &emsp;&emsp;属性赋值要么失败，要么创建一个属性，要么在原始对象中设置属性，但有一个例外，如果 o 继承自属性 x，而这个属性是一个具有 setter 方法的 accessor 属性，那么这时将调用 setter 方法而不是给 o 创建一个属性 x。需要注意的是，setter 方法是由对象 o 调用的，而不是定义这个属性的原型对象调用的。因此如果 setter 方法定义任意属性，这个操作只是针对 o 本身，并不会修改原型链。  ### 属性访问错误  &emsp;&emsp;查询一个不存在的属性并不会报错，如果在对象 0 自身的属性或继承的属性中均未找到属性 x，属性访问表达式 o.x 返回 undefined。但是，如果对象不存在，那么试图查询这个不存在的对象的属性就会报错。nu11 和 undefined 值都没有属性，因此查询这些值的属性会报错。   &emsp;&emsp;当然，给 nu11 和 undefined 设置属性也会报类型错误。给其他值设置属性也不总是成功，有一些属性是只读的，不能重新赋值，有一些对象不允许新增属性，但让人颇感意外的是，这些设置属性的失败操作不会报错：这是一个历史遗留问题，这个 bug 在 ECMAScript5 的严格模式中已经修复。在严格模式中，任何失败的属性设置操作都会抛出一个类型错误异常。  ```js //内置构造函数的原型是只读的 Object.prototype=o；//赋值失败，但没报错，Object.prototype没有修改 ```  ## 删除属性（掌握）  &emsp;&emsp;delete 运算符可以删除对象的属性。它的操作数应当是一个属性访问表达式。让人感到意外的是，delete 只是断开属性和宿主对象的联系，而不会去操作属性中的属性：   &emsp;&emsp;a={p:{x：1}}；b=a.p；delete a.p；执行这段代码之后 b.x 的值依然是 1。由于已经删除的属性的引用依然存在，因此在 JavaScript 的某些实现中，可能因为这种不严谨的代码而造成内存泄漏。所以在销毁对象的时候，要遍历属性中的属性，依次删除。   &emsp;&emsp;delete 运算符只能删除自有属性，不能删除继承属性（要删除继承属性必须从定义这个属性的原型对象上删除它，而且这会影响到所有继承自这个原型的对象）。   &emsp;&emsp;当 delete 表达式删除成功或没有任何副作用（比如删除不存在的属性）时，它返回 true。如果 delete 后不是一个属性访问表达式，delete 同样返回 true：  ```js 0={x：1}；//o有一个属性x，并继承属性tostring delete o.x；//删除x，返回true delete o.x；//什么都没做（x已经不存在了），返回true delete o.toString；//什么也没做（tostring是继承来的），返回true delete 1；//无意义，返回true ```  &emsp;&emsp;delete 不能删除那些可配置性为 fa1se 的属性（尽管可以删除不可扩展对象的可配置属性）。某些内置对象的属性是不可配置的，比如通过变量声明和函数声明创建的全局对象的属性。在严格模式中，删除一个不可配置属性会报一个类型错误。在非严格模式中（以及 ECMAScript3 中），在这些情况下的 delete 操作会返回 false：  ```js delete object.prototype；//不能删除，属性是不可配置的 Var x=1；//声明一个全局变量 delete this.x；//不能删除这个属性 function f（）{}//声明一个全局函数 delete this.f；//也不能删除全局函数 ```  &emsp;&emsp;在严格模式中，delete 后跟随一个非法的操作数（比如 x），则会报一个语法错误，因此必须显式指定对象及其属性。  ```js this.x=1；//创建一个可配置的全局属性（没有用var） delete x；//将它删除，在严格模式下报错 ```  ## 检测属性（掌握）  &emsp;&emsp;JavaScript 对象可以看做属性的集合，我们经常会检测集合中成员的所属关系——判断某个属性是否存在于某个对象中。可以通过 in 运算符、hasOwnPreperty（）和 propertyIsEnumerable（）方法来完成这个工作，甚至仅通过属性查询也可以做到这一点。  ### in 运算符  &emsp;&emsp;in 运算符的左侧是属性名（字符串），右侧是对象。如果对象的自有属性或继承属性中包含这个属性则返回 true。  ```js var o={x：1} "x" in o；//true:"x“是o的属性 "y" in o；//false:"y"不是o的属性 "tostring" in o；//true:o继承toString属性 ```  ### hasOwnPreperty（）  &emsp;&emsp;对象的 hasownProperty（）方法用来检测给定的名字是否是对象的自有属性。对于继承属性它将返回 false：  ```js var o={x：1} o.hasownProperty（“x"）；//true:o有一个自有属性x o.hasownProperty（"y"）；//false:o中不存在属性y o.hasownProperty（"tostring"）；//false:toString是继承属性 ```  ### propertyIsEnumerable()  &emsp;&emsp;propertyIsEnumerable（）是 hasOwnProperty（）的增强版，只有检测到是自有属性且这个属性的可枚举性（enumerable attribute）为 true 时它才返回 true。某些内置属性是不可枚举的。通常由 JavaScript 代码创建的属性都是可枚举的，除非在 ECMAScript5 中使用一个特殊的方法来改变属性的可枚举性，随后会提到：  ```js var o=inherit（{y：2}）； o.x=1； o.propertyIsEnumerable（"x"）；//true:o有一个可枚举的自有属性x o.propertyIsEnumerable（"y"）；//false:y是继承来的 object.prototype.propertyIsEnumerable（"toString"）；//false：不可枚举 ```  &emsp;&emsp;除了使用 in 运算符之外，另一种更简便的方法是使用“l==”判断一个属性是否是 undefined：  ````js var o={x：1} o.x !==undefined；//true:o中有属性x o.y !==a undefined；//false:o中没有属性y o.toString !==undefined；//true:o继承了toString属性 ```js &emsp;&emsp;然而有一种场景只能使用in运算符而不能使用上述属性访问的方式。in可以区分不存在的属性和存在但值为undefined的属性。 ```js var o={x:undefined}//属性被显式赋值为undefined o.x！==undefined//false：属性存在，但值为undefined o. y !== undefined//false：属性不存在 "x” in o//true：属性存在 "y" in o//false：属性不存在 delete o.x；//删除了属性x “x” in o//false：属性不再存在 ````  ## 枚举属性（掌握）  ### for/in 循环  &emsp;&emsp;for/in 循环可以在循环体中遍历对象中所有可枚举的属性（包括自有属性和继承的属性），把属性名称赋值给循环变量。对象继承的内置方法不可枚举的，但在代码中给对象添加的属性都是可枚举的（除非用下文中提到的一个方法将它们转换为不可枚举的）。  ```js var o={x：1，y：2，z：3}；//三个可枚举的自有属性 o.propertyIsEnumerable（"toString"）//=>false，不可枚举 for（p in o）//遍历属性 console.log（p）；//输出x、y和z，不会输出tostring ```  &emsp;&emsp;有许多实用工具库给 0bject.prototype 添加了新的方法或属性，这些方法和属性可以被所有对象继承并使用。然而在 ECMAScript 5 标准之前，这些新添加的方法是不能定义为不可枚举的，因此它们都可以在 for/in 循环中枚举出来。为了避免这种情况，需要过滤 for/in 循环返回的属性，下面两种方式是最常见的：  ```js for（p in o）{     if（lo.hasownProperty（p））continue；//跳过继承的属性 } for（p in o）{     if（typeof o[p]==="function"）continue；//跳过方法 } ```  ### Object.keys()  &emsp;&emsp;除了 for/in 循环之外，ECMAScript5 定义了两个用以枚举属性名称的函数。第一个是 0bject.keys（），它返回一个数组，这个数组由对象中可枚举的自有属性的名称组成。  ### Object.getownPropertyNames()  &emsp;&emsp;ECMAScript 5 中第二个枚举属性的函数是 0bject.getownPropertyNames（），它和 0jbect.keys（）类似，只是它返回对象的所有自有属性的名称，而不仅仅是可枚举的属性。在 ECMAScript3 中是无法实现的类似的函数的，因为 ECMAScript3 中没有提供任何方法来获取对象不可枚举的属性。  ## 属性 getter 和 setter（掌握）  &emsp;&emsp;在 ECMAScript 5 中，属性值可以用一个或两个方法替代，这两个方法就是 getter 和 setter。由 getter 和 setter 定义的属性称做“存取器属性”（accessor property），它不同于“数据属性”（data property），数据属性只有一个简单的值。   &emsp;&emsp;当程序查询存取器属性的值时，JavaScript 调用 getter 方法（无参数）。这个方法的返回值就是属性存取表达式的值。   &emsp;&emsp;当程序设置一个存取器属性的值时，JavaScript 调用 setter 方法，将赋值表达式右侧的值当做参数传入 setter。从某种意义上讲，这个方法负责“设置”属性值。可以忽略 setter 方法的返回值。   &emsp;&emsp;和数据属性不同，存取器属性不具有可写性（writable attribute）。如果属性同时具有 getter 和 setter 方法，那么它是一个读/写属性。如果它只有 getter 方法，那么它是一个只读属性。如果它只有 setter 方法，那么它是一个只写属性（数据属性中有一些例外），读取只写属性总是返回 undefined。  ```js var o={     //普通的数据属性     data_prop:value，//存取器属性都是成对定义的函数     get accessor_prop（）{/*这里是函数体*/}，     set accessor_prop（value）{/*这里是函数体*/} }； ```  &emsp;&emsp;存取器属性定义为一个或两个和属性同名的函数，这个函数定义没有使用 function 关键字，而是使用 get 和（或）set。注意，这里没有使用冒号将属性名和函数体分隔开，但在函数体的结束和下一个方法或数据属性之间有逗号分隔。和数据属性一样，存取器属性是可以继承的。  ## 属性的特性（掌握）  &emsp;&emsp;除了包含名字和值之外，属性还包含一些标识它们可写、可枚举和可配置的特性。在 ECMAScript3 中无法设置这些特性，所有通过 ECMAScript3 的程序创建的属性都是可写的、可枚举的和可配置的，且无法对这些特性做修改。   &emsp;&emsp;可以认为一个属性包含一个名字和 4 个特性。   &emsp;&emsp;数据属性的 4 个特性分别是它的值（value）、可写性（writable）、可枚举性（enumerable）和可配置性（configurable）。   &emsp;&emsp;存取器属性不具有值（value）特性和可写性，它们的可写性是由 setter 方法存在与否决定的。因此存取器属性的 4 个特性是读取（get）、写入（set）、可枚举性和可配置性。 &emsp;&emsp;为了实现属性特性的查询和设置操作，ECMAScript5 中定义了一个名为“属性描述符”（property descriptor）的对象，这个对象代表那 4 个特性。   &emsp;&emsp;数据属性的描述符对象的属性有 value、writable、enumerable 和 configurable。存取器属性的描述符对象则用 get 属性和 set 属性代替 value 和 writable。   &emsp;&emsp;其中 writable、enumerable 和 configurable 都是布尔值，当然，get 属性和 set 属性是函数值。  ### Object.getOwnPropertyDescriptor()  #### 读取  &emsp;&emsp;通过调用 0bject.getownPropertyDescriptor（）可以获得某个对象特定属性的属性描述符：  ```js //返回{value：1，writable:true，enumerable:true，configurable:true} Object.getownPropertyDescriptor（{x：1}，"x"）； //返回{get:/*func*/，set:undefned，enumerable:true，configurable:true} Object.getownPropertyDescriptor（random，"octet"）； //对于继承属性和不存在的属性，返回undefined Object.getownPropertyDescriptor（{}，"x"）；//undefined，没有这个属性 Object.getownPropertyDescriptor（{}，"tostring"）；//undefined，继承属性 ```  &emsp;&emsp;从函数名字就可以看出，Object.getownPropertyDescriptor（）只能得到自有属性的描述符。要想获得继承属性的特性，需要遍历原型链（Object.getPrototypeof（））。  #### 设置  ##### Object.defineProperty()  &emsp;&emsp;要想设置属性的特性，或者想让新建属性具有某种特性，则需要调用 Object.definePeoperty（），传入要修改的对象、要创建或修改的属性的名称以及属性描述符对象：  ```js var o={}；//创建一个空对象 //添加一个不可枚举的数据属性x，并赋值为1 Object.defineProperty（o，"x"，{value：1，writable:true，enumerable:false，configurable:true}）； //属性是存在的，但不可枚举 o.x；//=>1 Object.keys（o）//=>[] //现在对属性x做修改，让它变为只读 Object.defineproperty（o，"x"，{writable:false}）； //试图更改这个属性的值 o.x=2；//操作失败但不报错，而在严格模式中抛出类型错误异常 o.x//=>1 //属性依然是可配置的，因此可以通过这种方式对它进行修改： Object.defineproperty（o，"x"，{value：2}）； o.x//=>2 //现在将x从数据属性修改为存取器属性 Object.defneProperty（o，"x"，{get:function（）{return o；}}）；o.x//=>0 ```  &emsp;&emsp;传入 object.defineProperty（）的属性描述符对象不必包含所有 4 个特性。对于新创建的属性来说，默认的特性值是 false 或 undefined。对于修改的已有属性来说，默认的特性值没有做任何修改。注意，这个方法要么修改已有属性要么新建自有属性，但不能修改继承属性。  ##### Object.defineProperties()  &emsp;&emsp;如果要同时修改或创建多个属性，则需要使用 0bject.defineProperties（）。第一个参数是要修改的对象，第二个参数是一个映射表，它包含要新建或修改的属性的名称，以及它们的属性描述符，例如：  ```js var p=Object. defineProperties({),{     x:{ value:1, writable: true, enumerable: true, configurable: true},     y:{ value:1, writable: true, enumerable: true, configurable: true}, r:{     get: function(){ return Math. sqrt(this.x* this.x+ this.y* this.y)},     enumerable: true,     configurable: true     } )); ```  &emsp;&emsp;对于那些不允许创建或修改的属性来说，如果用 Object.defineProperty（）和 Object.defineProperties（）对其操作（新建或修改）就会抛出类型错误异常，比如，给一个不可扩展的对象新增属性就会抛出类型错误异常。   &emsp;&emsp;下面是完整的规则，任何对 0bject.defineProperty（）或 Object.defineProperties（）违反规则的使用都会抛出类型错误异常：  - 如果对象是不可扩展的，则可以编辑已有的自有属性，但不能给它添加新属性。 - 如果属性是不可配置的，则不能修改它的可配置性和可枚举性。 - 如果存取器属性是不可配置的，则不能修改其 getter 和 setter 方法，也不能将它转换为数据属性。 - 如果数据属性是不可配置的，则不能将它转换为存取器属性。 - 如果数据属性是不可配置的，则不能将它的可写性从 false 修改为 true，但可以从 true 修改为 false。 - 如果数据属性是不可配置且不可写的，则不能修改它的值。然而可配置但不可写属性的值是可以修改的（实际上是先将它标记为可写的，然后修改它的值，最后转换为不可写的）。  &emsp;&emsp;复制属性的特性  ```js /* *给Object.prototype添加一个不可枚举的extend（）方法 *这个方法继承自调用它的对象，将作为参数传入的对象的属性一一复制 *除了值之外，也复制属性的所有特性，除非在目标对象中存在同名的属性， *参数对象的所有自有对象（包括不可枚举的属性）也会一一复制。 */ Object.defineProperty（object.prototype，     “extend"，定义Object.prototype.extend     {         writable:true，enumerable:false，//将其定义为不可枚举的         configurable:true，         value:function（o）{//值就是这个函数             //得到所有的自有属性，包括不可枚举属性             var names=Object.getownPropertyNames（o）；             //遍历它们             for（var i=o；i<names.length；i++）{             //如果属性已经存在，则跳过                 if（names[i]in this）continue；                 //获得0中的属性的描述符                 var desc=Object.getOwnPropertyDescriptor（o，names[i]）；                 //用它给this创建一个属性                 Object.defineProperty（this，names[i]，desc）；             }         }     }）； ```  ### getter 和 setter 的老式 API  &emsp;&emsp;可以通过对象直接量语法给新对象定义存取器属性，但不能查询属性的 getter 和 setter 方法或给已有的对象添加新的存取器属性。在 ECMAScript5 中，可以通过 Object.getOwnPropertyDescriptor（）和 0bject.defineproperty（）来完成这些工作。   &emsp;&emsp;在 ECMAScript5 标准被采纳之前，大多数 JavaScript 的实现（IE 浏览器除外）已经可以支持对象直接量语法中的 get 和 set 写法。这些实现提供了非标准的老式 API 用来查询和设置 getter 和 setter。这些 API 由 4 个方法组成，所有对象都拥有这些方法。 \\_lookupGetter\\_（）和\\_lookupSetter\\_（）用以返回一个命名属性的 getter 和 setter 方法。defineGetter（）和 defineSetter（）用以定义 getter 和 setter，这两个函数的第一个参数是属性名字，第二个参数是 getter 和 setter 方法。这 4 个方法都是以两条下划线作前缀，两条下划线作后缀，以表明它们是非标准的方法。  ## 对象的三个属性(掌握)  ### 原型属性  &emsp;&emsp;对象的原型属性是用来继承属性的，这个属性如此重要，以至于我们经常把“o 的原型属性”直接叫做“o 的原型”。   &emsp;&emsp;原型属性是在实例对象创建之初就设置好的，通过对象直接量创建的对象使用 Object.prototype 作为它们的原型。通过 new 创建的对象使用构造函数的 prototype 属性作为它们的原型。通过 Object.create（）创建的对象使用第一个参数（也可以是 nul1）作为它们的原型。   &emsp;&emsp;在 ECMAScript5 中，将对象作为参数传入 Object.getPrototypeOf（）可以查询它的原型。在 ECMAScript3 中，则没有与之等价的函数，但经常使用表达式 o.constructor.prototype 来检测一个对象的原型。通过 new 表达式创建的对象，通常继承一个 constructor 属性，这个属性指代创建这个对象的构造函数。   &emsp;&emsp;后面还解释了使用这种方法来检测对象原型的方式并不可靠的原因。注意，通过对象直接量或 Object.create（）创建的对象包含一个名为 constructor 的属性，这个属性指代 Object（）构造函数。因此，constructor.prototype 才是对象直接量的真正的原型，但对于通过 Object.create（）创建的对象则往往不是这样。   &emsp;&emsp;要想检测一个对象是否是另一个对象的原型（或处于原型链中），请使用 isPrototypeof（）方法。例如，可以通过 p.isPrototypeOf（o）来检测 p 是否是 o 的原型,isPrototypeOf（）函数实现的功能和 instanceof 运算符非常类似：  ```js var p={x：1}；/定义一个原型对象 var o=Object.create（p）；//使用这个原型创建一个对象 p.isPrototype0f（o）//=>true:o继承自p Object.prototype.isPrototypeOf（o）//=>true:p继承自object.prototype ```  &emsp;&emsp;Mozilla 实现的 JavaScript（包括早些年的 Netscape）对外暴露了一个专门命名为*proto*的属性，用以直接查询/设置对象的原型。但并不推荐使用*proto*，因为尽管 Safari 和 Chrome 的当前版本都支持它，但 IE 和 Opera 还未实现它（可能以后也不会实现）。实现了 ECMAScript 5 的 Firefox 版本依然支持\\_proto，但对修改不可扩展对象的原型做了限制。  ### 类属性  &emsp;&emsp;对象的类属性（class attribute）是一个字符串，用以表示对象的类型信息。ECMAScript 3 和 ECMAScript5 都未提供设置这个属性的方法，并只有一种间接的方法可以查询它。 默认的 toString（）方法（继承自 Object.prototype）返回了如下这种格式的字符串：  ```js [object class] ```  &emsp;&emsp;因此，要想获得对象的类，可以调用对象的 tostring（）方法，然后提取已返回字符串的第 8 个到倒数第二个位置之间的字符。不过让人感觉棘手的是，很多对象继承的 tostring（）方法重写了，为了能调用正确的 tostring（）版本，必须间接地调用 Function.ca11（）方法。   &emsp;&emsp;classof（）函数可以返回传递给它的任意对象的类：  ```js function classof(o) {   if (o === null) return \'Null\';   if (o === undefined) return \'Undefined\';   return Object.prototype.toString.cal1(o).slice(8, -1); } ```  &emsp;&emsp;通过内置构造函数（比如 Array 和 Date）创建的对象包含“类属性”（class atribute），它与构造函数名称相匹配。宿主对象也包含有意义的“类属性”，但这和具体的 JavaScript 实现有关。通过对象直接量和 Object.create 创建的对象的类属性是“Object”，那些自定义构造函数创建的对象也是一样，类属性也是“Object”，因此对于自定义的类来说，没办法通过类属性来区分对象的类：  ```js classof（nul1）//=>"Null" classof（1）//=>"Number" c1assof（""）//=>"String" classof（false）//=>"Boolean" classof（{}）//=>"Object" classof（[]）//=>"Array" classof（/./）//=>"Regexp" classof（new Date（））//=>"Date". classof（window）//=>"Window”（这是客户端宿主对象） function f（）{}；//定义一个自定义构造函数 classof（new f（））；//=>"Object" ```  ### 可扩展性  &emsp;&emsp;对象的可扩展性用以表示是否可以给对象添加新属性。所有内置对象和自定义对象都是显式可扩展的，宿主对象的可扩展性是由 JavaScript 引擎定义的。除非将它们转换为不可扩展的。   &emsp;&emsp;ECMAScript5 定义了用来查询和设置对象可扩展性的函数。通过将对象传入 Object.esExtensible（），来判断该对象是否是可扩展的。如果想将对象转换为不可扩展的，需要调用 Object.preventExtensions（），将待转换的对象作为参数传进去。注意，一旦将对象转换为不可扩展的，就无法再将其转换回可扩展的了。同样需要注意的是，preventExtensions（）只影响到对象本身的可扩展性。如果给一个不可扩展的对象的原型添加属性，这个不可扩展的对象同样会继承这些新属性。   &emsp;&emsp;可扩展属性的目的是将对象“锁定”，以避免外界的干扰。对象的可扩展性通常和属性的可配值性与可写性配合使用。   &emsp;&emsp;Object.seal（）和 Object.preventExtensions（）类似，除了能够将对象设置为不可扩展的，还可以将对象的所有自有属性都设置为不可配置的。也就是说，不能给这个对象添加新属性，而且它已有的属性也不能删除或配置，不过它已有的可写属性依然可以设置。对于那些已经封闭（sealed）起来的对象是不能解封的。可以使用 Object.isSealed（）来检测对象是否封闭。   &emsp;&emsp;Object.freeze（）将更严格地锁定对象——“冻结”（frozen）。除了将对象设置为不可扩展的和将其属性设置为不可配置的之外，还可以将它自有的所有数据属性设置为只读（如果对象的存取器属性具有 setter 方法，存取器属性将不受影响，仍可以通过给属性赋值调用它们）。使用 Object.isFrozen（）来检测对象是否冻结。   &emsp;&emsp;Object.preventExtensions（）、Object.seal（）和 Object.freeze（）都返回传入的对象，也就是说，可以通过函数嵌套的方式调用它们：  ```js //创建一个封闭对象，包括一个冻结的原型和一个不可枚举的属性 var o=object.seal（Object.create（Object.freeze（{x：1}），                         {y:{value：2，writable:true}}））； ```  ## 序列化对象(掌握)  &emsp;&emsp;对象序列化（serialization）是指将对象的状态转换为字符串，也可将字符串还原为对象。ECMAScript 5 提供了内置函数]S0N.stringify（）和]S0N.parse（）用来序列化和还原 JavaScript 对象。这些方法都使用 JSON 作为数据交换格式，JSON 的全称是“JavaScript Object Notation”——JavaScript 对象表示法，它的语法和 JavaScript 对象与数组直接量的语法非常相近：  ```js o={x：1，y:{z:[false，null，“]]}}；//定义一个测试对象 s=JS0N.stringify（o）；//s是{"x"：1，"y"：{"z"：[false，mull，""]}} p=JS0N.parse（s）；//p是o的深拷贝 ```  &emsp;&emsp;NaN、Infinity 和-Infinity 序列化的结果是 null，日期对象序列化的结果是 ISO 格式的日期字符串（参照 Date.toJSON（）函数），但 JSON.parse（）依然保留它们的字符串形态，而不会将它们还原为原始日期对象。函数、RegExp、Error 对象和 undefined 值不能序列化和还原。JSON.stringify（）只能序列化对象可枚举的自有属性。对于一个不能序列化的属性来说，在序列化后的输出字符串中会将这个属性省略掉。   &emsp;&emsp;JSON.stringify（）和 JSON.parse（）都可以接收第二个可选参数，通过传入需要序列化或还原的属性列表来定制自定义的序列化或还原操作。  ## 对象方法（掌握）  ### toString（）方法  &emsp;&emsp;toString（）方法没有参数，它将返回一个表示调用这个方法的对象值的字符串。默认的 toString（）方法的返回值带有的信息量很少，例如，下面这行代码的计算结果为字符串“[object Object]”：  ```js var s={x：1，y：1}.tostring（）； ```  &emsp;&emsp;由于默认的 toString（）方法并不会输出很多有用的信息，因此很多类都带有自定义的 toString（）。例如，当数组转换为字符串的时候，结果是一个数组元素列表，只是每个元素都转换成了字符串，再比如，当函数转换为字符串的时候，得到函数的源代码。  ### toLocaleString（）方法  &emsp;&emsp;除了基本的 toString（）方法之外，对象都包含 tolocaleString（）方法，这个方法返回一个表示这个对象的本地化字符串。0bject 中默认的 toLocaleString（）方法并不做任何本地化自身的操作，它仅调用 toString（）方法并返回对应值。Date 和 Number 类对 toLocaleString（）方法做了定制，可以用它对数字、日期和时间做本地化的转换。Array 类的 toLocalestring（）方法和 toString（）方法很像，唯一的不同是每个数组元素会调用 tolocalestring（）方法转换为字符串，而不是调用各自的 toString（）方法。  ### toJSON（）方法  &emsp;&emsp;Object.prototype 实际上没有定义 toJSON（）方法，但对于需要执行序列化的对象来说，JSON.stringify（）方法会调用 toJSON（）方法。如果在待序列化的对象中存在这个方法，则调用它，返回值即是序列化的结果，而不是原始的对象。具体示例参见 Date.toJSON（）。  ### valueOf（）方法  &emsp;&emsp;valueOf（）方法和 toString（）方法非常类似，但往往当 JavaScript 需要将对象转换为某种原始值而非字符串的时候才会调用它，尤其是转换为数字的时候。如果在需要使用原始值的上下文中使用了对象，JavaScript 就会自动调用这个方法。默认的 valueOf（）方法不足为奇，但有些内置类自定义了 valueOf（）方法（比如 Date.valueOf（））。 '},{title:"【读书笔记】《JavaScript权威指南》第5章语句",path:"/posts/%E3%80%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%91%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B%E7%AC%AC5%E7%AB%A0%E8%AF%AD%E5%8F%A5.html",strippedContent:' ## 前言  &emsp;&emsp;表达式在 JavaScript 中是短语，那么语句（statement）就是 JavaScript 整句或命令。表达式计算出一个值，但语句用来执行以**使某件事发生**。   &emsp;&emsp;“使某件事发生”的一个方法是计算带有副作用的表达式。诸如赋值和函数调用这些有副作用的表达式，是可以作为单独的语句的，这种把表达式当做语句的用法也称做表达式语句（expression statement）。类似的语句还有声明语句（declaration statement），声明语句用来声明新变量或定义新函数。   &emsp;&emsp;另一种“使某件事发生”的方法是改变语句的默认执行顺序。默认情况下，JavaScript 解释器依照语句的编写顺序依次执行。JavaScript 中有很多语句和控制结构（control structure）来改变语句的默认执行顺序：  - 条件（conditional）语句，JavaScript 解释器可以根据一个表达式的值来判断是执行还是跳过这些语句，如 if 语句和 switch 语句。 - 循环（loop）语句，可以重复执行语句，如 while 和 for 语句。 - 跳转（jump）语句，可以让解释器跳转至程序的其他部分继续执行，如 break、return 和 throw 语句  ## 表达式语句（掌握）  &emsp;&emsp;具有副作用的表达式是 JavaScript 中最简单的语句。赋值语句是一类比较重要的表达式语句，例如：  ```js greeting="Hello"+name； i*=3； ```  &emsp;&emsp;递增运算符（++）和递减运算符（--）和赋值语句有关。它们的作用是改变一个变量的值，就像执行一条赋值语句一样：  ```js counter++； ```  &emsp;&emsp;delete 运算符的重要作用是删除一个对象的属性，所以，它一般作为语句使用，而不是作为复杂表达式的一部分：  ```js delete o.x； ```  &emsp;&emsp;函数调用是表达式语句的另一个大类，例如：  ```js alert（greeting）； window.close（）； ```  ## 复合语句和空语句（掌握）  &emsp;&emsp;JavaScript 中还可以将多条语句联合在一起，形成一条复合语句（compound statement）。只须用花括号将多条语句括起来即可。因此，下面几行代码就可以当成一条单独的语句，使用在 JavaScript 中任何希望使用一条语句的地方：  ```js {     x=Math.PI;     cx=Math.cos(x);     console.1og("cos(π)="+cx); } ```  - 第一，语句块的结尾不需要分号。块中的原始语句必须以分号结束，但语句块不需要。 - 第二，语句块中的行都有缩进，这不是必需的，但整齐的缩进能让代码可读性更强，更容易理解。 - 最后，需要注意，JavaScript 中没有块级作用域，在语句块中声明的变量并不是语句块私有的。  ```js //初始化一个数组a for（i=0；i<a.length；a[i++]=0）； ```  &emsp;&emsp;在这个循环中，所有的操作都在表达式 a[i++]=0 中完成，这里并不需要任何循环体。然而 JavaScript 需要循环体中至少包含一条语句，因此，这里只使用了一个单独的分号来表示一条空语句。   &emsp;&emsp;注意，在 for 循环、while 循环或 if 语句的右圆括号后的分号很不起眼，这很可能造成一些致命 bug，而这些 bug 很难定位到。例如，下面的代码的执行结果可能就不是程序作者想要的效果：  ```js if（（a==0）||（b==0））；//糟糕！这一行代码什么都没做... a=nul1；/这一行代码总是会执行 ```  &emsp;&emsp;如果有特殊的目的需要使用空语句，最好在代码中添加注释，这样可以更清楚地说明这条空语句是有用的，例如：  ```js for（i=o；i<a.length；a[i++]=0）/*empty*/； ```  ## 声明语句（掌握）  ### var  &emsp;&emsp;var 语句用来声明一个或者多个变量,var 声明的变量是无法通过 delete 删除的。   &emsp;&emsp;如果 var 语句中的变量没有指定初始化表达式，那么这个变量的值初始为 undefined。   &emsp;&emsp;变量在声明它们的脚本或函数中都是有定义的，变量声明语句会被“提前”至脚本或者函数的顶部。但是初始化的操作则还在原来 var 语句的位置执行，在声明语句之前变量的值是 undefined。   &emsp;&emsp;需要注意的是，var 语句同样可以作为 for 循环或者 for/in 循环的组成部分（和在循环之外声明的变量声明一样，这里声明的变量也会“提前”）。  ### function  &emsp;&emsp;function 是要声明的函数的名称的标识符。函数名之后的圆括号中是参数列表，参数之间使用逗号分隔。当调用函数时，这些标识符则指代传入函数的实参。   &emsp;&emsp;函数体是由 JavaScript 语句组成的，语句的数量不限，且用花括号括起来。在定义函数时，并不执行函数体内的语句，它和调用函数时待执行的新函数对象相关联。注意，function 语句里的花括号是必需的，这和 while 循环和其他一些语句所使用的语句块是不同的，即使函数体只包含一条语句，仍然必须使用花括号将其括起来。   &emsp;&emsp;函数声明语句通常出现在 JavaScript 代码的最顶层，也可以嵌套在其他函数体内。但在嵌套时，函数声明只能出现在所嵌套函数的顶部。也就是说，函数定义不能出现在 if 语句、while 循环或其他任何语句中，正是由于函数声明位置的这种限制，ECMAScript 标准规范并没有将函数声明归类为真正的语句。有一些 JavaScript 实现的确允许在出现语句的地方都可以进行函数声明，但是不同的实现在细节处理方式上有很大差别，因此将函数声明放在其他的语句内的做法并不具备可移植性。   &emsp;&emsp;和通过 var 声明变量一样，函数定义语句中的函数被显式地“提前”到了脚本或函数的顶部。因此它们在整个脚本和函数内都是可见的。使用 var 的话，只有变量声明提前了——变量的初始化代码仍然在原来的位置。然而使用函数声明语句的话，函数名称和函数体均提前：脚本中的所有函数和函数中所有嵌套的函数都会在当前上下文中其他代码之前声明。也就是说，可以在声明一个 JavaScript 函数之前调用它。   &emsp;&emsp;和 var 语句一样，函数声明语句创建的变量也是无法删除的。但是这些变量不是只读的，变量值可以重写。  ## 条件语句（掌握）  &emsp;&emsp;条件语句是通过判断指定表达式的值来决定执行还是跳过某些语句。这些语句是代码的 “决策点”，有时称为“分支”。如果说 JavaScript 解释器是按照代码的“路径”执行的，条件语句就是这条路径上的分叉点，程序执行到这里时必须选择其中一条路径继续执行。  ### if  &emsp;&emsp;需要注意的是，if 语句中括住 expression 的圆括号在语法上是必需的。JavaScript 语法规定，if 关键字和带圆括号的表达式之后必须跟随一条语句，但可以使用语句块将多条语句合并成一条。  ### else if  &emsp;&emsp;if/e1se 语句通过判断一个表达式的计算结果来选择执行两条分支中的一条。但当代码中有多条分支的时候该怎么办呢？一种解决办法是使用 else if 语句。elseif 语句并不是真正的 JavaScript 语句，它只不过是多条 if/else 语句连在一起时的一种惯用写法。  ### switch  &emsp;&emsp;当所有的分支都依赖于同一个表达式的值时，else if 并不是最佳解决方案。在这种情况下，重复计算多条 if 语句中的条件表达式是非常浪费的做法。   &emsp;&emsp;switch 语句正适合处理这种情况。关键字 switch 之后紧跟着圆括号括起来的一个表达式，随后是一对花括号括起来的代码块：  ```js switch（expression）{ statements } ```  &emsp;&emsp;然而，switch 语句的完整语法要比这复杂一些。代码块中可以使用多个由 case 关键字标识的代码片段，case 之后是一个表达式和一个冒号，case 和标记语句很类似，只是这个标记语句并没有名字，它只和它后面的表达式关联在一起。当执行这条 switch 语句的时候，它首先计算 expression 的值，然后查找 case 子句中的表达式是否和 expression 的值相同（这里的“相同”是按照“===”运算符进行比较的）。如果找到匹配的 case，那么将会执行这个 case 对应的代码块。如果找不到匹配的 case，那么将会执行“default:”标签中的代码块。如果没有“default:”标签，switch 语句将跳过它的所有代码块。  ```js switch（n）{     case 1：//如果n===1，从这里开始执行     //执行代码块1     break；//停止执行switch语句     case 2：//如果n===2，从这里执行     //执行代码块2     break；//在这里停止执行switch语句     case 3：//如果n===3，从这里执行     //执行代码块3     break；//在这里停止执行switch语句     default://如果所有的条件都不匹配     //执行代码块4     break；//在这里停止执行switch语句 } ```  &emsp;&emsp;如果没有 break 语句，那么 switch 语句就会从与 expression 的值相匹配的 case 标签处的代码块开始执行，依次执行后续的语句，一直到整个 switch 代码块的结尾。如果在函数中使用 switch 语句，可以使用 return 来代替 break，return 和 break 都用于终止 switch 语句，也会防止一个 case 语句块执行完后继续执行下一个 case 语句块。  ## 循环（掌握）  ### while  ```js while (expression) statement; ```  &emsp;&emsp;在执行 while 语句之前，JavaScript 解释器首先计算 expression 的值，如果它的值是假值，那么程序将跳过循环体中的逻辑 statement 转而执行程序中的下一条语句。反之，如果表达式 expression 是真值，JavaScript 解释器将执行循环体内的逻辑，然后再次计算表达式 expression 的值，这种循环会一直继续下去，直到 expression 的值为假值为止。  ### do/while  &emsp;&emsp;do/while 循环和 while 循环非常相似，只不过它是在循环的尾部而不是顶部检测循环表达式，这就意味着循环体至少会执行一次。do/while 循环的语法如下：  ```js do     statement while(expression); do{     console.1og(a[i]); }while(++i<len); ```  &emsp;&emsp;在 do/while 循环和普通的 while 循环之间有两点语法方面的不同之处。   &emsp;&emsp;首先，do 循环要求必须使用关键字 do 来标识循环的开始，用 while 来标识循环的结尾并进入循环条件判断。   &emsp;&emsp;其次，和 while 循环不同，do 循环是用分号结尾的。如果 while 的循环体使用花括号括起来的话，则 while 循环也不用使用分号做结尾。  ### for  ```js for（initialize；test；increment）     statement ```  &emsp;&emsp;当然，有些循环会比这些例子更加复杂，而且循环中的一次迭代会改变多个变量。在 JavaScript 中，这种情况则必须用到逗号运算符，它将初始化表达式和自增表达式合并入一个表达式中以用于 for 循环：  ```js var i，j； for（i=0，j=10；i<10；i++，j--）     sum+=i*j； ```  ### for/in  ```js for (variable in object) statement; ```  &emsp;&emsp;在执行 for/in 语句的过程中，JavaScript 解释器首先计算 object 表达式。如果表达式为 nu11 或者 undefined，JavaScirpt 解释器将会跳过循环并执行后续的代码。如果表达式等于一个原始值，这个原始值将会转换为与之对应的包装对象（wrapper object）（见 3.6 节）。否则，expression 本身已经是对象了。JavaScript 会依次枚举对象的属性来执行循环。然而在每次循环之前，JavaScript 都会先计算 variable 表达式的值，并将属性名（一个字符串）赋值给它。  ```js var o = { x: 1, y: 2, z: 3 }; var a = [],   i = 0; for (a[i++] in o /* empty*/); ```  &emsp;&emsp;其实，for/in 循环并不会遍历对象的所有属性，只有“可枚举”（enumerable）的属性才会遍历到。由 JavaScript 语言核心所定义的内置方法就不是“可枚举的”。比如，所有的对象都有方法 toString（），但 for/in 循环并不枚举 toString 这个属性。除了内置方法之外，还有很多内置对象的属性也是“不可枚举的”（nonenumerable）。   &emsp;&emsp;而代码中定义的所有属性和方法都是可枚举的。对象可以继承其他对象的属性，那些继承的自定义属性也可以使用 for/in 枚举出来。   &emsp;&emsp;如果 for/in 的循环体删除了还未枚举的属性，那么这个属性将不会再枚举到。   &emsp;&emsp;如果循环体定义了对象的新属性，这些属性通常也不会枚举到（然而，JavaScript 的有些实现是可以枚举那些在循环体中增加的继承属性的）。  #### 属性枚举的顺序  &emsp;&emsp;ECMAScript 规范并没有指定 for/in 循环按照何种顺序来枚举对象属性。但实际上，主流浏览器厂商的 JavaScript 实现是按照属性定义的先后顺序来枚举简单对象的属性，先定义的属性先枚举。   &emsp;&emsp;在下列情况下，枚举的顺序取决于具体的实现（并且是非交互的）：  - 对象继承了可枚举属性； - 对象具有整数数组索引的属性； - 使用 delete 删除了对象已有的属性； - 使用 Object.defineProperty（）或者类似的方法改变了对象的属性。  &emsp;&emsp;但当数组元素的索引是非数字或数组是稀疏数组（数组索引是不连续的）时它们则按照特定顺序枚举。  ## 跳转（掌握）  ### 标签语句  &emsp;&emsp;语句是可以添加标签的，标签是由语句前的标识符和冒号组成。break 和 continue 是 JavaScript 中唯一可以使用语句标签的语句。  ```js mainloop:while（tokenl=nul1）{     //忽略这里的代码..     continue mainloop；//跳转到下一次循环     //忽略这里的代码… } ```  &emsp;&emsp;这里用做标签的 identifier 必须是一个合法的 JavaScript 标识符，而不能是一个保留字。标签的命名空间和变量或函数的命名空间是不同的，因此可以使用同一个标识符作为语句标签和作为变量名或函数名。   &emsp;&emsp;语句标签只有在它所起作用的语句（当然也可以在它的子句中）内是有定义的。一个语句标签不能和它内部的语句标签重名，但在两个代码段不相互嵌套的情况下是可以出现同名的语句标签的。带有标签的语句还可以带有标签，也就是说，任何语句可以有很多个标签。  ### break 语句  &emsp;&emsp;单独使用 break 语句的作用是立即退出最内层的循环或 switch 语句。   &emsp;&emsp;在 break 关键字和 labelname 之间不能换行。因为 JavaScript 可以给语句自动补全省略掉的分号，如果 break 关键字和标签之间有换行，JavaScript 解释器会认为你在使用 break 不带标签的最简形式，因此会在 break 后补充分号。   &emsp;&emsp;最后，需要注意的是，不管 break 语句带不带标签，它的控制权都无法越过函数的边界。比如，对于一条带标签的函数定义语句来说，不能从函数内部通过这个标签来跳转到函数外部。  ### continue 语句  &emsp;&emsp;continue 语句和 break 语句非常类似，但它不是退出循环，而是转而执行下一次循环。不管 continue 语句带不带标签，它只能在循环体内使用。在其他地方使用将会报语法错误。   &emsp;&emsp;在不同类型的循环中，continue 的行为也有所区别：  - 在 while 循环中，在循环开始处指定的 expression 会重复检测，如果检测结果为 true，循环体会从头开始执行。 - 在 do/while 循环中，程序的执行直接跳到循环结尾处，这时会重新判断循环条件，之后才会继续下一次循环。 - 在 for 循环中，首先计算自增表达式，然后再次检测 test 表达式，用以判断是否执行循环体。 - 在 for/in 循环中，循环开始遍历下一个属性名，这个属性名赋给了指定的变量。  &emsp;&emsp;需要注意 continue 语句在 while 和 for 循环中的区别，while 循环直接进入下一轮的循环条件判断，但 for 循环首先计算其 increment 表达式，然后判断循环条件。  ### return 语句  &emsp;&emsp;函数中的 return 语句既是指定函数调用后的返回值。return 语句只能在函数体内出现，如果不是的话会报语法错误。当执行到 return 语句的时候，函数终止执行，并返回 expression 的值给调用程序。   &emsp;&emsp;由于 JavaScript 可以自动插入分号，因此在 return 关键字和它后面的表达式之间不能有换行。  ### throw 语句  &emsp;&emsp;所谓异常（exception）是当发生了某种异常情况或错误时产生的一个信号。抛出异常，就是用信号通知发生了错误或异常状况。捕获异常是指处理这个信号，即采取必要的手段从异常中恢复。在 JavaScript 中，当产生运行时错误或者程序使用 throvw 语句时就会显式地抛出异常。使用 try/catch/finally 语句可以捕获异常。  ```js throw expression; ```  &emsp;&emsp;expression 的值可以是任意类型的。可以抛出一个代表错误码的数字，或者包含可读的错误消息的字符串。当 JavaScript 解释器抛出异常的时候通常采用 Error 类型和其子类型，当然也可以使用它们。一个 Error 对象有一个 name 属性表示错误类型，一个 message 属性用来存放传递给构造函数的字符串。  ```js function factorial（x）{     //如果输入参数是非法的，则抛出一个异常     if（x<0）throw new Error（"x不能是负数”）；     //否则，计算出一个值，并正常地返回它     for（var f=1；x>1；f*=x，x--）/* empty*/；     return f； } ```  &emsp;&emsp;当抛出异常时，JavaScript 解释器会立即停止当前正在执行的逻辑，并跳转至就近的异常处理程序。异常处理程序是用 try/catch/finally 语句的 catch 从句编写的，下一节会介绍它。   &emsp;&emsp;如果抛出异常的代码块没有一条相关联的 catch 从句，解释器会检查更高层的闭合代码块，看它是否有相关联的异常处理程序。以此类推，直到找到一个异常处理程序为止。如果抛出异常的函数没有处理它的 try/catch/finally 语句，异常将向上传播到调用该函数的代码。这样的话，异常就会沿着 JavaScript 方法的词法结构和调用栈向上传播。如果没有找到任何异常处理程序，JavaScript 将把异常当成程序错误来处理，并报告给用户。  ### try/catch/finally 语句  &emsp;&emsp;try/catch/finally 语句是 JavaScript 的异常处理机制。其中 try 从句定义了需要处理的异常所在的代码块。catch 从句跟随在 try 从句之后，当 try 块内某处发生了异常时，调用 catch 内的代码逻辑。catch 从句后跟随 finally 块，后者中放置清理代码，不管 try 块中是否产生异常，finally 块内的逻辑总是会执行。   &emsp;&emsp;尽管 catch 和 finally 都是可选的，但 try 从句需要至少二者之一与之组成完整的语句。try、catch 和 finally 语句块都需要使用花括号括起来，这里的花括号是必需的，即使从句中只有一条语句也不能省略花括号。  ```js try{     //通常来讲，这里的代码会从头执行到尾而不会产生任何问题，     //但有时会抛出一个异常，要么是由throw语句直接抛出异常，     //要么是通过调用一个方法间接抛出异常 catch（e）{     //当且仅当try语句块抛出了异常，才会执行这里的代码     //这里可以通过局部变量e来获得对Error对象或者抛出的其他值的引用     //这里的代码块可以基于某种原因处理这个异常，也可以忽略这个异常，     //还可以通过throw语句重新抛出异常 finally{     //不管try语句块是否抛出了异常，这里的逻辑总是会执行，终止try语句块的方式有：     //1）正常终止，执行完语句块的最后一条语句     //2）通过break、continue或return语句终止     //3）抛出一个异常，异常被catch从句捕获     //4）抛出一个异常，异常未被捕获，继续向上传播 } ```  &emsp;&emsp;关键字 catch 后跟随了一对圆括号，圆括号内是一个标识符。这个标识符具有块级作用域，它只在 catch 语句块内有定义。   &emsp;&emsp;通常状况下，解释器执行到 try 块的尾部，然后开始执行 finally 中的逻辑，以便进行必要的清理工作。当由于 return、continue 或 break 语句使得解释器跳出 try 语句块时，解释器在执行新的目标代码之前先执行 fnally 块中的逻辑。   &emsp;&emsp;如果在 try 中产生了异常，而且存在一条与之相关的 catch 从句来处理这个异常，解释器会首先执行 catch 中的逻辑，然后执行 finally 中的逻辑。如果不存在处理异常的局部 catch 从句，解释器会首先执行 finally 中的逻辑，然后向上传播这个异常，直到找到能处理这个异常的 catch 从句。   &emsp;&emsp;如果 finally 块使用了 return、continue、break 或者 throw 语句使程序发生跳转，或者通过调用了抛出异常的方法改变了程序执行流程，不管这个跳转使程序挂起还是继续执行，解释器都会将其忽略。例如，如果 fina1ly 从句抛出一个异常，这个异常将替代正在抛出的异常。如果 finally 从句运行到了 return 语句，尽管已经抛出了异常且这个抛出的异常还没有处理，这个方法依然会正常返回。   &emsp;&emsp;在没有 catch 从句的情况下 try 从句可以和 finally 从句一起使用。在这种情况下，finally 块只包含清理代码，不管 try 块中是否有 break、continue 或 return 语句，这里的代码一定会执行，回想一下，我们无法完全精确地使用 while 循环来模拟 for 循环，因为 continue 语句在两个循环中的行为表现不一致。如果使用 try/finally 语句，就能使用 while 循环来正确模拟包含 continue 的 for 循环：  ```js while (test) {   try {     body;   } finally {     increment;   } } ```  &emsp;&emsp;然而需要注意的是，当 body 包含 break 语句时，while 循环和 for 循环便有了更微妙的区别，（造成了一次额外的自增运算），因此即便使用了 finally 从句，使用 while 来完全模拟 for 循环依然是不可能的。  ## 其他语句类型（了解）  ### with 语句  &emsp;&emsp;作用域链（scope chain）是一个可以按序检索的对象列表，通过它可以进行变量名解析。with 语句用于临时扩展作用域链，它具有如下的语法：  ```js with（object） statement ```  &emsp;&emsp;这条语句将 object 添加到作用域链的头部，然后执行 statement，最后把作用域链恢复到原始状态。   &emsp;&emsp;在 严格模式中是禁止使用 with 语句的，并且在非严格模式里也是不推荐使用 with 语句的，尽可能避免使用 with 语句。那些使用 with 语句的 JavaScript 代码非常难于优化，并且同没有使用 with 语句的代码相比，它运行得更慢。   &emsp;&emsp;在对象嵌套层次很深的时候通常会使用 with 语句来简化代码编写。例如，在客户端 JavaScript 中，可能会使用类似下面这种表达式来访问一个 HTML 表单中的元素：  ```js document.forms[o].address.value; ```  &emsp;&emsp;如果这种表达式在代码中多次出现，则可以使用 with 语句将 form 对象添加至作用域链的顶层：  ```js with（document.forms[o]）{     //直接访问表单元素，例如：     name.value=""；     address.value=""；     email.value=""； } ```  &emsp;&emsp;这种方法减少了大量的输入，不用再为每个属性名添加 document.forms[o]前缀。这个对象临时挂载在作用域链上，当 JavaScript 需要解析诸如 address 的标识符时，就会自动在这个对象中查找。当然，不使用 with 语句的等价代码可以写成这样：  ```js var f = document.forms[o]; f.name.value = \'\'; f.address.value = \'\'; f.email.value = \'\'; ```  &emsp;&emsp;只有在查找标识符的时候才会用到作用域链，创建新的变量的时候不使用它，看一下下面这行代码：  ```js with（o）x=1； ```  &emsp;&emsp;如果对象 o 有一个属性 x，那么这行代码给这个属性赋值为 1。但如果 o 中没有定义属性 x，这段代码和不使用 with 语句的代码 x=1 是一模一样的。它给一个局部变量或者全局变量 x 赋值，或者创建全局对象的一个新属性。with 语句提供了一种读取。的属性的快捷方式，但它并不能创建 o 的属性。  ### debugger 语句  &emsp;&emsp;debugger 语句通常什么也不做。然而，当调试程序可用并运行的时候，JavaScript 解释器将会（非必需）以调式模式运行。实际上，这条语句用来产生一个断点（breakpoint），JavaScript 代码的执行会停止在断点的位置，这时可以使用调试器输出变量的值、检查调用栈等。  ### "use strict"  &emsp;&emsp;“use strict”是 ECMAScript5 引入的一条指令。指令不是语句（但非常接近于语句）。“use strict”指令和普通的语句之间有两个重要的区别：  - 它不包含任何语言的关键字，指令仅仅是一个包含一个特殊字符串直接量的表达式（可以是使用单引号也可以使用双引号），对于那些没有实现 ECMAScript5 的 JavaScript 解释器来说，它只是一条没有副作用的表达式语句，它什么也没做。将来的 ECMAScript 标准希望将 use 用做关键字，这样就可以省略引号了。 - 它只能出现在脚本代码的开始或者函数体的开始、任何实体语句之前。但它不必一定出现在脚本的首行或函数体内的首行，因为“use strict”指令之后或之前都可能有其他字符串直接量表达式语句，并且 JavaScript 的具体实现可能将它们解析为解释器自有的指令。在脚本或者函数体内第一条常规语句之后字符串直接量表达式语句只当做普通的表达式语句对待；它们不会当做指令解析，它们也没有任何副作用。  #### 严格模式（了解）  - 在严格模式中禁止使用 with 语句。 - 在严格模式中，所有的变量都要先声明，如果给一个未声明的变量、函数、函数参数、catch 从句参数或全局对象的属性赋值，将会抛出一个引用错误异常（在非严格模式中，这种隐式声明的全局变量的方法是给全局对象新添加一个新属性）。 - 在严格模式中，调用的函数（不是方法）中的一个 this 值是 undefined。（在非严格模式中，调用的函数中的 this 值总是全局对象）。可以利用这种特性来判断 JavaScript 实现是否支持严格模式：  ```js var hasstrictMode=（function（）{"use strict"；return this===undefined}（））； ```  - 同样，在严格模式中，当通过 ca11（）或 apply（）来调用函数时，其中的 this 值就是通过 ca11（）或 apply（）传入的第一个参数（在非严格模式中，nu11 和 undefined 值被全局对象和转换为对象的非对象值所代替）。 - 在严格模式中，给只读属性赋值和给不可扩展的对象创建新成员都将抛出一个类型错误异常（在非严格模式中，这些操作只是简单地操作失败，不会报错）。 - 在严格模式中，传入 eva1（）的代码不能在调用程序所在的上下文中声明变量或定义函数，而在非严格模式中是可以这样做的。相反，变量和函数的定义是在 eval（）创建的新作用域中，这个作用域在 eval（）返回时就弃用了。 - 在严格模式中，函数里的 arguments 对（见 8.3.2 节）拥有传入函数值的静态副本。在非严格模式中，arguments 对象具有“魔术般”的行为，arguments 里的数组元素和函数参数都是指向同一个值的引用。 - 在严格模式中，当 delete 运算符后跟随非法的标识符（比如变量、函数、函数参数）时，将会抛出一个语法错误异常（在非严格模式中，这种 delete 表达式什么也没做，并返回 false）。 - 在严格模式中，试图删除一个不可配置的属性将抛出一个类型错误异常（在非严格模式中，delete 表达式操作失败，并返回 false）。 - 在严格模式中，在一个对象直接量中定义两个或多个同名属性将产生一个语法错误（在非严格模式中不会报错）。 - 在严格模式中，函数声明中存在两个或多个同名的参数将产生一个语法错误（在非严格模式中不会报错）。 - 在严格模式中是不允许使用八进制整数直接量（以 0 为前缀，而不是 0x 为前缀）的（在非严格模式中某些实现是允许八进制整数直接量的）。 - 在严格模式中，标识符 eval 和 arguments 当做关键字，它们的值是不能更改的。不能给这些标识符赋值，也不能把它们声明为变量、用做函数名、用做函数参数或用做 catch 块的标识符。 - 在严格模式中限制了对调用栈的检测能力，在严格模式的函数中，arguments.caller 和 arguments.callee 都会抛出一个类型错误异常。严格模式的函数同样具有 caller 和 arguments 属性，当访问这两个属性时将抛出类型错误异常（有一些 JavaScript 的实现在非严格模式里定义了这些非标准的属性）。 '},{title:"【读书笔记】《JavaScript权威指南》第4章表达式和运算符",path:"/posts/%E3%80%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%91%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B%E7%AC%AC4%E7%AB%A0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6.html",strippedContent:' &emsp;&emsp;为什么要理解表达式，运算符和语句呢？抛开可以加深你对计算机语言语法的理解这种有一些虚幻缥缈的原因，最直接的原因是我们在面试题上会遇到，它们经常会把语句写的长长的，错综复杂，不加分号和空格，然后问你运行结果，这时候就考你什么是语句，表达式，什么会触发计算，怎么把它断句，组成正确的运行顺序。  ## 概念（掌握）  ### 表达式  &emsp;&emsp;表达式（expression）JavaScript 中的一个短语，JavaScript 解释器会将其计算（evaluate）出一个结果。   &emsp;&emsp;程序中的常量是最简单的一类表达式。变量名也是一种简单的表达式，它的值就是赋值给变量的值。   &emsp;&emsp;复杂表达式是由简单表达式组成的。比如，数组访问表达式是由一个表示数组的表达式、左方括号、一个整数表达式和右方括号构成。它们所组成的新的表达式的运算结果是该数组的特定位置的元素值。同样的，函数调用表达式由一个表示函数对象的表达式和 0 个或多个参数表达式构成。  ### 运算符  &emsp;&emsp;将简单表达式组合成复杂表达式最常用的方法就是使用运算符（operator）。运算符按照特定的运算规则对操作数（通常是两个）进行运算，并计算出新值。   &emsp;&emsp;乘法运算符“\\*” 是比较简单的例子。表达式 x\\*y 是对两个变量表达式 x 和 y 进行运算并得出结果。有时我们更愿意说运算符返回了一个值而不是“计算”出了一个值。  ## 表达式（掌握）  ### 原始表达式  &emsp;&emsp;原始表达式是表达式的最小单位——它们不再包含其他表达式。JavaScript 中的原始表达式包含常量或直接量、关键字和变量。  ```js 1.23 //数字直接量 "hel1o" //字符串直接量 /pattern/ //正则表达式直接量 ```  &emsp;&emsp;JavaScript 中的一些保留字构成了原始表达式：  ```js true; //返回一个布尔值：真 false; //返回一个布尔值：假 null; //返回一个值：空 this; //返回“当前“对象 ```  &emsp;&emsp;最后，第三种原始表达式是变量：  ```js i; //返回变量i的值 sum; //返回sum的值 undefined; //undefined是全局变量，和null不同，它不是一个关键字 ```  ### 对象和数组的初始化表达式  &emsp;&emsp;对象和数组初始化表达式实际上是一个新创建的对象和数组。这些初始化表达式有时称做“对象直接量”和“数组直接量”。然而和布尔直接量不同，它们不是原始表达式，因为它们所包含的成员或者元素都是子表达式。  #### 数组初始化表达式  &emsp;&emsp;数组初始化表达式是通过一对方括号和其内由逗号隔开的列表构成的。初始化的结果是一个新创建的数组。数组的元素是逗号分隔的表达式的值：  ```js [] //一个空数组：[]内留空即表示该数组没有任何元素 [1+2，3+4] //拥有两个元素的数组，第一个是3，第二个是7 ```  &emsp;&emsp;数组直接量中的列表逗号之间的元素可以省略，这时省略的空位会填充值 undefined。例如，下面这个数组包含 5 个元素，其中三个元素是 undefined：  ```js var sparseArray = [1, , , , 5]; ```  &emsp;&emsp;数组直接量的元素列表结尾处可以留下单个逗号，这时并不会创建一个新的值为 undefined 的元素。  #### 对象初始化表达式  &emsp;&emsp;对象初始化表达式和数组初始化表达式非常类似，只是方括号被花括号代替，并且每个子表达式都包含一个属性名和一个冒号作为前缀：  ```js var p={x：2.3，y:-1.2}；//一个拥有两个属性成员的对象 var q={}；//一个空对象 q.x=2.3；q-y=-1.2；//q的属性成员和p的一样 ```  &emsp;&emsp;对象直接量中的属性名称可以是字符串而不是标识符  ```js var side = 1; var square = {   upperLeft: { x: p.x, y: p.y },   lowerRight: { x: p.x + side, y: p.y + side } }; ```  ### 函数定义表达式  &emsp;&emsp;函数定义表达式定义一个 JavaScript 函数。表达式的值是这个新定义的函数。从某种意义上讲，函数定义表达式可称为“函数直接量”。   &emsp;&emsp;一个典型的函数定义表达式包含关键字 function，跟随其后的是一对圆括号，括号内是一个以逗号分割的列表，列表含有 0 个或多个标识符（参数名），然后再跟随一个由花括号包裹的 JavaScript 代码段（函数体），例如：  ```js //这个函数返回传入参数值的平方 var square = function(x) {   return x * x; }; ```  &emsp;&emsp;函数定义表达式同样可以包含函数的名字。函数也可以通过函数语句来定义，而不是函数表达式。更多详情会在后面中讨论。  ### 属性访问表达式  &emsp;&emsp;属性访问表达式运算得到一个对象属性或一个数组元素的值。JavaScript 为属性访问定义了两种语法：  ```js expression.identifier; expression[expression]; ```  &emsp;&emsp;第一种写法是一个表达式后跟随一个句点和标识符。表达式指定对象，标识符则指定需要访问的属性的名称。   &emsp;&emsp;第二种写法是使用方括号，方括号内是另外一个表达式（这种方法适用于对象和数组）。第二个表达式指定要访问的属性的名称或者代表要访问数组元素的索引。   &emsp;&emsp;不管使用哪种形式的属性访问表达式，在“.”和“[”之前的表达式总是会首先计算。  - 如果计算结果是 null 或者 undefined，表达式会抛出一个类型错误异常，因为这两个值都不能包含任意属性。 - 如果运算结果不是对象（或者数组），JavaScript 会将其转换为对象。  * 如果对象表达式后跟随句点和标识符，则会查找由这个标识符所指定的属性的值，并将其作为整个表达式的值返回。 * 如果对象表达式后跟随一对方括号，则会计算方括号内的表达式的值并将它转换为字符串。 * 不论哪种情况，如果命名的属性不存在，那么整个属性访问表达式的值就是 undefined。  &emsp;&emsp;显然.identifier 的写法更加简单，但需要注意的是，这种方式只适用于要访问的属性名称是合法的标识符，并且需要知道要访问的属性的名字。   &emsp;&emsp;如果属性名称是一个保留字或者包含空格和标点符号，或是一个数字（对于数组来说），则必须使用方括号的写法。   &emsp;&emsp;当属性名是通过运算得出的值而不是固定的值的时候，这时必须使用方括号写法。  ### 调用表达式  &emsp;&emsp;JavaScript 中的调用表达式（invocation expression）是一种调用（或者执行）函数或方法的语法表示。它以一个函数表达式开始，这个函数表达式指代了要调用的函数。函数表达式后跟随一对圆括号，括号内是一个以逗号隔开的参数列表，参数可以有 0 个也可有多个，例如：  ```js f(0)//f是一个函数表达式；0是一个参数表达式 Math.max（x，y，z）//Math.max是一个函数；x，y和z是参数 a.sort（）//a.sort是一个函数，它没有参数 ```  &emsp;&emsp;当对调用表达式进行求值的时候，首先计算函数表达式，然后计算参数表达式，得到一组参数值。   &emsp;&emsp;如果函数表达式的值不是一个可调用的对象，则抛出一个类型错误异常（所有的函数都是可调用的，即使宿主对象不是函数它也有可能被调用，这里的区别将在后面讲述）。   &emsp;&emsp;然后，实参的值被依次赋值给形参，这些形参是定义函数时指定的，接下来开始执行函数体。如果函数使用 return 语句给出一个返回值，那么这个返回值就是整个调用表达式的值。否则，调用表达式的值就是 undefined。   &emsp;&emsp;如果这个表达式是一个属性访问表达式，那么这个调用称做“方法调用”（method invocation）。在方法调用中，执行函数体的时候，作为属性访问主题的对象和数组（也就是"."的对象或数组）便是其调用方法内 this 的指向。这种特性使得在面向对象编程范例中，函数（其 OO 名称为“方法”）可以调用其宿主对象。   &emsp;&emsp;在 ECMAScript 5 中，那些通过严格模式定义的函数在调用时将使用 undefined 作为 this 的值，this 不会指向全局对象。  ### 对象创建表达式  &emsp;&emsp;对象创建表达式（object creation expression）创建一个对象并调用一个函数（这个函数称做构造函数）初始化新对象的属性。对象创建表达式和函数调用表达式非常类似，只是对象创建表达式之前多了一个关键字 new：  ```js new Object(); new Point(2, 3); ```  &emsp;&emsp;如果一个对象创建表达式不需要传入任何参数给构造函数的话，那么这对空圆括号是可以省略掉的：  ```js new Object(); new Date(); ```  &emsp;&emsp;JavaScript 首先创建一个新的空对象，然后，JavaScript 通过传入指定的参数并将这个新对象当做 this 的值来调用一个指定的函数。这个函数可以使用 this 来初始化这个新创建对象的属性。   &emsp;&emsp;那些被当成构造函数的函数不会返回一个值，并且这个新创建并被初始化后的对象就是整个对象创建表达式的值。如果一个构造函数确实返回了一个对象值，那么这个对象就作为整个对象创建表达式的值，而新创建的对象就废弃了。  ## 运算符（掌握）  ### 运算符概述  &emsp;&emsp;需要注意的是，大多数运算符都是由标点符号表示的，比如“+”和“=”。而另外一些运算符则是由关键字表示的，比如 delete 和 instanceof。关键字运算符和标点符号所表示的运算符一样都是正规的运算符，它们的语法都非常言简意赅。   &emsp;&emsp;下表是按照运算符的优先级排序的，前面的运算符优先级要高于后面的运算符优先级。 被水平分割线分隔开来的运算符具有不同的优先级。标题为 A 的列表示运算符的结合性，L（从左至右）或 R（从右至左），标题为 N 的列表示操作数的个数。标题为“类型”的列表示期望的操作数类型，以及运算符的结果类型（在“一”符号之后）。下表之后的段落会解释优先级、结合性和操作数类型的概念。 ![image](https://s1.ax1x.com/2018/10/29/igJE5Q.png)  #### 操作数的个数  &emsp;&emsp;运算符可以根据其操作数的个数进行分类。JavaScript 中的大多数运算符（比如“\\*”乘法运算符）是一个二元运算符（binary operator），将两个表达式合并成一个稍复杂的表达式。换言之，它们的操作数均是两个。   &emsp;&emsp;JavaScript 同样支持一些一元运算符（unary operator），它们将一个表达式转换为另一个稍复杂的表达式。表达式一 x 中的“-”运算符就是一个一元运算符，是将操作数 x 求负值。   &emsp;&emsp;最后，JavaScript 支持一个三元运算符（ternary operator），条件判断运算符“？：”，它将三个表达式合并成一个表达式。  #### 操作数类型和结果类型  &emsp;&emsp;一些运算符可以作用于任何数据类型，但仍然希望它们的操作数是指定类型的数据，并且大多数运算符返回（或计算出）一个特定类型的值。在上表标题为“类型”的列中列出了运算符操作数的类型（箭头前）和运算结果的类型（箭头后）。  #### 左值  &emsp;&emsp;上表中的赋值运算符和其他少数运算符期望它们的操作数是 1va1 类型。左值（lvalue）是一个古老的术语，它是指“表达式只能出现在赋值运算符的左侧”。在 JavaScript 中，变量、对象属性和数组元素均是左值。ECMAScript 规范允许内置函数返回一个左值，但自定义的函数则不能返回左值。  #### 运算符的副作用  &emsp;&emsp;计算一个简单的表达式（比如 2\\*3）不会对程序的运行状态造成任何影响，程序后续执行的计算也不会受到该计算的影响。而有一些表达式则具有很多副作用，前后的表达式运算会相互影响。   &emsp;&emsp;赋值运算符是最明显的一个例子：如果给一个变量或属性赋值，那么那些使用这个变量或属性的表达式的值都会发生改变。   &emsp;&emsp;“++”和“--”递增和递减运算符与此类似，因为它们包含隐式的赋值。delete 运算符同样有副作用：删除一个属性就像（但不完全一样）给这个属性赋值 undefined。   &emsp;&emsp;其他的 JavaScript 运算符都没有副作用，但函数调用表达式和对象创建表达式有些特别，在函数体或者构造函数内部运用了这些运算符并产生了副作用的时候，我们说函数调用表达式和对象创建表达式是有副作用的。  #### 运算符优先级  &emsp;&emsp;上表中所示的运算符是按照优先级从高到低排序的，每个水平分割线内的一组运算符具有相同的优先级。运算符优先级控制着运算符的执行顺序。优先级高的运算符（表格的顶部）的执行总是先于优先级低（表格的底部）的运算符。   &emsp;&emsp;运算符的优先级可以通过显式使用圆括号来重写。   &emsp;&emsp;需要注意的是，属性访问表达式和调用表达式的优先级要比上表中列出的所有运算符都要高。看一下这个例子：  ```js typeof my.functions[x](y); ```  &emsp;&emsp;尽管 typeof 是优先级最高的运算符之一，但 typeof 也是在两次属性访问和函数调用之后执行的。   &emsp;&emsp;实际上，如果你真的不确定你所使用的运算符的优先级，最简单的方法就是使用圆括号来强行指定运算次序。有些重要规则需要熟记：乘法和除法的优先级高于加法和减法，赋值运算的优先级非常低，通常总是最后执行的。  #### 运算符的结合性  &emsp;&emsp;结合性指定了在多个具有同样优先级的运算符表达式中的运算顺序。在上表中标题为 A 的列说明了运算符的结合性。L 指从左至右结合，R 指从右至左结合。   &emsp;&emsp;一元操作符、赋值和三元条件运算符都具有从右至左的结合性。  #### 运算顺序  &emsp;&emsp;运算符的优先级和结合性规定了它们在复杂的表达式中的运算顺序，但并没有规定子表达式的计算过程中的运算顺序。   &emsp;&emsp;JavaScript 总是严格按照从左至右的顺序来计算表达式。   &emsp;&emsp;例如，在表达式 w=x+y\\*z 中，将首先计算子表达式 w，然后计算 x、y 和 z，然后，y 的值和 z 的值相乘，再加上 x 的值，最后将其赋值给表达式 w 所指代的变量或属性。给表达式添加圆括号将会改变乘法、加法和赋值运算的关系，但从左至右的顺序是不会改变的。   &emsp;&emsp;只有在任何一个表达式具有副作用而影响到其他表达式的时候，其求值顺序才会和看上去有所不同。  &emsp;&emsp;如果表达式 x 中的一个变量自增 1，这个变量在表达式 z 中使用，那么实际上是先计算出了 x 的值再计算 z 的值，这一点非常重要。   &emsp;&emsp;作者在这里揭示了一种很容易忽略的现象。假设存在 a=1，那么“b=（a++）+a；”将如何计算结果呢？按照正文所述，顺序应该是，1）计算 b，2）计算 a++（假设值为 c），3）计算 a，4）计算 c+a，5）将 c+a 的结果赋值给 b。按照“+ +”的定义，第 2）步中 a++的结果依然是 1，即 c 为 1，随后 a 立即增 1，因此在执行第 3）步时，a 的值已经是 2。所以 b 的结果为 3。很多初学者会误认为 a 增 1 的操作是在表达式计算完毕后执行的。  ### 算术表达式  #### “+”运算符  &emsp;&emsp;二元加法运算符“+”可以对两个数字做加法，也可以做字符串连接操作。   &emsp;&emsp;加号的转换规则优先考虑字符串连接，如果其中一个操作数是字符串或者转换为字符串的对象，另外一个操作数将会转换为字符串，加法将进行字符串的连接操作。如果两个操作数都不是类字符串（string-like）的，那么都将进行算术加法运算。  - 如果其中一个操作数是对象，则对象会遵循对象到原始值的转换规则转换为原始类值：日期对象通过 toString（）方法执行转换，其他对象则通过 valueOf（）方法执行转换（如果 value0f（）方法返回一个原始值的话）。由于多数对象都不具备可用的 valueof（）方法，因此它们会通过 tostring（）方法来执行转换。 - 在进行了对象到原始值的转换后，如果其中一个操作数是字符串的话，另一个操作数也会转换为字符串，然后进行字符串连接。 - 否则，两个操作数都将转换为数字（或者 NaN），然后进行加法操作。  ```js 1 + {}; //=>"1[object Object]"：对象转换为字符串后进行字符串连接 2 + undefined; //=>NaN:undefined转换为NaN后做加法 ```  #### 一元算术运算符  &emsp;&emsp;一元运算符作用于一个单独的操作数，并产生一个新值。在 JavaScript 中，一元运算符具有很高的优先级，而且都是右结合（right-associative）。  ##### 一元加法（+）  &emsp;&emsp;一元加法运算符把操作数转换为数字（或者 NaN），并返回这个转换后的数字。如果操作数本身就是数字，则直接返回这个数字。  ##### 一元减法（-）  &emsp;&emsp;当“-”用做一元运算符时，它会根据需要把操作数转换为数字，然后改变运算结果的符号。  ##### 递增（++）  &emsp;&emsp;递增“+ +”运算符对其操作数进行增量（加一）操作，操作数是一个左值（lvalue）（变量、数组元素或对象属性）。运算符将操作数转换为数字，然后给数字加 1，并将加 1 后的数值重新赋值给变量、数组元素或者对象属性。   &emsp;&emsp;递增“+ +”运算符的返回值依赖于它相对于操作数的位置。当运算符在操作数之前，称为“前增量”（pre-increment）运算符，它对操作数进行增量计算，并返回计算后的值。当运算符在操作数之后，称为“后增量”（post-increment）运算符，它对操作数进行增量计算，但返回未做增量计算的（unincremented）值。 &emsp;&emsp;需要注意的是，表达式++x 并不总和 x=x+1 完全一样，“+ +”运算符从不进行字符串连接操作，它总是会将操作数转换为数字并增 1。如果 x 是字符串“1”，++x 的结果就是数字 2，而 x+1 是字符串“11”。   &emsp;&emsp;同样需要注意的是，由于 JavaScript 会自动进行分号补全，因此不能在后增量运算符和操作数之间插入换行符。如果插入了换行符，JavaScript 将会把操作数当做一条单独的语句，并在其之前补上一个分号。  ##### 递减（--）  &emsp;&emsp;递减“一”运算符的操作数也是一个左值。它把操作数转换为数字，然后减 1，并将计算后的值重新赋值给操作数。和“++”运算符一样，递减“--”运算符的返回值依赖于它相对操作数的位置，当递减运算符在操作数之前，操作数减 1 并返回减 1 之后的值。当递减运算符在操作数之后，操作数减 1 并返回减 1 之前的值。当递减运算符在操作符的右侧时，运算符和操作数之间不能有换行符。  #### 位运算符  &emsp;&emsp;位运算符可以对由数字表示的二进制数据进行更低层级的按位运算。尽管它们并不是传统的数学运算，但这里也将其归类为算术运算符，因为它们作用于数值类型的操作数并返回数字。这些运算符在 JavaScript 编程中并不常用，如果你对十进制整数的二进制表示并不熟悉的话，你可以跳过本节内容。所以我跳过了。。。。  ### 关系表达式  &emsp;&emsp;关系运算符用于测试两个值之间的关系（比如“相等”，“小于”，或“是.的属性”），根据关系是否存在而返回 true 或 false。关系表达式总是返回一个布尔值。  #### 相等和不等运算符  &emsp;&emsp;“= =”和“= = =”运算符用于比较两个值是否相等，两个运算符允许任意类型的操作数，如果操作数相等则返回 true，否则返回 false。   &emsp;&emsp;“= = =”也称为严格相等运算符（strict equality）（有时也称做恒等运算符（identity operator）），它用来检测两个操作数是否严格相等。“==”运算符称做相等运算符（equality operator），它用来检测两个操作数是否相等，这里“相等”的定义非常宽松，可以允许进行类型转换。 &emsp;&emsp;“!=”和“！= =”运算符的检测规则是“= =”和“= = =”运算符的求反。如果两个值通过“= =”的比较结果为 true，那么通过“！=”的比较结果则为 false。如果两值通过 “= = =”的比较结果为 true，那么通过“！= =”的比较结果则为 false。“!=”称做“不相等”、“!= =”称做“不严格相等”。  ##### 严格相等运算符“===”计算规则  - 如果两个值类型不相同，则它们不相等。 - 如果两个值都是 nul1 或者都是 undefined，则它们不相等。如果两个值都是布尔值 true 或都是布尔值 false，则它们相等。 - 如果其中一个值是 NaN，或者两个值都是 NaN，则它们不相等。 - 如果两个值为数字且数值相等，则它们相等。如果一个值为 0，另一个值为-0，则它们同样相等。 - 如果两个值为字符串，且所含的对应位上的 16 位数（参照 3.2 节）完全相等，则它们相等。如果它们的长度或内容不同，则它们不等。两个字符串可能含义完全一样且所显示出的字符也一样，但具有不同编码的 16 位值。JavaScript 并不对 Unicode 进行标准化的转换，因此像这样的字符串通过“= = =”和“= =”运算符的比较结果也不相等。 - 如果两个引用值指向同一个对象、数组或函数，则它们是相等的。如果指向不同的对象，则它们是不等的，尽管两个对象具有完全一样的属性。  ##### 相等运算符“==”计算规则  - 如果两个操作数的类型相同，则和上文所述的严格相等的比较规则一样。如果严格相等，那么比较结果为相等。如果它们不严格相等，则比较结果为不相等。 - 如果两个操作数类型不同，“==”相等操作符也可能会认为它们相等。检测相等将会遵守如下规则和类型转换： - - 如果一个值是 null，另一个是 undefined，则它们相等。 - - 如果一个值是数字，另一个是字符串，先将字符串转换为数字，然后使用转换后的值进行比较。 - - 如果其中一个值是 true，则将其转换为 1 再进行比较。如果其中一个值是 false，则将其转换为 0 再进行比较。 - - 如果一个值是对象，另一个值是数字或字符串，则使用转换规则将对象转换为原始值，然后再进行比较。对象通过 toString（）方法或者 value0f（）方法转换为原始值。JavaScript 语言核心的内置类首先尝试使用 valueof（），再尝试使用 toString（），除了日期类，日期类只使用 toString（）转换。那些不是 JavaScript 语言核心中的对象则通过各自的实现中定义的方法转换为原始值。 - - 其他不同类型之间的比较均不相等。  #### 比较运算符  &emsp;&emsp;比较操作符的操作数可能是任意类型。然而，只有数字和字符串才能真正执行比较操作，因此那些不是数字和字符串的操作数都将进行类型转换，类型转换规则如下：  - 如果操作数为对象，那么这个对象将依照转换规则转换为原始值：如果 valueof（）返回一个原始值，那么直接使用这个原始值。否则，使用 tostring（）的转换结果进行比较操作。 - 在对象转换为原始值之后，如果两个操作数都是字符串，那么将依照字母表的顺序对两个字符串进行比较，这里提到的“字母表顺序”是指组成这个字符串的 16 位 Unicode 字符的索引顺序。 - 在对象转换为原始值之后，如果至少有一个操作数不是字符串，那么两个操作数都将转换为数字进行数值比较。0 和一 0 是相等的。Infinity 比其他任何数字都大（除了 Infinity 本身），-Infinity 比其他任何数字都小（除了它自身）。如果其中一个操作数是（或转换后是）NaN，那么比较操作符总是返回 false。  &emsp;&emsp;需要注意的是，JavaScript 字符串是一个由 16 位整数值组成的序列，字符串的比较也只是两个字符串中的字符的数值比较。由 Unicode 定义的字符编码顺序和任何特定语言或者本地语言字符集中的传统字符编码顺序不尽相同。注意，字符串比较是区分大小写的，所有的大写的 ASCII 字母都“小于”小写的 ASCII 字母。   &emsp;&emsp;参照 String.localCompare（）方法来获取更多字符串比较的相关信息，String.1ocalCompare（）方法更加健壮可靠，这个方法参照本地语言的字母表定义的字符次序。对于那些不区分字母大小写的比较来说，则需要首先将字符串转全部换为小写字母或者大写字母，通过 String.toLowerCase（）和 String.toupperCase（）做大小写的转换。  #### in 运算符  &emsp;&emsp;in 运算符希望它的左操作数是一个字符串或可以转换为字符串，希望它的右操作数是一个对象。如果右侧的对象拥有一个名为左操作数值的属性名，那么表达式返回 true，例如：  ```js var point={x：1，y：1}；//定义一个对象 "x" in point//=>true：对象有一个名为"x“的属性 “z" in point//=>false：对象中不存在名为“z”的属性 "tostring" in point//=>true：对象继承了toString（）方法 var data=[7，8，9]；//拥有三个元素的数组 "o" in data//=>true：数组包含元素”0” 1 in data//=>true：数字转换为字符串 3 in data//=>false：没有索引为3的元素 ```  #### instanceof 运算符  &emsp;&emsp;instanceof 运算符希望左操作数是一个对象，右操作数标识对象的类。如果左侧的对象是右侧类的实例，则表达式返回 true；否则返回 false。  ```js var d=new Date（）；//通过Date（）构造函数来创建一个新对象 d instanceof Date；//计算结果为true，d是由Date（）创建的 d instanceof Object；//计算结果为true，所有的对象都是0bject的实例 d instanceof Number；//计算结果为false，d不是一个Number对象 vara=[1，2，3]；//通过数组直接量的写法创建一个数组 a instanceof Array；//计算结果为true，a是一个数组 a instanceof Object；//计算结果为true，所有的数组都是对象 a instanceof RegExp；//计算结果为false，数组不是正则表达式 ```  &emsp;&emsp;需要注意的是，所有的对象都是 0bject 的实例。当通过 instanceof 判断一个对象是否是一个类的实例的时候，这个判断也会包含对“父类”（superclass）的检测。如果 instanceof 的左操作数不是对象的话，instanceof 返回 false。如果右操作数不是函数，则抛出一个类型错误异常。  ### 逻辑表达式  #### 逻辑与（&&）  &emsp;&emsp;一般来讲，当“  ”右侧的表达式具有副作用的时候（赋值、递增、递减和函数调用表达式）要格外小心。因为这些带有副作用的表达式的执行依赖于左操作数的计算结果。  #### 逻辑或（||）  &emsp;&emsp;和“&8”运算符一样，同样应当避免右操作数包含一些具有副作用的表达式，除非你目地明确地在右侧使用带副作用的表达式，而有可能不会计算右侧的表达式。  #### 逻辑非（！）  &emsp;&emsp;“！”运算符是一元运算符。它放置在一个单独的操作数之前。它的目的是将操作数的布尔值进行求反。   &emsp;&emsp;作为一个一元运算符，“！”具有很高的优先级，并且和操作数紧密绑定在一起。如果你希望对类似 p8&q 的表达式做求反操作，则需要使用圆括号：！（p&&q）。  ### 赋值表达式  &emsp;&emsp;“=”具有非常低的优先级，通常在一个较长的表达式中用到了一条赋值语句的值的时候，需要补充圆括号以保证正确的运算顺序。  ```js (a = b) == 0; ```  &emsp;&emsp;赋值操作符的结合性是从右至左，也就是说，如果一个表达式中出现了多个赋值运算符，运算顺序是从右到左。  #### 带操作的赋值运算  ![image](https://s1.ax1x.com/2018/10/29/igYGef.png)  &emsp;&emsp;只有在 data[i++]包含具有副作用的表达式（比如函数调用和赋值操作）的时候，两者才不等价。比如，下面两个表达式就不等价：  ```js data[i++]*=2； data[i++]=data[i++]*2； ```  ### 表达式计算  &emsp;&emsp;和其他很多解释性语言一样，JavaScript 同样可以解释运行由 JavaScript 源代码组成的字符串，并产生一个值。JavaScript 通过全局函数 eval（）来完成这个工作。  #### eval()讲解  &emsp;&emsp;eva1（）只有一个参数。如果传入的参数不是字符串，它直接返回这个参数。如果参数是字符串，它会把字符串当成 JavaScript 代码进行编译（parse），如果编译失败则抛出一个语法错误（SyntaxError）异常。如果编译成功，则开始执行这段代码，并返回字符串中的最后一个表达式或语句的值，如果最后一个表达式或语句没有值，则最终返回 undefined。如果字符串抛出一个异常，这个异常将把该调用传递给 eval（）。   &emsp;&emsp;关于 eva1（）最重要的是，它使用了调用它的变量作用域环境。也就是说，它查找变量的值和定义新变量和函数的操作和局部作用域中的代码完全一样。如果一个函数定义了一个局部变量 x，然后调用 eval（"x"），它会返回局部变量的值。如果它调用 eval（"x=1"），它会改变局部变量的值。如果函数调用了 eval（"var y=3；"），它声明一个新的局部变量 y。同样地，一个函数可以通过如下代码声明一个局部函数：  ```js eval（"function f（）{return x+1；}"）； ```  &emsp;&emsp;如果在最顶层代码中调用 eval（），当然，它会作用于全局变量和全局函数。   &emsp;&emsp;需要注意的是，传递给 eva1（）的字符串必须在语法上讲的通—不能通过 eval（）往函数中任意粘贴代码片段，比如，eval（"return；"）是没有意义的，因为 return 只有在函数中才起作用，并且事实上，eva1 的字符串执行时的上下文环境和调用函数的上下文环境是一样的，这不能使其作为函数的一部分来运行。如果字符串作为一个单独的脚本是有语义的（就像诸如 x=0 的短代码），那么将其传递给 eva1（）作参数是完全没有问题的，否则，eval（）将抛出语法错误异常。  #### 全局 eval（）(了解)  &emsp;&emsp;ECMAScript5 是反对使用 EvalError 的，并且规范了 eval（）的行为。“直接的 eval”，当直接使用非限定的“eval”名称（eval 看起来像是一个保留字）来调用 eval（）函数时，通常称为“直接 eval”（direct eval）。直接调用 eva1（）时，它总是在调用它的上下文作用域内执行。其他的间接调用则使用全局对象作为其上下文作用域，并且无法读、写、定义局部变量和函数。下面有一段示例代码：  ```js var geval=eval；//使用别名调用eval将是全局eval var x="global"，y="global"；//两个全局变量 function f（）{//函数内执行的是局部eval     var x="local"；//定义局部变量     eval（"x+=\'changed\'；"）；//直接eval更改了局部变量的值     return x；     }//返回更改后的局部变量 function g（）{//这个函数内执行了全局eval     var y="1ocal"；//定义局部变量     geval（"y+=\'changed\'；"）；//间接调用改变了全局变量的值     return y；     }//返回未更改的局部变量 console.1og（f（），x）；//更改了局部变量：输出"local changed global"： console.1og（g（），y）；//更改了全局变量：输出“local globalchanged”： ```  #### 严格 eval（）  &emsp;&emsp;ECMAScript 5 严格模式（参照 5.7.3 节）对 eval（）函数的行为施加了更多的限制，甚至对标识符 eval 的使用也施加了限制。当在严格模式下调用 eva1（）时，或者 eva1（）执行的代码段以“use strict”指令开始，这里的 eva1（）是私有上下文环境中的局部 eval。也就是说，在严格模式下，eval 执行的代码段可以查询或更改局部变量，但不能在局部作用域中定义新的变量或函数。   &emsp;&emsp;此外，严格模式将“eval”列为保留字，这让 eva1（）更像一个运算符。不能用一个别名覆盖 eva1（）函数。并且变量名、函数名、函数参数或者异常捕获的参数都不能取名为“eval”。  ### 其他运算符  #### 条件运算符（？：）  &emsp;&emsp;条件运算符的操作数可以是任意类型。第一个操作数当成布尔值，如果它是真值，那么将计算第二个操作数，并返回其计算结果。否则，如果第一个操作数是假值，那么将计算第三个操作数，并返回其计算结果。第二个和第三个操作数总是会计算其中之一，不可能两者同时执行。  #### typeof 运算符  &emsp;&emsp;typeof 是一元运算符，放在其单个操作数的前面，操作数可以是任意类型。返回值为表示操作数类型的一个字符串。表 4-3 列出了任意值在 typeof 运算后的返回值： ![image](https://s1.ax1x.com/2018/10/29/igY0ln.png) &emsp;&emsp;尽管 JavaScript 中的函数是对象的一种，但 typeof 运算符还是将函数特殊对待，对函数做 typeof 运算有着特殊的返回值。在 JavaScript 中，函数和“可执行的对象”（callable object）有着微妙的区别。所有的函数都是可执行的（callable），但是对象也有可能是可执行的，可以像调用函数一样调用它，但它并不是一个真正的函数。ECMAScript 5 规范则扩充至所有可执行对象，包括内置对象（native object）和宿主对象（host object），所有可执行对象进行 typeof 运算都将返回“function”。   &emsp;&emsp;大多数浏览器厂商也将 JavaScript 的原生函数对象（native function object）当成它们的宿主对象的方法来使用。但微软却一直将非原生可执行对象（non-native callableobject）当成其客户端的方法来使用，在 IE9 之前的版本中，非原生可执行对象的 typeof 运算将返回“object”，尽管它们的行为和函数非常相似。而在 IE9 中，这些客户端方法是真正的内置函数对象（native function object）。  #### delete 运算符  &emsp;&emsp;delete 是一元操作符，它用来删除对象属性或者数组元素。就像赋值、递增、递减运算符一样，delete 也是具有副作用的，它是用来做删除操作的，不是用来返回一个值的。 &emsp;&emsp;delete 希望他的操作数是一个左值，如果它不是左值，那么 delete 将不进行任何操作同时返回 true。否则，delete 将试图删除这个指定的左值。如果删除成功，delete 将返回 true。   &emsp;&emsp;然而并不是所有的属性都可删除，一些内置核心和客户端属性是不能删除的，用户通过 var 语句声明的变量不能删除。同样，通过 function 语句定义的函数和函数参数也不能删除。   &emsp;&emsp;在 ECMAScript 5 严格模式中，如果 delete 的操作数是非法的，比如变量、函数或函数参数，delete 操作将抛出一个语法错误（SyntaxError）异常，只有操作数是一个属性访问表达式的时候它才会正常工作。在严格模式下，delete 删除不可配置的属性时会抛出一个类型错误异常。在非严格模式下，这些 delete 操作都不会报错，只是简单地返回 false，以表明操作数不能执行删除操作。  ```js var o={x：1，y：2}；//定义一个变量，初始化为对象 delete o.x；//删除一个对象属性，返回true typeof o.x；//属性不存在，返回“undefined” delete o.x；//删除不存在的属性，返回true delete o；//不能删除通过var声明的变量，返回false ∥在严格模式下，将抛出一个异常 delete 1；//参数不是一个左值，返回true this.x=1；//给全局对象定义一个属性，这里没有使用var delete x；//试图删除它，在非严格模式下返回true //在严格模式下会抛出异常，这时使用“delete this.x“来代替 x；//运行时错误，没有定义x ```  #### void 运算符  &emsp;&emsp;void 是一元运算符，它出现在操作数之前，操作数可以是任意类型。这个运算符并不是经常使用：操作数会照常计算，但忽略计算结果并返回 undefined。由于 void 会忽略操作数的值，因此在操作数具有副作用的时候使用 void 来让程序更具语义。   &emsp;&emsp;这个运算符最常用在客户端的 URL—javascript:URL 中，在 URL 中可以写带有副作用的表达式和运算符|，而 void 则让浏览器不必显示这个表达式的计算结果。例如，经常在 HTML 代码中的<a\\>标签里使用 void 运算符：  ```html <a href="javascript:void window.open（）；">打开一个新窗口</a） ```  #### 逗号运算符（，）  &emsp;&emsp;逗号运算符是二元运算符，它的操作数可以是任意类型。它首先计算左操作数，然后计算右操作数，最后返回右操作数的值。   &emsp;&emsp;总是会计算左侧的表达式，但计算结果忽略掉，也就是说，只有左侧表达式具有副作用，才会使用逗号运算符让代码变得更通顺。逗号运算符最常用的场景是在 for 循环中，这个 for 循环通常具有多个循环变量。  ```js //for循环中的第一个逗号是var语句的一部分 //第二个逗号是逗号运算符 //它将两个表达式（i++和j--）放在一条（for循环中的）语句中 for（var i=0，j=10；i<j；i+，j--） console.1og（i+j）； ``` '},{title:"【读书笔记】《JavaScript权威指南》第3章类型、值和变量",path:"/posts/%E3%80%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%91%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B%E7%AC%AC3%E7%AB%A0%E7%B1%BB%E5%9E%8B%E3%80%81%E5%80%BC%E5%92%8C%E5%8F%98%E9%87%8F.html",strippedContent:' ## 概念（了解）  &emsp;&emsp;计算机程序的运行需要对值（value）进行操作。   &emsp;&emsp;在编程语言中，能够表示并操作的值的类型称做数据类型（type），编程语言最基本的特性就是能够支持多种数据类型。   &emsp;&emsp;当程序需要将值保存起来以备将来使用时，便将其赋值给（将值“保存”到）一个变量（variable）。变量是一个值的符号名称，可以通过名称来获得对值的引用。  ## js 数据类型“一览众山小”（掌握）  &emsp;&emsp;本书在此章节开头写了一个很好的概括，我看过许多博文和视频，他们都没有讲得如此的清楚，大多数人都是把重心放在了 api 上面，然而作者在这里并没有讲 api，真正的讲了数据类型，让我对 js 有了一个整体的认知，在我学习 python 等其他语言时，我发现它们的数据设计都是大同小异的，读了这篇文章真的是让我更容易学习计算机语言，这个概括在后面每一章开头都不会重现的，有许多人看着冗长就直接跳过了，非常可惜。因此本段不会做太多的删减。  ### 原始类型  &emsp;&emsp;JavaScript 的数据类型分为两类：原始类型（primitive type）和对象类型（object type）。JavaScript 中的原始类型包括数字、字符串和布尔值。   &emsp;&emsp;JavaScript 原始类型中有两个特殊的原始值：null（空）和 undefined（未定义），它们不是数字、字符串和布尔值。它们通常分别代表了各自特殊类型的唯一的成员。  ### 对象类型  &emsp;&emsp;javaScript 中除了数字、字符串、布尔值、nu11 和 undefined 之外的就是对象了。对象（object）是属性（property）的集合，每个属性都由“名/值对”（值可以是原始值，比如数字、字符串，也可以是对象）构成。  #### 数组  &emsp;&emsp;普通的 JavaScript 对象是“命名值”的无序集合。JavaScript 同样定义了一种特殊对象一一数组（array），表示带编号的值的有序集合。JavaScript 为数组定义了专用的语法，使数组拥有一些和普通对象不同的特有行为特性。  #### 函数  &emsp;&emsp;JavaScript 还定义了另一种特殊对象一一函数。函数是具有与它相关联的可执行代码的对象，通过调用函数来运行可执行代码，并返回运算结果。和数组一样，函数的行为特征和其他对象都不一样。JavaScript 为使用函数定义了专用语法。对于 JavaScript 函数来讲，最重要的是，它们都是真值，并且 JavaScript 可以将它们当做普通对象来对待。  #### 类对象  &emsp;&emsp;如果函数用来初始化（使用 new 运算符）一个新建的对象，我们称之为构造函数（constructor）。每个构造函数定义了一一类（class）对象一一由构造函数初始化的对象组成的集合。类可以看做是对象类型的子类型。除了数组（Array）类和函数（Function）类之外，JavaScript 语言核心定义了其他三种有用的类。日期（Date）类定义了代表日期的对象。正则（RegExp）类定义了表示正则表达式（一种强大的模式匹配工具，在第 10 章会讲到）的对象。错误（Error）类定义了那些表示 JavaScript 程序中运行时错误和语法错误的对象。可以通过定义自己的构造函数来定义需要的类。  #### 内存管理  &emsp;&emsp;JavaScript 解释器有自己的内存管理机制，可以自动对内存进行垃圾回收（garbage collection）。这意味着程序可以按需创建对象，程序员则不必担心这些对象的销毁和内存回收。当不再有任何引用指向一个对象，解释器就会知道这个对象没用了，然后自动回收它所占用的内存资源。  #### 面向对象  &emsp;&emsp;JavaScript 是一种面向对象的语言。不严格地讲，这意味着我们不用全局的定义函数去操作不同类型的值，数据类型本身可以定义方法（method）来使用值。例如，要对数组 a 中的元素进行排序，不必要将 a 传入 sort()函数，而是调用 a 的一个方法 sort()：  ```js a.sort()；//sort(a)的面向对象的版本 ```  &emsp;&emsp;第 9 章将会讲述方法的定义。从技术上讲，只有 JavaScript 对象才能拥有方法。然而，数字、字符串和布尔值也可以拥有自己的方法。在 JavaScript 中，只有 null 和 undefined 是无法拥有方法的值。  #### 可变类型和不可变类型  &emsp;&emsp;JavaScript 的类型可以分为原始类型和对象类型，也可分为可以拥有方法的类型和不能拥有方法的类型，同样可分为可变（mutable）类型和不可变（immutable）类型。可变类型的值是可修改的。对象和数组属于可变类型：JavaScript 程序可以更改对象属性值和数组元素的值。数字、布尔值、null 和 undefined 属于不可变类型——比如，修改一个数值的内容本身就说不通。字符串可以看成由字符组成的数组，你可能会认为它是可变的。然而在 JavaScript 中，字符串是不可变的：可以访问字符串任意位置的文本，但 JavaScript 并未提供修改已知字符串的文本内容的方法。  #### 数据类型转换  &emsp;&emsp;JavaScript 可以自由地进行数据类型转换。比如，如果在程序期望使用字符串的地方使用了数字，JavaScript 会自动将数字转换为字符串。如果在期望使用布尔值的地方使用了非布尔值，JavaScript 也会进行相应的转换。JavaScript 中灵活的类型转换规则对“判断相等”（equality）的定义亦有影响。  #### 变量和作用域  &emsp;&emsp;JavaScript 变量是无类型的（untyped），变量可以被赋予任何类型的值，同样一个变量也可以重新赋予不同类型的值。使用 var 关键字来声明（declare）变量。JavaScript 采用词法作用域（lexical scoping）。不在任何函数内声明的变量称做全局变量（global variable），它在 JavaScript 程序中的任何地方都是可见的。在函数内声明的变量具有函数作用域（function scope），并且只在函数内可见。  ## 数字  ### 范围（了解）  &emsp;&emsp;和其他编程语言不同，JavaScript 不区分整数值和浮点数值。JavaScript 中的所有数字均用浮点数值表示。JavaScript 采用 IEEE 754 标准定义的 64 位浮点格式表示数字，这意味着它能表示的最大值是+-1.7976931348623157×10308，最小值是+-5×10-324。   &emsp;&emsp;按照 JavaScript 中的数字格式，能够表示的整数范围是从-9007199254740992~ 9007 199254740992（即-2^53~2^53），包含边界值。如果使用了超过此范围的整数，则无法保证低位数字的精度。然而需要注意的是，JavaScript 中实际的操作（比如数组索引，以及第 4 章讲到的位操作符）则是基于 32 位整数。  ### 整型直接量（了解）  &emsp;&emsp;除了十进制的整型直接量，JavaScript 同样能识别十六进制（以 16 为基数）值。所谓十六进制的直接量是指以“0x”或“0X”为前缀，其后跟随十六进制数串的直接量。下面是十六进制整型直接量的例子：  ```js Oxff; //15*16+15=255（十进制） 0xcafe911; ```  &emsp;&emsp;尽管 ECMAScript 标准不支持八进制直接量，但 JavaScript 的某些实现可以允许采用八进制（基数为 8）形式表示整数。八进制直接量以数字 0 开始，其后跟随一个由 0~7（包括 0 和 7）之间的数字组成的序列，例如：  ```js 0377; //3*64+7*8+7=255（十进制） ```  &emsp;&emsp;由于某些 JavaScript 的实现支持八进制直接量，而有些不支持，因此最好不要使用以 0 为前缀的整型直接量，毕竟我们也无法得知当前 JavaScript 的实现是否支持八进制的解析。 在 ECMAScript6 的严格模式下，八进制直接量是明令禁止的。  ### 浮点型直接量（了解）  ```js 3.14; 2345.789; 0.333333333333333333; 6.02e23; //6.02×10^23 1.4738223e-32; //1.4738223×10^32 ```  ### JavaScript 中的算术运算（掌握）  &emsp;&emsp;JavaScript 程序是使用语言本身提供的算术运算符来进行数字运算的。这些运算符包括加法运算符（+）、减法运算符（一）、乘法运算符（\\*）、除法运算符（/）和求余（求整除后的余数）运算符（%），除了基本的运算符外，JavaScript 还支持更加复杂的算术运算，这些复杂运算通过作为 Math 对象的属性定义的函数和常量来实现。  #### 溢出（overflow）  &emsp;&emsp;当数字运算结果超过了 JavaScript 所能表示的数字上限（溢出），结果为一个特殊的无穷大（infinity）值，在 JavaScript 中以 Infinity 表示。同样地，当负数的值超过了 JavaScript 所能表示的负数范围，结果为负无穷大，在 JavaScript 中以-Infinity 表示。 无穷大值的行为特性和我们所期望的是一致的：基于它们的加、减、乘和除运算结果还是无穷大值（当然还保留它们的正负号）。  #### 下溢（underflow）  &emsp;&emsp;下溢（underflow）是当运算结果无限接近于零并比 JavaScript 能表示的最小值还小的时候发生的一种情形。这种情况下，JavaScript 将会返回 0。当一个负数发生下溢时，JavaScript 返回一个特殊的值“负零”。这个值（负零）几乎和正常的零完全一样，JavaScript 程序员很少用到负零。  #### 被零整除与 NaN  &emsp;&emsp;被零整除在 JavaScript 并不报错：它只是简单的返回无穷大（Infinity）或负无穷大（-Infinity）。但有一个例外，零除以零是没有意义的，这种整除运算结果也是一个非数字（not-a-number）值，用 NaN 表示。无穷大除以无穷大、给任意负数作开方运算或者算术运算符与不是数字或无法转换为数字的操作数一起使用时都将返回 NaN。   &emsp;&emsp;JavaScript 中的非数字值有一点特殊：它和任何值都不相等，包括自身。也就是说，没办法通过 x==NaN 来判断变量 x 是否是 NaN。相反，应当使用 x！=x 来判断，当且仅当 x 为 NaN 的时候，表达式的结果才为 true。函数[isNaN()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/isNaN)的作用与此类似，如果参数是 NaN 或者是一个非数字值（比如字符串和对象），则返回 true。JavaScript 中有一个类似的函数[isFinite()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/isFinite)，在参数不是 NaN、Infinity 或-Infinity 的时候返回 true。  #### 负零值  负零值同样有些特殊，它和正零值是相等的（甚至使用 JavaScript 的严格相等测试来判断）。这意味着这两个值几乎一模一样，除了作为除数之外：  ```js var zero = 0; //正常的零值 zero === negz; //=>true：正零值和负零值相等 1 / zero === 1 / negz; //=>false：正无穷大和负无穷大不等 ```  ### 二进制浮点数和四舍五入错误（掌握）  &emsp;&emsp;实数有无数个，但 JavaScript 通过浮点数的形式只能表示其中有限的个数（确切地说是 18437736874454810627 个）。也就是说，当在 JavaScript 中使用实数的时候，常常只是真实值的一个近似表示。   &emsp;&emsp;JavaScript 采用了 IEEE-754 浮点数表示法（几乎所有现代编程语言所采用），这是一种二进制表示法，可以精确地表示分数，比如 1/2、1/8 和 1/1024。遗憾的是，我们常用的分数（特别是在金融计算方面）都是十进制分数 1/10、1/100 等。二进制浮点数表示法并不能精确表示类似 0.1 这样简单的数字。   &emsp;&emsp;JavaScript 中的数字具有足够的精度，并可以极其近似于 0.1。但事实是，数字不能精确表述的确带来了一些问题。看下这段代码：  ```js var x = 0.3 - 0.2; //30美分减去20美分 var y = 0.2 - 0.1; //20美分减去10美分 x == y; //=>false：两值不相等！ x == 0.1; //=>false:.3-.2不等于.1 y == 0.1; //=>true:.2-.1等于.1 ```  &emsp;&emsp;JavaScript 的未来版本或许会支持十进制数字类型以避免这些舍入问题。在这之前你可能更愿意使用大整数进行重要的金融计算，例如，要使用整数“分”而不要使用小数“元”进行基于货币单位的运算。  ### 日期和时间（了解）  &emsp;&emsp;JavaScript 语言核心包括 Date()构造函数，用来创建表示日期和时间的对象。这些日期对象的方法为日期计算提供了简单的 API。日期对象不像数字那样是基本数据类型。详细细节在后面章节会说到。  ## 文本  ### UTF-16 编码（了解）  &emsp;&emsp;JavaScript 采用 UTF-16 编码的 Unicode 字符集，JavaScript 字符串是由一组无符号的 16 位值组成的序列。最常用的 Unicode 字符都是通过 16 位的内码表示，并代表字符串中的单个字符。   &emsp;&emsp;那些不能表示为 16 位的 Unicode 字符则遵猫 UTF-16 编码规则——用两个 16 位值组成的一个序列（亦称做“代理项对”）表示。这意味着一个长度为 2 的 JavaScript 字符串（两个 16 位值）有可能表示一个 Unicode 字符。  ```js var p="π";      //π由16位内码表示0x03c0 var e="𝑒;     //𝑒17位内码表示0x1d45; p.length;       //1 e.length;       //2 //在ECMAScript 6中，有一个新的Unicode转义符，能让你指定任意的码位（不用再管是否是16位） console.log(\'\\u{1d452}\'); //𝑒 ```  ### 字符串拆分成数行（掌握）  &emsp;&emsp;在 ECMAScript3 中，字符串直接量必须写在一行中，而在 ECMAScript5 中，字符串直接量可以拆分成数行，每行必须以反斜线（\\）结束，反斜线和行结束符都不算是字符串直接量的内容。如果希望在字符串直接量中另起一行，可以使用转义字符\\n（后续会有介绍）。  ```js "two\\nlines"//这里定义了一个显示为两行的字符串 "one\\ 1ong\\ line" //用三行代码定义了显示为单行的字符串，只在ECMAScript5中可用 ```  ### 引号嵌套（了解）  &emsp;&emsp;需要注意的是，当使用单引号来定界字符串时，需要格外小心英文中的缩写和所有格写法，比如 can\'t 和 O\'Reily\'s。因为撤号和单引号是同一个字符，所以必须使用反斜线(\\\\)来转义（转义符将在下一章讲解）所有的撤号。   &emsp;&emsp;当 JavaScript 代码和 HTML 代码混杂在一起的时候，最好在 JavaScript 和 HTML 代码中各自使用独立的引号风格。  ```html <button onclick="alert（"Thank you"）">Click Me</button> ```  ### 转义字符（了解）  &emsp;&emsp;在 JavaScript 字符串中，反斜线（\\）有着特殊的用途，反斜线符号后加一个字符，就不再表示它们的字面含义了，比如，\\n 就是一个转义字符\\，它表示的是一个换行符。  ```js \\o NUL字符（\\u0000) \\b 退格符(\\u0008) \\t 水平制表符(\\u0009) \\n 换行符(\\u000A) \\v 垂直制表符(\\u000B) \\f 换页符(\\u000C) \\r 回车符(\\u000D) \\" 双引号(\\u0022) \\\' 撇号或单引号(\\u0027) \\\\ 反斜线(\\u005C) \\xXX 由两位十六进制数XX指定的Latin-1字符 \\uXXXX 由4位十六进制数XXXX指定的Unicode字符 ```  &emsp;&emsp;"\\\\n"这个转义字符则常与 alert()搭配使用。   &emsp;&emsp;如果一定要在 document.write()当中使用“\\\\n”，必须包裹在 HTML 的\\<PRE>标记里才有作用。（一般用\\<br>）。  ## 布尔值（了解）  &emsp;&emsp;任意 JavaScript 的值都可以转换为布尔值。下面这些值会被转换成 false：  ```js undefined; null; 0; NaN; (\'\'); //空字符串 ```  &emsp;&emsp;所有其他值，包括所有对象（数组）都会转换成 true。false 和上面 6 个可以转换成 false 的值有时称做“假值”（falsy value），其他值称做“真值”（truthy value）。   &emsp;&emsp;JavaScript 期望使用一个布尔值的时候，假值会被当成 false，真值会被当成 true。  ## null 和 undefined（掌握）  ### null  &emsp;&emsp;对 null 执行 typeof 预算，结果返回字符串“object”，也就是说，可以将 nu11 认为是一个特殊的对象值，含义是“非对象”。但实际上，通常认为 nu11 是它自有类型的唯一一个成员，它可以表示数字、字符串和对象是“无值”的。  ### undefined  &emsp;&emsp;ECMAScript5 中做了修正；undefined 在该版本中是只读的。实际上，使用“.”和“[0”来存取这两个值的成员或方法都会产生一个类型错误。nul1 和 undefined 都不包含任何属性和方法。   &emsp;&emsp;你或许认为 undefined 是表示系统级的、出乎意料的或类似错误的值的空缺，而 nu11 是表示程序级的、正常的或在意料之中的值的空缺。如果你想将它们赋值给变量或者属性，或将它们作为参数传入函数，最佳选择是使用 null。   &emsp;&emsp;**联想延伸**：[因此 Object.prototype.\\_\\_proto\\_\\_ 是 null,而不是 undefined](https://segmentfault.com/q/1010000005795507)。  ## 全局对象（掌握）  &emsp;&emsp;当 JavaScript 解释器启动时（或者任何 Web 浏览器加载新页面的时候），它将创建一个新的全局对象，并给它一组定义的初始属性，全局对象的属性是全局定义的符号，JavaScript 程序可以直接使用。  - 全局属性，比如 undefined、Infinity 和 NaN - 全局函数，比如 isNaN（）、parseInt（）和 eval（） - 构造函数，比如 Date（）、RegExp（）、String（）、Object（）和 Array（） - 全局对象，比如 Math 和 JSON  ```js var global = this; //定义一个引用全局对象的全局变量 ```  ## 包装对象（掌握）  ### 概念  &emsp;&emsp;存取字符串、数字或布尔值的属性时创建的临时对象称做包装对象。  ### 读取属性或方法  &emsp;&emsp;字符串既然不是对象，为什么它会有属性呢？只要引用了字符串 s 的属性，JavaScript 就会将字符串值通过调用 new String(s)的方式转换成对象，这个对象继承了字符串的方法并被用来处理属性的引用。一旦属性引用结束，这个新创建的对象就会销毁（其实在实现上并不一定创建或销毁这个临时对象，然而整个过程看起来是这样）。   &emsp;&emsp;同字符串一样，数字和布尔值也具有各自的方法：通过 Number()和 Boolean()构造函数创建一个临时对象，这些方法的调用均是来自于这个临时对象。nul1 和 undefined 没有包装对象：访问它们的属性会造成一个类型错误。  ### 设置属性或方法  &emsp;&emsp;在读取字符串、数字和布尔值的属性值（或方法）的时候，表现的像对象一样。但如果你试图给其属性赋值，则会忽略这个操作：修改只是发生在临时对象身上，而这个临时对象并未继续保留下来。  ```js var s="test"；//创建一个字符串 s.len=4；//给它设置一个属性 var t=s.len；//查询这个属性undefined ```  ### 原始值和包装对象  &emsp;&emsp;需要注意的是，可通过 String()，Number()或 Boolean()构造函数来显式创建包装对象：  ```js vars="test"，n=1，b=true；//一个字符串、数字和布尔值 var S=new String(s)；//一个字符串对象 var N=new Number(n)；//一个数值对象 var B=new Boolean(b)；//一个布尔对象 ```  &emsp;&emsp;JavaScript 会在必要时将包装对象转换成原始值，因此上段代码中的对象 S、N 和 B 常常，但不总是表现的和值 s、n 和 b 一样。“= =”等于运算符将原始值和其包装对象视为相等，但“===”全等运算符将它们视为不等。通过 typeof 运算符可以看到原始值和其包装对象的不同。  ## 不可变的原始值和可变的对象引用（掌握）  &emsp;&emsp;JavaScript 中的原始值（undefined、null、布尔值、数字和字符串）与对象（包括数组和函数）有着根本区别。原始值是不可更改的：任何方法都无法更改（或“突变”）一个原始值。  ### 值比较  &emsp;&emsp;原始值的比较是值的比较：只有在它们的值相等时它们才相等。对象值都是引用（reference），对象的比较均是引用的比较：当且仅当它们引用同一个基对象时，它们才相等。  ## 类型转换（掌握）  ![image](https://s1.ax1x.com/2018/10/26/i6lLFI.png)  ### 显式类型转换  &emsp;&emsp;做显式类型转换最简单的方法就是使用 Boolean()、Number()、String()或 Object()函数。当不通过 new 运算符调用这些函数时，它们会作为类型转换函数并按照上表所描述的规则做类型转换：  ```js Number(\'3\'); //=>3 String(false); //=>"false"或使用false.toString（） Boolean([]); //=>true Object(3); //=>new Number（3） ```  &emsp;&emsp;需要注意的是，除了 null 或 undefined 之外的任何值都具有 tostring()方法，这个方法的执行结果通常和 String()方法的返回结果一致。   &emsp;&emsp;如果试图把 null 或 undefined 转换为对象，则会像上表所描述的那样抛出一个类型错误（TypeError）。Object()函数在这种情况下不会抛出异常：它仅简单地返回一个新创建的空对象。  ### 隐式类型转换  JavaScript 中的某些运算符会做隐式的类型转换。如果“+”运算符的一个操作数是字符串，它将会把另外一个操作数转换为字符串。一元“+”运算符将其操作数转换为数字。同样，一元“！”运算符将其操作数转换为布尔值并取反。  ```js x + \'\' + //等价于String(x)   x; //等价于Number(x).也可以写成x-0 !!x; //.等价于Boolean(x).注意是双叹号 ```  ### 对象转换为原始值  &emsp;&emsp;new Boolean(false)是一个对象而不是原始值，它将转换为 true。 所有的对象继承了两个转换方法。第一个是 toString()，第二个是 valueOf()。  ```js [1，2，3].tostring()//=>“1，2，3" (function(x){f(x)；}).tostring()//=>"function（x）{\\n f（x）；\\n}" /\\d+/g.toString()//=>"/\\\\d+/g" new Date(2010，0，1).toString()//=>"Fri Jan 01 201000：00：00 CMT-0800（PST）" ```  ```js var d=new Date(2010，0，1)；//2010年1月1日（太平洋时间） d.valueOf()//=>1262332800000 ```  #### 对象到字符串的转换  &emsp;&emsp;如果对象具有 toString（）方法，则调用这个方法。如果对象没有 tostring（）方法，或者这个方法并不返回一个原始值，那么 JavaScript 会调用 valueOf（）方法。  #### 对象到数字的转换  &emsp;&emsp;如果对象具有 valueof（）方法，后者返回一个原始值，则 JavaScript 将这个原始值转换为数字（如果需要的话）并返回这个数字。否则，如果对象具有 toString（）方法，后者返回一个原始值，则 JavaScript 将其转换并返回。   &emsp;&emsp;对象转换为数字的细节解释了为什么空数组会被转换为数字 0 以及为什么具有单个元素的数组同样会转换成一个数字。数组继承了默认的 value0f（）方法，这个方法返回一个对象而不是一个原始值，因此，数组到数字的转换则调用 tostring（）方法。空数组转换成为空字符串，空字符串转换成为数字 0。含有一个元素的数组转换为字符串的结果和这个元素转换字符串的结果一样。如果数组只包含一个数字元素，这个数字转换为字符串，再转换回数字。  ## 作为属性的变量（掌握）  &emsp;&emsp;当声明一个 JavaScript 全局变量时，实际上是定义了全局对象的一个属性。   &emsp;&emsp;当使用 var 声明一个变量时，创建的这个属性是不可配置的，也就是说这个变量无法通过 delete 运算符删除。   &emsp;&emsp;如果你没有使用严格模式并给一个未声明的变量赋值的话，JavaScript 会自动创建一个全局变量。以这种方式创建的变最是全局对象的正常的可配值属性，并可以删除它们：  ```js var true var=1；//声明一个不可删除的全局变量 fakevar=2；//创建全局对象的一个可删除的属性 this.fakevar2=3；//同上delete truevar//=>false：变量并没有被删除 delete fakevar//=>true：变量被删除 delete this.fakevar2//=>true：变量被删除 ```  ### 声明上下文对象  &emsp;&emsp;JavaScript 全局变量是全局对象的属性，这是在 ECMAScript 规范中强制规定的。对于局部变量则没有如此规定，但我们可以想象得到，局部变量当做跟函数调用相关的某个对象的属性。ECMAScript 5 规范称为“声明上下文对象”（declarative environment record）。  ## 作用域链（掌握）  ### 作用域链含义  &emsp;&emsp;如果将一个局部变量看做是自定义实现的对象的属性的话，那么可以换个角度来解读变量作用域。   &emsp;&emsp;每一段 JavaScript 代码（全局代码或函数）都有一个与之关联的作用域链（scope chain）。这个作用域链是一个对象列表或者链表，这组对象定义了这段代码“作用域中”的变量。  ### 变量解析规则  &emsp;&emsp;当 JavaScript 需要查找变量 x 的值的时候（这个过程称做“变量解析”（variable resolution）），它会从链中的第一个对象开始查找，如果这个对象有一个名为 x 的属性，则会直接使用这个属性的值，如果第一个对象中不存在名为 x 的属性，JavaScript 会继续查找链上的下一个对象。如果第二个对象依然没有名为 x 的属性，则会继续查找下一个对象，以此类推。如果作用域链上没有任何一个对象含有属性 x，那么就认为这段代码的作用域链上不存在 x，并最终抛出一个引用错误（ReferenceError）异常。  ### 作用域链组成  &emsp;&emsp;在 JavaScript 的最顶层代码中（也就是不包含在任何函数定义内的代码），作用域链由一个全局对象组成。   &emsp;&emsp;在不包含嵌套的函数体内，作用域链上有两个对象，第一个是定义函数参数和局部变量的对象，第二个是全局对象。   &emsp;&emsp;在一个嵌套的函数体内，作用域链上至少有三个对象。  ### 函数定义和调用对于作用域链  &emsp;&emsp;当定义一个函数时，它实际上保存一个作用域链。当调用这个函数时，它创建一个新的对象来存储它的局部变量，并将这个对象添加至保存的那个作用域链上，同时创建一个新的更长的表示函数调用作用域的“链”。   &emsp;&emsp;对于嵌套函数来讲，事情变得更加有趣，每次调用外部函数时，内部函数又会重新定义一遍。因为每次调用外部函数的时候，作用域链都是不同的。内部函数在每次定义的时候都有微妙的差别一一在每次调用外部函数时，内部函数的代码都是相同的，而且关联这段代码的作用域链也不相同。   &emsp;&emsp;作用域链的概念对于理解 with 语句是非常有帮助的，同样对理解闭包的概念也至关重要。 '},{title:"【读书笔记】《JavaScript权威指南》第2章词法结构",path:"/posts/%E3%80%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%91%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B%E7%AC%AC2%E7%AB%A0%E8%AF%8D%E6%B3%95%E7%BB%93%E6%9E%84.html",strippedContent:' ## 词法结构的概念  &emsp;&emsp;编程语言的词法结构是一套基础性规则，用来描述如何使用这门语言来编写程序。   &emsp;&emsp;作为语法的基础，它规定了诸如变量名是什么样的、怎么写注释，以及程序语句之间如何分隔等规则。  ## 字符集  ### 范围（掌握）  &emsp;&emsp;JavaScript 程序是用 Unicode 字符集编写的。Unicode 是 ASCII 和 Latin-1 的超集，并支持地球上几乎所有在用的语言。ECMAScript 3 要求 JavaScript 的实现必须支持 Unicode2.1 及后续版本，ECMAScript5 则要求支持 Unicode3 及后续版本。  #### 联想延伸  &emsp;&emsp;静态 [String.fromCharCode()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/fromCharCode) 方法返回使用指定的 Unicode 值序列创建的字符串。经常在浏览器的按键事件使用，可以把索引值（按键码）转化成该键对应的的字符。   例：下例返回字符串 "ABC"  ```js String.fromCharCode(65, 66, 67); ```  &emsp;&emsp;注意：该方法返回一个字符串，而不是一个 String 对象。   &emsp;&emsp;由于 fromCharCode 是 String 的静态方法，所以应该像这样使用：String.fromCharCode()，而不是作为你创建的 String 对象的方法。   &emsp;&emsp;由于高位编码字符是用两个低位编码（lower value）表示形成的一个字符，因此[String.fromCodePoint()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/fromCodePoint) （ES6 规范的一部分）被用来返回这样一对低位编码，从而可以完全表示这些高位编码字符。  ### 区分大小写（掌握）  &emsp;&emsp;JavaScript 是区分大小写的语言。也就是说，关键字、变量、函数名和所有的标识符都必须采取一致的大小写形式，如果有一个字母大小写不相同就不是同一个，程序会抛出异常。  #### 需要注意  &emsp;&emsp;HTML 并不区分大小写（尽管 XHTML 区分大小写）。由于它和客户端 JavaScript 联系紧密，因此这点区别很容易混淆。   &emsp;&emsp;许多客户端 JavaScript 对象和属性与它们所表示的 HTML 标签和属性同名。在 HTML 中，这些标签和属性名可以使用大写也可以是小写，而在 JavaScript 中则必须是小写。例如，在 HTML 中设置事件处理程序时，onclick 属性可以写成 onClick，但在 JavaScript 代码（或者 XHTML 文档）中，必须使用小写的 onclick。  ### 空格、换行符（掌握）  &emsp;&emsp;JavaScript 会忽略程序中标识之间的空格。多数情况下，JavaScript 同样会忽略换行符。但是有少数情况不会忽略，在下文会讲到。  ### Unicode 转义序列（了解）  &emsp;&emsp;在有些老旧的计算机硬件和软件里，无法显示或输入 Unicode 字符全集。JavaScript 定义了一种特殊序列，使用 6 个 ASCII 字符来代表任意 16 位 Unicode 内码。这些 Unicode 转义序列均以\\u 为前缀，其后跟随 4 个十六进制数（使用数字以及大写或小写的字母 A~F 表示）。   &emsp;&emsp;这种 Unicode 转义写法可以用在 JavaScript 字符串直接量、正则表达式直接量和标识符中（关键字除外）。例如，如下两个 JavaScript 字符串是完全一样的：  ```js "cafe"= = ="caf\\uooe9"//.=> true ```  ### 标准化（了解）  &emsp;&emsp;Unicode 允许使用多种方法对同一个字符进行编码。比如，字符“é”可以使用 Unicode 字符\\uooE9 表示，也可以使用普通的 ASCII 字符 e 跟随一个语调符\\u0301。在文本编辑器中，这两种编码的显示结果一模一样，但它们的二进制编码表示是不一样的，在计算机里也不相等。Unicode 标准为所有字符定义了一个首选的编码格式，并给出了一个标准化的处理方式将文本转换为一种适合比较的标准格式，JavaScript 会认为它正在解析的程序代码已经是这种标准格式，不会再对其标识符、字符串或正则表达式作标准化处理。  ## 注释（掌握）  &emsp;&emsp;JavaScript 支持两种格式的注释。   &emsp;&emsp;在行尾“/”之后的文本都会被 JavaScript 当做注释忽略掉的。。  ```js //这里是单行注释 /*这里是一段注释*/ //这里是另一段注释 /*  *这又是一段注释  *这里的注释可以连写多行  *但不能有嵌套的注释  */ ```  ## 直接量（了解）  &emsp;&emsp;所谓直接量，就是程序中直接使用的数据值。下面列出的都是直接量：  ```js 12; //数字 1.2; //小数 (\'hello world\'); //字符串文本 (\'Hi\'); //另一个字符串 true; //布尔值 false / //另一个布尔值   javascript /   gi; //正则表达式直接量（用做模式匹配） null; //空 ```  &emsp;&emsp;具体类型讲解在后面章节。  ## 标识符和保留字  ### 标识符（掌握）  &emsp;&emsp;标识符就是一个名字。在 JavaScript 中，标识符用来对变量和函数进行命名，或者用做 JavaScript 代码中某些循环语句中的跳转位置的标记.   &emsp;&emsp;JavaScript 标识符必须以字母、下划线（）或美元符（\\$）开始。后续的字符可以是字母、数字、下划线或美元符（数字是不允许作为首字符出现的，以便 JavaScript 可以轻易区分开标识符和数字）。  #### 特殊字符（了解）  &emsp;&emsp;出于可移植性和易于书写的考虑，通常我们只使用 ASCII 字母和数字来书写标识符。然而需要注意的是，JavaScript 允许标识符中出现 Unicode 字符全集中的字母和数字。（从技术上讲，ECMAScript 标准也允许在标识符的首字符后面出现 Unicode 字符集中的 Mn 类、Mc 类和 Pc 类坪注 7）。由此，程序员也可以使用非英语语言或数学符号来书写标识符。  ``` var sí=true； var π=3.14； ```  ### 保留字（了解）  &emsp;&emsp;JavaScript 把一些标识符拿出来用做自己的关键字。因此，就不能再在程序中把这些关键字用做标识符了。值得注意的是，这些保留字中的一部分在 ES6 中已经使用了。此外，还有一些关键字在普通的 JS 代码中是合法的，但是在严格模式下是保留字。另外，JS 中内置了很多全局变量和函数，应当避免把他们的名字用作变量名和函数名。此处不做详细列出，自行搜索。  ## 可选的分号（掌握）  &emsp;&emsp;我见过很多初学者没有注意到这个问题，不知道 JavaScript 的分号大多情况是可以不写的，然后每次程序出错时，为了找出哪里没有分号，都看成“斗鸡眼”了，还浪费了时间。   &emsp;&emsp;需要注意的是，JavaScript 并不是在所有换行处都填补分号：只有在缺少了分号就无法正确解析代码的时候，JavaScript 才会填补分号。换句话讲（类似下面代码中的两处异常），如果当前语句和随后的非空格字符不能当成一个整体来解析的话，JavaScript 就在当前语句行结束处填补分号。   &emsp;&emsp;这里有个知乎讨论，[JavaScript 语句后应该加分号么？](https://www.zhihu.com/question/20298345)，这个[semi](https://github.com/yyx990803/semi) 是一个自动加分号的工具，其中还介绍了 Eslint 如何自动加分号。不过我劝你还是加分号，能够减少很多不必要的麻烦，多活几年。。。  ### 不能省略分号的情况（掌握）  &emsp;&emsp;声明变量时特别注意！  ```js a = 3; b = 4; var y = x + f(a + b).toString(); ```  &emsp;&emsp;通常来讲，如果一条语句以“（”、“[”、“/”、“+”或“-”开始，那么它极有可能和前一条语句合在一起解析。以“/”、“+”和“一”开始的语句并不常见，而以 “（”和“[”开始的语句则非常常见，至少在一些 JavaScript 编码风格中是很普遍的。有些程序员喜欢保守地在语句前加上一个分号，这样哪怕之前的语句被修改了、分号被误删除了，当前语句还是会正确地解析：  ```js var x=0//这里省略了分号 ;[x，x+1，X+2].forEach(console.1og)//前面的分号保证了正确地语句解析 ```  &emsp;&emsp;return、break 和 continue 语句后面换行会自动插入分号，可以在结尾加{} 或()，代码写在其中这样会避免 return 设计错误。   &emsp;&emsp;涉及“+ +”和“--”运算符的时候，如果将其用做后缀表达式，它和表达式应当在同一行。否则，行尾将填补分号，同时“++”或“--”将会作为下一行代码的前缀操作符并与之一起解析。  ```js x; ++y; ```  &emsp;&emsp;这段代码将解析为“x；+ +y”，而不是“x++；y”。 '},{title:"回到顶部功能的探究",path:"/posts/%E5%9B%9E%E5%88%B0%E9%A1%B6%E9%83%A8%E5%8A%9F%E8%83%BD%E7%9A%84%E6%8E%A2%E7%A9%B6.html",strippedContent:' &nbsp;&nbsp;&nbsp;&nbsp;随着互联网的发展，单个网页要呈现的内容越来越多，例如淘宝，京东类的电商网页，csdn,segmentfault 类的博客文章网页，还有许多网页都需要回到顶部功能，今天我们就来探索一下，看看怎么写回到顶部功能才能更好适应业务需求。   &nbsp;&nbsp;&nbsp;&nbsp;本文打算面向的是网页初学者或者一些平时工作没有注意到这方面的朋友，希望的是通过本文章让读者更加注重细节，哪怕是一个小小的功能。  ## 布局样式  ### 要求  &nbsp;&nbsp;&nbsp;&nbsp;高度自适应,高度让内容撑开，文字图标垂直居中。   &nbsp;&nbsp;&nbsp;&nbsp;像淘宝网页，为了充分利用空间，吸引更多的点击，在回到顶部按钮的地方还有实惠热卖，猜你喜欢等等按钮，并且每当活动都会有不同的呈现，所以这个 div 需要高度自适应，高度让内容撑开。   &nbsp;&nbsp;&nbsp;&nbsp;而文字图标垂直居中已经是一个设计的习惯，所以布局要考虑适应后续文字图标的大小不同，还有怎么方便地实现文字图标垂直居中。  #### HTML：  ```html <div id="to-top">   <a href="JavaScript:;">回到顶部</a> </div> ```  #### css:  ```css #to-top {   width: 36px;   line-height: 1.25;   background-color: #fff;   position: fixed;   right: 40px;   bottom: 40px;   text-align: center; } #to-top a {   padding: 5px;   display: block;   text-decoration: none;   color: black;   border: 1px solid #940050; } ```  #### 效果：  ![图片描述][1]  ## 跳转功能  跳转功能有许多实现  ### 利用锚点  #### HTML：  ```html <a href="#">回到顶部</a> ```  优点：简单快速，没有兼容性问题；   缺点：没有缓慢过渡的动画效果，用户体验不好，这种利用锚点跳转的一般用于文章目录的跳转，而不是回到顶部；  ### 原生 JavaScript 实现  #### 兼容问题  scrollTop 在浏览器的兼容不一样  ```js document.body.scrollTop || document.documentElement.scrollTop; ```  #### Element.scrollTop  &nbsp;&nbsp;&nbsp;&nbsp;Element.scrollTop 属性可以获取或设置一个元素的内容垂直滚动的像素数。   &nbsp;&nbsp;&nbsp;&nbsp;一个元素的 scrollTop 值是这个元素的顶部到它的最顶部可见内容（的顶部）的距离的度量。当一个元素的内容没有产生垂直方向的滚动条，那么它的 scrollTop 值为 0。   scrollTop 可以被设置为任何整数值，同时注意：   &nbsp;&nbsp;&nbsp;&nbsp;如果一个元素不能被滚动（例如，它没有溢出，或者这个元素有一个"non-scrollable"属性）， scrollTop 将被设置为 0。   &nbsp;&nbsp;&nbsp;&nbsp;设置 scrollTop 的值小于 0，scrollTop 被设为 0   &nbsp;&nbsp;&nbsp;&nbsp;如果设置了超出这个容器可滚动的值, scrollTop 会被设为最大值.  ```js var ToTop_btn = document.getElementById("to-top"); var ToTop_distance = 30; ToTop_btn.onclick = function(){ \tvjsar ToTop_animate = setInterval(function(){ \t\tvar scroll = document.body.scrollTop || document.documentElement.scrollTop; \t\tif ( scroll <= 0) { \t\t\tclearInterval(ToTop_animate); \t\t} \t\tscroll -= ToTop_distance; \t\tdocument.body.scrollTop=document.documentElement.scrollTop = scroll; \t},5); }; ```  兼容到 IE7+  #### Window.scrollTo()  scrollTo() 方法可把内容滚动到指定的坐标，设置 scrollTo(0,0)可以实现回到顶部的效果。  ```js var ToTop_btn = document.getElementById(\'to-top\'); var ToTop_distance = 30; ToTop_btn.onclick = function() {   var ToTop_animate = setInterval(function() {     var scroll = document.body.scrollTop || document.documentElement.scrollTop;     if (scroll <= 0) {       clearInterval(ToTop_animate);     }     scroll -= ToTop_distance;     scrollTo(0, scroll);   }, 5); }; ```  兼容到 IE7+  #### Window.scrollBy()  scrollBy() 方法可把内容滚动指定的像素数。   注意： 要使此方法工作 window 滚动条的可见属性必须设置为 true！  ```js var ToTop_btn = document.getElementById(\'to-top\'); var ToTop_distance = 30; ToTop_btn.onclick = function() {   var ToTop_animate = setInterval(function() {     if (scroll <= 0) {       clearInterval(ToTop_animate);     }     scrollBy(0, -ToTop_distance);   }, 5); }; ```  兼容到 IE7+  ### 利用 jQuery 实现  ```js $(\'#to-top\').click(function() {   $(\'body,html\').animate({ scrollTop: 0 }, 300); }); ```  ### 利用 vue 实现  后续补充  ### 利用 react 实现  后续补充  [1]: https://wx2.sinaimg.cn/large/005TbzGMgy1fv49pxvw86j301w03e0m9.jpg '},{title:"深入掌握vertical-align",path:"/posts/%E6%B7%B1%E5%85%A5%E6%8E%8C%E6%8F%A1vertical-align.html",strippedContent:' &nbsp;&nbsp;&nbsp;&nbsp;很多程序员知道 vertical-align 的作用,但是对于 vertical-align 到底怎么对齐的和它的适用对象却一知半解，因此经常遇到 vertical-align 不起作用的问题，今天我们就来说说 vertical-align。   &nbsp;&nbsp;&nbsp;&nbsp;不过 vertical-align 属性牵扯到的知识实在是太多了，不是一篇文章就可以讲清楚的，这里我就只说一说重要的和日常用到的知识点，本文不涉及表格单元格（table-cell）元素的垂直对齐方式。  ## 为什么要用 vertical-align  &nbsp;&nbsp;&nbsp;&nbsp;我们经常需要在竖直方向上对齐一些并肩排列的元素。例如表单输入框开头的图标，图片垂直居中，多行文字垂直居中等等。   &nbsp;&nbsp;&nbsp;&nbsp;CSS 为我们提供了一些实现方法。我们可以使用 flex 布局，也可以用 position:absolute，有时候甚至利用手动添加内外边距的方法。   &nbsp;&nbsp;&nbsp;&nbsp;然而 flex 的 PC 兼容性相对较差，IE 要 10，甚至 11 以上才有很好的兼容，绝对定位会使元素脱离文档流，以致于增加页面的复杂度。而使用固定的内外边距，太过死板，需求有了变化就要重新计算 margin，不便于项目以后的更改。   &nbsp;&nbsp;&nbsp;&nbsp;这里还有另一种值得尝试的解决方案，那就是 vertical-align。它能让你在不同场景下使用 vertical-align 去进行灵活细微的元素对齐工作，而你并不需要知道元素的具体尺寸。   &nbsp;&nbsp;&nbsp;&nbsp;然而，vertical-align 不是万能的，当 div 里的子节点过多时，由于 line-box 的基线不确定，子节点越多，布局就越难控制，此时就应该考虑用 position 等等。  ## 浏览器支持  所有浏览器都支持 vertical-align 属性。  注释：任何的版本的 Internet Explorer （包括 IE8）都不支持属性值 "inherit"。  ## 作用  veritical 是垂直的意思，而 align 是对齐的意思，两个合起来就是在垂直方向进行对齐。   MDN 上写到：vertical-align 用来指定行内元素（inline）或表格单元格（table-cell）元素的垂直对齐方式  ## 适用对象  vertical-align 用于对齐行内级元素。行内级元素就是 display 属性是下面其中的一种的元素：   inline，inline-block，inline-table（本文不涉及）  ## base-line（基线）和 outer edge（外边沿）  理解 vertical-align 最关键的一点在于理解相关元素的基线和上下边沿。  ### 在 inline 元素中  ![图片描述][1]  上图行高的上下边沿用红线表示，绿线表示字体的高度，蓝线表示基线。  #### 行内元素的外边沿  从上图中你可以看到三种情况。  1. 左图中的行高和字体尺寸相同，所以红线和绿线重合在一起了。 2. 中间的图片，行高是字体高度的两倍。 3. 右图行高是字体高度的一半。  总结：行内元素的外边沿就是它们的行高的上下边沿。  #### 行内元素的基线  行内元素的基线是字符下面的一条线。具体是下图中的蓝线。  ### 在 inline-block 元素中  ![图片描述][2]  左图包含 in-flow 内容（一个字母 C）的 inline-block 元素；   中间的图片包含 in-flow 内容并且设置了 over-flow:hidden 属性的 inline-block 元素；   右图没有 in-flow 内容，但是设置了高度属性的 inline-block 元素。   三个例子都设置了 margin 属性。   红线是 margin 的边缘，黄色部分是边框，绿色部分是内边距 padding，蓝色部分是内容。蓝线是各个元素的基线。  #### inline-block 元素的外边沿  inline-block 元素的外边沿是它们的 margin-box 的上下边沿。也就是图中的红线。  #### inline-block 元素的基线  inline-block 元素的基线取决于元素是否有 in-flow 内容:  1. 包含 in-flow 内容的 inline-block 元素的基线是普通文档流中最后一个元素内容的基线（例如左图）。这最后一个元素的基线如何定位，那就看它是什么类型的元素了。 2. 包含 in-flow 内容而且设置了 overflow 属性（值非 visible）的 inline-block 元素，其基线是 margin-box 的下边沿（例如中间的图）。所以它的基线就和自己的底边沿重合了。 3. 不包含 in-flow 内容的 inline-block 元素（例如右图）和上者相同，同样是底边线。  ### 在 line-box 中  #### line-box 简介  &nbsp;&nbsp;&nbsp;&nbsp;inline 元素在一行放不下所有元素的时候，就会在下面创建一个新行。所有的行都有一个叫做 line-box 的东西，它是用来包裹这一行所有内容用的。它包含一条基线，一个 text box，一个上边沿，一个下边沿。line-box 的 base-line（基线）和 outer edge（外边沿），和上面的 inline 元素的 base-line（基线）和 outer edge（外边沿）不一样。   &nbsp;&nbsp;&nbsp;&nbsp;line-box 规定出了我们对齐元素时的活动范围。在 line-box 中 vertical-align 负责每个元素的竖直对齐方式   &nbsp;&nbsp;&nbsp;&nbsp;如下图中所示：line-box 的上下边沿用红线标出。（line-box 的边沿平时是看不到的，画出来是为了方便读者理解）  ![图片描述][3]  #### line-box 的外边沿  &nbsp;&nbsp;&nbsp;&nbsp;line-box 的上边沿和行内最高的元素的上边沿对齐；同样下边沿和行内最低元素的下边沿对齐。这两个边沿也就是图中的红线。  #### line-box 的基线  &nbsp;&nbsp;&nbsp;&nbsp;line-box 的基线是会变化的：CSS2.1 没有定义 line-box 的 baseline，这就意味着，line-box 的基线是会根据一定的规则动态改变的。  ![图片描述][4]  &nbsp;&nbsp;&nbsp;&nbsp;由于 line-box 的基线是不可见的，所以你也不可能准确的说出它到底在哪里。但是能通过一个简单方法知道它在哪。只要在一行内容的行首添加一个字符就行，例如：我加了一个"x"（行首灰色的那个）。如果这个字符没有进行任何人为方式的对齐，那么它的基线就默认是在 line-box 的基线上。  #### text box  &nbsp;&nbsp;&nbsp;&nbsp;line-box 的基线周围的空间，我们可以称之为 text box，在 W3C 说明中，text box 叫做 strut。   &nbsp;&nbsp;&nbsp;&nbsp;你可以把 text box 看做是一个在 line-box 中没有进行任何对齐的 inline 元素。它的高度等于父元素的字体大小。因此 text box 是用于包裹 line box 中没有设置任何对齐的文字的，换言之，没有设置任何对齐的文字默认是在 text-box 中。   &nbsp;&nbsp;&nbsp;&nbsp;上图中绿线之间的部分就是 text box。由于 text box 是和基线紧密相连的，因此它会随着基线的移动而移动。  ### line-box 的基线是会移动的  缺点：line-box 的基线的位置受其内部所有元素的影响。所以 div 里面的元素尽量简单，不然布局很难控制。  #### 有一个元素刚好撑满了 line-box  如果有一个比较高的元素刚好撑满了 line-box，vertical-align 对它来说就没用任何影响了。因为它的下面和上面已经没有位置可以让它再移动了。   下面两幅图中矮小的盒子都设置 vertical-align:baseline。左图的高盒子设置为 vertical-align:text-bottom。右图的高盒子设置为 vertical-align:text-top。你就会发现两个矮盒子位置不一样，证明两幅图中 line-box 的基线是不在同一位置，因为矮盒子是跟着基线对齐的。  ![图片描述][5]  #### 没有盒子撑满 line-box  将两个比较高的盒子放置在一行，调整它们两个的垂直对齐方式使基线能够同时满足两种对齐。然后 line-box 的的高度就得到了调整（如左图）。再添加第三个元素，它的高度不会超过 line-box 的边缘，因为它的定位方式既不会影响 line-box 的高度，也不会影响基线的位置（如中图）。如果它真的超出了原有 line-box 的边缘，line-box 的高度和基线都会重新调整。这种情况我们的前两个盒子就会下移（如右图）。  ![图片描述][6]  ## 取值  我们通过使用 vertical-align 可以把上面我们介绍的那些参考点（基线，上线边沿等）设置成确定的关系  主要分一下三种情况：  ### 相对于 line-box 的基线进行对齐  #### 将元素的基线相对于 line-box 的基线进行对齐  ![图片描述][7]  ##### baseline  将元素的基线对齐到 line-box 的基线上；  ##### sub  将元素的基线对齐到 line-box 基线下方；  ##### super  将元素的基线对齐到 line-box 的基线上方；  ##### < percentage >  元素的基线相对于 line-box 的基线进行确定距离的对齐，定位的距离和方向由设置的百分比数值决定，百分比是相对于 line-height 的。  ##### < length >  元素的基线相对于 line-box 的基线进行确定距离的对齐，定位的距离和方向由设置的具体长度值决定。  #### 将元素的外边沿相对于 line-box 的基线进行对齐  ![图片描述][8]  ##### middle  使元素的上沿和下沿的中点对齐到字母“x”的基线上边加上一半 x 的高度上（其实就是字母 x 的正中间）。  ### 相对于 line-box 的 text box 对齐  #### 将元素的外边沿相对于 line-box 的 text box 对齐  ![图片描述][9]  以下的两种情况，其实也是相对于 line-box 的基线的一种对齐，因为 text-box 的上下边沿也是取决于基线的。  ##### text-top  元素的上边沿对齐到 line-box 的 text-box 的上边沿；  ##### text-bottom  元素的下边沿对齐到 line-box 的 text-box 的下边沿。  ### 相对于 line-box 的外边沿对齐  #### 将元素的外边沿相对于 line-box 的外边沿对齐  ![图片描述][10]  ##### top  将元素的上边沿和 line-box 的上边沿对齐；  ##### bottom  将元素的下边沿和 line-box 的下边沿对齐；  ## 应用例子  ### 使图标和文字居中  同学们常常有一个问题：当我让一个图标和它旁边的文字居中对齐时，仅仅对图标使用 vertical-align:middle 似乎并没有真正的使两者居中对齐？ 我们来看一个例子： html:  ```html <span class="icon middle"   ></span> Centered?   <span class="icon middle"     ></span> <span class="middle">Centered!</span></span></span   ></span > ```  css:  ```css .icon {   display: inline-block; } .middle {   vertical-align: middle; } ```  效果（添加了一些辅助线，实际上看不见）：  ![图片描述][11]  从图中看出，左图灰色方块离文字的中心稍微下移了，右图的图标和右边的文字就完美的居中对齐了。  原因：   因为左图中的文字没有经过对齐处理，所以它默认是在 text-box 中的，它的基线和 line-box 的基线是重合的。通过给灰色方块设置 vertical-align: middle;，我们就把灰色方块上沿和下沿的中点对齐到字母“x”的基线上边加上一半 x 的高度上（其实就是字母 x 的正中间）。但是 x 字母的正中心并不是文字所在的 text-box 的正中心，而是 text-box 中心稍稍的偏下了一点。  再看右图，我们把“Centered!”包裹起来并为也设置 vertical-align: middle;，就把“Centered!”的上沿和下沿的中点对齐到字母“x”的基线上边加上一半 x 的高度上（其实就是字母 x 的正中间）。这样灰色方块和文字的中点就在同一水平线上了。（上面《line-box 的基线是会移动的》的第二种情况）  ### 使图片垂直水平居中  html：  ```html <div id="wrap"><img src="a.jpg" /></div> ```  css：  ```css #wrap:after {   content: \'\';   display: inline-block;   height: 100%;   width: 0px;   vertical-align: middle; } #wrap img {   vertical-align: middle; } ```  效果（根据图中蓝色的 after 伪类实际上不可见，为了演示而增加）：  ![图片描述][12]  图片垂直居中了！   原理：   如果没有添加 after 伪类，div 里面添加了一个文本“x”，如下图：  ![图片描述][13]  如下图,如果添加 after 伪类，div 里面再添加了一个文本“x”，此时 after 伪类没有 in-flow 内容（但是设置了高度属性），基线在 div 最底下，给设置 vertical-align: middle;，就会将元素的外边沿相对于 line-box 的基线进行对齐，所以“x”向下移，跑到了 after 伪类中间，所以图片也跟着“x”跑到了 after 伪类中间 （上面《line-box 的基线是会移动的》的第一种情况） ![图片描述][14]  ### 消除 inline 元素下面的小空隙  当你想对齐竖直对齐 li 元素的时候。   代码：  ```html <ul>   <li class="box"></li>   <li class="box"></li>   <li class="box"></li> </ul>  < style type="text/css" > .box { display: inline-block; } < /style > ```  效果：   ![图片描述][15]  正如你所看到的，由于 li 元素默认是和基线对齐的，基线下面是留有一部分空白的，这个空白是可以容纳半个“x”的空间。这就导致了空隙的存在。如何解决？我们可以改变基线的位置，例如给 li 元素设置对齐方式为 vertical-align: middle   效果：   ![图片描述][16]  左图下面的空白线消失了！这种情况不会发生在包含文本内容的 inline-block 元素身上，因为文本内容已经把基线的位置抬高了。  ### 多行文本水平垂直居中  html:  ```html <div id="wrap">   <span     >xcdcdc xcdcdc xcdcdc xcdcdcxcdcdc xcdcdc xcdcdc xcdcdcxcdcdc xcdc dc xcdcdc     xcdcdcxcdcdc xcdcdc xcdcdc xcdcdcxcdcdc xcdcdc xcdcdc xcdcdcxcdcdc xcdcdc     xcdcdc xcdcdcxcdcdc xcdcdc xcdcdc xcdcdcxcdcdc xcdcdc xcdcdc xcdcdcxcdcdc     xcdcdc xcdcdc xcdcdcxcdcdc xcdcdc xcdcdc xcdcdcxcdcdc xcdcdc xcdcdc     xcdcdcxcdcdc xcdcdc xcdcdc xcdcdcxcdcdc xcdcdc xcdcdc xcdcdcxcdcdc xcdcdc     xcdcdc xcdcdc   </span> </div> ```  ```css #wrap {   width: 500px;   height: 500px;   background-color: #ff000030; } #wrap:after {   content: \'\';   display: inline-block;   height: 100%;   width: 0px;   vertical-align: middle;   background-color: blue; } #wrap span {   vertical-align: middle;   display: inline-block;   text-align: center;   max-width: 495px; } ```  效果：  ![图片描述][17]  line-height、font-size、vertical-align 是设置行内元素布局的关键属性。这三个属性是相互依赖的关系，通过组合三者可以达到很多效果。如果能理解运用本文章，工作中的不少关于 vertical-align 的问题都能在此得到解决，由于篇幅有限，关于 line-height 和 font-size 的探究以后再另开文章，如果想了解的可以关注作者。   参考文章： [你所不知道的 vertical-align](https://www.jianshu.com/p/71a03b8f6eb6)   [Vertical-Align: All You Need To Know](https://link.jianshu.com?t=http://christopheraue.net/2014/03/05/vertical-align/)  [1]: https://ws2.sinaimg.cn/large/005TbzGMly1fuvn2jpqiij30hz039741.jpg [2]: https://ws2.sinaimg.cn/large/005TbzGMly1fuvn2w0w3yj30hj03w0pe.jpg [3]: https://wx4.sinaimg.cn/large/005TbzGMly1fuvn38clb6j30g104tt8h.jpg [4]: https://ws4.sinaimg.cn/large/005TbzGMly1fuvn3g6mbnj30ia05dq2s.jpg [5]: https://wx2.sinaimg.cn/large/005TbzGMly1fuvn3p9dknj30l304n741.jpg [6]: https://ws2.sinaimg.cn/large/005TbzGMly1fuvn43rij6j30l006j3y9.jpg [7]: https://ws3.sinaimg.cn/large/005TbzGMly1fuvn4krp9rj30if032wec.jpg [8]: https://ws4.sinaimg.cn/large/005TbzGMly1fuvn4ubtnmj30iq02a741.jpg [9]: https://wx3.sinaimg.cn/large/005TbzGMly1fuvn530nd7j30ip02ujr5.jpg [10]: https://ws4.sinaimg.cn/large/005TbzGMly1fuvn5b5xxaj30jt02pa9t.jpg [11]: https://ws2.sinaimg.cn/large/005TbzGMly1fuvn5ji16mj30jo02xdfl.jpg [12]: https://ws3.sinaimg.cn/large/005TbzGMly1fuvn5qetz9j30ia0i9aag.jpg [13]: https://wx4.sinaimg.cn/large/005TbzGMly1fuvn5y1yvej30dy0f1t92.jpg [14]: https://ws2.sinaimg.cn/large/005TbzGMly1fuvn666pfaj30jc0hzq3c.jpg [15]: https://ws1.sinaimg.cn/large/005TbzGMly1fuvn6digicj30kx04e0rk.jpg [16]: https://wx3.sinaimg.cn/large/005TbzGMly1fuvn6jnfrsj30kr04c0o2.jpg [17]: https://ws4.sinaimg.cn/large/005TbzGMly1fuvn6smxcuj30iq0j6q35.jpg '},{title:"用css来实现实心三角形，空心三角形和三角指示箭头，兼容到ie6",path:"/posts/%E7%94%A8css%E6%9D%A5%E5%AE%9E%E7%8E%B0%E5%AE%9E%E5%BF%83%E4%B8%89%E8%A7%92%E5%BD%A2%EF%BC%8C%E7%A9%BA%E5%BF%83%E4%B8%89%E8%A7%92%E5%BD%A2%E5%92%8C%E4%B8%89%E8%A7%92%E6%8C%87%E7%A4%BA%E7%AE%AD%E5%A4%B4%EF%BC%8C%E5%85%BC%E5%AE%B9%E5%88%B0ie6.html",strippedContent:' &nbsp;&nbsp;&nbsp;&nbsp;在前端工作中经常会出现好多三角形，比如下拉图标、tooltip 提示框、多级菜单等，如果将三角形变成图片，通过 img 标签的 src 或者 background 中的 url 来访问，会增加 http 请求的个数，从前端性能方面来看这并不好，所以对于普通的三角形，我们要用 css 来画三角形.   &nbsp;&nbsp;&nbsp;&nbsp;由于 ie6 我们在工作中已经很少要求兼容了，所以在此把兼容 ie6 和其他浏览器的 demo 分开不同标题写，便于同学快速查询，节省时间。  ## 普通实心三角形  &nbsp;&nbsp;&nbsp;&nbsp;css 实现三角形图标已不是什么新鲜技术，也有很多相关的技术文章讲过了，基本原理大同小异。   &nbsp;&nbsp;&nbsp;&nbsp;主要是利用一个 div 或者元素的 border 并不是我们直观意义上的一条有高度的线，而是一个等高梯形或者三角形（宽高为 0 时），要是给 div 的高和宽设置为 0，然后设置四个 border 不同的颜色，三角形就出来了，可以看一下效果：   html：  ```html <div class="container"></div> ```  css:  ```css .container {   width: 0;   height: 0;   border-width: 50px;   border-style: solid;   border-color: blue red green yellow; } ```  效果：   ![图片描述][1]  可以看到每一个方向的 border 都是一个三角形，那么我们只需把对应方向剩余其他方向的 border 设置为透明或者隐藏掉就可以得到任何方向的一个三角形了。如果我们想得到一个下拉图标，我们可以将 border 的左右和下边框改为透明，css 改动如下：  ```css .container {   width: 0px;   height: 0px;   border-width: 50px;   border-style: solid;   border-color: blue transparent transparent transparent; } ```  再看一下效果：   ![图片描述][2]  即便是已经生成一个我们需要的三角形，但是三角形的占用高度仍是原高度，这会导致在和其他元素使用时，造成上移的效果。此时，我们需要把下边框的高度设置为 0。  ### 最终版本 1，手动改颜色：  ```css .container {   width: 0px;   height: 0px;   border-width: 50px 50px 0;   border-style: solid;   border-color: blue transparent transparent transparent; } ```  再来看看效果（设置一个阴影方便来查看）：   ![图片描述][3]  在使用时我们仍需要修改对应的颜色，能不能根据父元素设定的颜色（使用当前字体颜色），显示对应的颜色呢？我们需要把 border-color 修改下：  ### 最终版本 2，使用当前字体颜色，默认黑色：  ```css .container {   width: 0px;   height: 0px;   border-width: 50px 50px 0;   border-style: solid;   border-left-color: transparent;   border-right-color: transparent; } ```  ## 兼容 ie6 的手动改颜色的实心三角形  因为 ie6 不支持 transparent 透明属性，这时候我们可以将对应区域的 border 的样式设置为 dashed，dashed 在边框宽度很大时，会隐藏掉。   css 修改如下：  ```css .container {   width: 0px;   height: 0px;   border-width: 50px 50px 0;   border-style: solid dashed dashed dashed;   border-color: blue transparent transparent transparent;   overflow: hidden; } ```  ## 兼容 ie6 的继承颜色实心三角形  css 修改如下：  ```css .container {   width: 0px;   height: 0px;   border-width: 50px 50px 0;   border-style: solid dashed dashed dashed;   border-left-color: transparent;   border-right-color: transparent;   overflow: hidden; } ```  ## 普通空心三角形  空心三角形的实现很简单，就是在实心三角形上覆盖一个比它小的和背景颜色相同的实心三角形就行了。   css 如下：  ```css .container {   width: 0px;   height: 0px;   border-width: 50px 50px 0;   border-style: solid;   border-color: blue transparent transparent transparent;   position: relative; } .container:before {   content: \'\';   width: 0px;   height: 0px;   border-width: 45px 45px 0;   border-style: solid;   border-color: #fff transparent transparent transparent;   position: absolute;   top: -48px;   left: -45px; } ```  效果：   ![图片描述][4]  ## 兼容 ie6 的空心三角形  ie7 不支持 before 伪类，所以用 div 代替 html 如下：  ```html <div id="container">   <div id="container1"></div>   <div id="container2"></div> </div> ```  css 如下：  ```css #container {   position: relative; } #container1 {   width: 0px;   height: 0px;   border-width: 50px 50px 0;   border-style: solid dashed dashed dashed;   border-color: blue transparent transparent transparent; } #container2 {   width: 0px;   height: 0px;   border-width: 44px 45px 0;   border-style: solid dashed dashed dashed;   border-color: #fff transparent transparent transparent;   position: absolute;   top: 2px;   left: 5px; } ```  ## 普通三角指示箭头  &nbsp;&nbsp;&nbsp;&nbsp;为了语义化，两个三角形用 before 和 after 伪类来实现，因为 after 伪元素会覆盖 before 伪元素，所以 after 伪元素就是第二个三角形。   &nbsp;&nbsp;&nbsp;&nbsp;在消息框中为了视觉效果更好，我们应该将三角箭头的边框宽度和主体元素的边框宽度保持一致。   &nbsp;&nbsp;&nbsp;&nbsp;第二个三角形相较于第一个三角形的偏移值 A 其实应该是主体元素边框宽度 B 的"根号 2"倍，约为 1.414，为了方便可以按 1.4 倍计算。   假设主体元素边框宽度为 6px，所以第二个三角形相较于第一个三角形的偏移量 A 应为 6px\\*1.4 = 8.4px   如下图所示：   ![图片描述][5] html:  ```html <div class="container"></div> ```  css:  ```css .container {   position: relative; } .container:before {   content: \'\';   width: 0px;   height: 0px;   border-width: 50px 50px 0;   border-style: solid;   border-color: blue transparent transparent transparent;   position: absolute;   top: 0;   left: 0; } .container:after {   content: \'\';   width: 0px;   height: 0px;   border-width: 50px 50px 0;   border-style: solid;   border-color: #fff transparent transparent transparent;   position: absolute;   top: -1px;   left: 0; } ```  效果：   ![图片描述][6]  ## 兼容 ie6 的三角指示箭头  ie7 不支持 before 伪类，所以用 div 代替 html 如下：  ```html <div id="container">   <div id="container1"></div>   <div id="container2"></div> </div> ```  css 如下：  ```css #container {   position: relative; } #container1 {   width: 0px;   height: 0px;   border-width: 50px 50px 0;   border-style: solid dashed dashed dashed;   border-color: blue transparent transparent transparent; } #container2 {   width: 0px;   height: 0px;   border-width: 50px 50px 0;   border-style: solid dashed dashed dashed;   border-color: #fff transparent transparent transparent;   position: absolute;   top: -1px;   left: 0; } ```  [1]: https://ws1.sinaimg.cn/large/005TbzGMgy1fus4cmgn8mj303x03x3ya.jpg [2]: https://wx1.sinaimg.cn/large/005TbzGMgy1fus4cymmpdj304403ia9t.jpg [3]: https://wx4.sinaimg.cn/large/005TbzGMgy1fus4d446ywj303x02rgld.jpg [4]: https://wx4.sinaimg.cn/large/005TbzGMgy1fus4dtjfk3j303y02m0sh.jpg [5]: https://ws2.sinaimg.cn/large/005TbzGMgy1fus4e1mq57j30m80b5dg6.jpg [6]: https://ws4.sinaimg.cn/large/005TbzGMgy1fus4ea87spj304202qt8h.jpg '},{title:"git学习总结",path:"/posts/git%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93.html",strippedContent:' ## 版本控制简介  ### 版本控制  工程设计领域中使用版本控制管理工程蓝图的设计过程。在 IT 开发过程中也可以使用版本控制思想管理代码的版本迭代。  ### 版本控制工具  集中式版本控制工具：CVS、**SVN**、VSS…… 分布式版本控制工具：**Git**、Mercurial、Bazaar、Darcs……  ### 版本控制工具应该具备的功能  1. 协同修改      多人并行不悖的修改服务器端的同一个文件。 1. 数据备份      不仅保存目录和文件的当前状态，还能够保存每一个提交过的历史状态。 1. 版本管理      在保存每一个版本的文件信息的时候要做到不保存重复数据，以节约存储空间，提高运行效率。这方面 SVN 采用的是增量式管理的方式，而 Git 采取了文    件系统快照的方式。 1. 权限控制      对团队中参与开发的人员进行权限控制。      对团队外开发者贡献的代码进行审核——Git 独有。 1. 历史记录      查看修改人、修改时间、修改内容、日志信息。      将本地文件恢复到某一个历史状态。 1. 分支管理      允许开发团队在工作过程中多条生产线同时推进任务，进一步提高效率。  ## Git 简介  ### Git 简介  ![图片描述][1]  ### Git 的优势  1. 大部分操作在本地完成，不需要联网 1. 完整性保证 1. 尽可能添加数据而不是删除或修改数据 1. 分支操作非常快捷流畅 1. 与 Linux 命令全面兼容  ### Git 结构  ![图片描述][2]  ### Git 和代码托管中心  代码托管中心的任务：维护远程库   局域网环境下: GitLab 服务器   外网环境下: GitHub,码云  ## Git 命令行操作  ### 本地库初始化  命令：git init   效果: 在此目录下生成.git 目录，把这个目录变成 Git 可以管理的仓库   注意：.git 目录中存放的是本地库相关的子目录和文件，不要删除，也不要胡乱修改  ### 设置签名  作用：区分不同开发人员的身份   注意：这里设置的签名和登录远程库(代码托管中心)的账号、密码没有任何关系。   命令：  - 项目级别/仓库级别：仅在当前本地库范围内有效  ``` git config user.name "你的名字" git config user.email "你的邮箱" ```  信息保存位置：./.git/config 文件  - 系统用户级别：登录当前操作系统的用户范围  ``` git config --global "你的名字" git config --global "你的邮箱" ```  信息保存位置：~/.gitconfig 文件  - 级别优先级     就近原则：项目级别优先于系统用户级别，二者都有时采用项目级别的签名     如果只有系统用户级别的签名，就以系统用户级别的签名为准     二者都没有不允许  ### 状态查看  命令：git status   查看工作区、暂存区状态  ### 添加  命令：git add [file name]   将工作区的“新建/修改”添加到暂存区   如果有很多改动可以通过 git add -A .来一次添加所有改变的文件。  git add -u [< path >]: 把< path >中所有跟踪文件中被修改过或已删除文件的信息添加到索引库。它不会处理那些不被跟踪的文件。省略< path >表示 . ,即当前目录。  git add -A: []表示把中所有跟踪文件中被修改过或已删除文件和所有未跟踪的文件信息添加到索引库。省略< path >表示 . ,即当前目录。  ### 提交  命令：git commit -m "本次提交的描述" [file name]   将暂存区的内容提交到本地库  ### 查看历史记录  命令：git log   历史记录过多时，多屏显示控制方式：空格向下翻页，b 向上翻页，q 退出  ``` git log --pretty=oneline ```  ![图片描述][3]  ``` git log --oneline ```  ![图片描述][4]  ``` git reflog ```  ![图片描述][5]  HEAD@{移动到当前版本需要多少步}  ### 版本回退  - 基于索引值操作[推荐]     git reset --hard [局部索引值] - 使用^符号：只能后退     git reset --hard HEAD^     注：一个^表示后退一步，n 个表示后退 n 步 - 使用~符号：只能后退     git reset --hard HEAD~n     注：表示后退 n 步 - reset 命令的三个参数对比     --soft 参数     仅仅在本地库移动 HEAD 指针     --mixed 参数     在本地库移动 HEAD 指针，重置暂存区     --hard 参数     在本地库移动 HEAD 指针，重置暂存区，工作区  ### 删除文件并找回  前提：删除前，文件存在时的状态提交到了本地库。   操作：git reset --hard [指针位置]   删除操作已经提交到本地库：指针位置指向历史记录   删除操作尚未提交到本地库：指针位置使用 HEAD  ### 比较文件差异  git diff [文件名]   将工作区中的文件和暂存区进行比较   git diff [本地库中历史版本] -- [文件名]   例：git diff HEAD -- < filename >   将工作区中的文件和本地库历史记录比较   git diff [< commit-id >][< commit-id >]   不带文件名比较多个文件  ### SSH 登录  进入当前用户的家目录   $ cd ~   删除.ssh 目录   $ rm -rvf .ssh   运行命令生成.ssh 密钥目录   $ ssh-keygen -t rsa -C   你的邮箱@qq.com   [注意：这里-C 这个参数是大写的 C]   进入.ssh 目录查看文件列表   $ cd .ssh   $ ls -lF   查看 id_rsa.pub 文件内容  $ cat id_rsa.pub   复制 id_rsa.pub 文件内容，登录 GitHub，点击用户头像 →Settings→SSand GPG keys   New SSH Key   输入复制的密钥信息   回到 Git bash 创建远程地址别名   git remote add origin_ssh git@github.com:atgui/huashan.git   推送文件进行测试  ### 撤销修改  git checkout -- file   可以丢弃工作区的修改   这里有两种情况：   一种是 readme.txt 自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；   一种是 readme.txt 已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。   git reset HEAD < file >   可以把暂存区的修改撤销掉（unstage），重新放回工作区  ### 标签管理  首先，切换到需要打标签的分支上   git tag < name >   默认标签是打在最新提交的 commit 上的   git tag < name > < commit id >   标签是打在历史提交的 commit 上   git tag -a v0.1 -m "version 0.1 released" 1094adb   创建带有说明的标签，用-a 指定标签名，-m 指定说明文字   可以用命令 git tag 查看所有标签   注意，标签不是按时间顺序列出，而是按字母排序的。可以用 git show < tagname >查看标签信息    注意：标签总是和某个 commit 挂钩。如果这个 commit 既出现在 master 分支，又出现在 dev 分支，那么在这两个分支上都可以看到这个标签。  ### 操作标签  如果标签打错了，也可以删除：   git tag -d v0.1   如果要推送某个标签到远程，使用： git push origin < tagname >   要删除远程标签就麻烦一点，先从本地删除，然后，从远程删除。删除命令也是 push   git tag -d v0.9   git push origin :refs/tags/v0.9  ## 分支管理  ### 什么是分支？  在版本控制过程中，使用多条线同时推进多个任务  ### 分支的好处？  同时并行推进多个功能开发，提高开发效率   各个分支在开发过程中，如果某一个分支开发失败，不会对其他分支有任何影响。失败的分支删除重新开始即可。  ### 分支操作  #### 创建分支  git branch [分支名]  #### 查看分支  git branch -v  #### 切换分支  git checkout [分支名]  #### 合并分支  第一步：切换到接受修改的分支（被合并，增加新内容）上   git checkout [被合并分支名]   第二步：执行 merge 命令   git merge [有新内容分支名]  #### 解决冲突  ##### 冲突的表现  ![图片描述][6]  ##### 冲突的解决  第一步：编辑文件，删除特殊符号   第二步：把文件修改到满意的程度，保存退出   第三步：git add [文件名]   第四步：git commit -m "日志信息"   注意：此时 commit 一定不能带具体文件名  ## 忽略特殊文件.gitignore  在 Git 工作区的根目录下创建一个特殊的.gitignore 文件，然后把要忽略的文件名填进去，Git 就会自动忽略这些文件   不需要从头写.gitignore 文件，GitHub 已经为我们准备了各种配置文件，只需要组合一下就可以使用了。所有配置文件可以直接在线浏览：https://github.com/github/gitignore   忽略文件的原则是：   1.忽略操作系统自动生成的文件，比如缩略图等；   2.忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如 Java 编译产生的.class 文件；   3.忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件。  ## 远程库  ### 查看和创建远程库地址别名  git remote -v 查看当前所有远程地址别名 git remote add [别名][远程地址]   ![图片描述][7]  ### 推送  git push [别名][分支名]  ### 克隆  git clone [远程地址]   效果：   完整的把远程库下载到本地   创建 origin 远程地址别名   初始化本地库  ### 团队成员邀请  ![图片描述][8]  “岳不群”其他方式把邀请链接发送给“令狐冲”，“令狐冲”登录自己的 GitHub 账号，访问邀请链接。   ![图片描述][9]  ### 拉取  pull=fetch+merge   git fetch [远程库地址别名][远程分支名]   git merge [远程库地址别名/远程分支名]   git pull [远程库地址别名][远程分支名]  ### 解决冲突  要点：   如果不是基于 GitHub 远程库的最新版所做的修改，不能推送，必须先拉取。   拉取下来后如果进入冲突状态，则按照“分支冲突解决”操作解决即可。  ### 跨团队协作  Fork   ![图片描述][10] ![图片描述][11] ![图片描述][12]  本地修改，然后推送到远程   Pull Request  ![图片描述][13]  ![图片描述][14]  对话   ![图片描述][15]  ![图片描述][16]  审核代码   ![图片描述][17]  合并代码   ![图片描述][18]  将远程库修改拉取到本地   参考：[Git 教程-廖雪峰的官方网站][19] ，[尚硅谷 Git&GitHub 视频教程][20]  [1]: https://wx4.sinaimg.cn/large/005TbzGMgy1fuqpprpt6lj30m80c2myr.jpg [2]: https://ws4.sinaimg.cn/large/005TbzGMgy1fuqpu7ntjaj307e09nwep.jpg [3]: https://wx4.sinaimg.cn/large/005TbzGMgy1fuqpunvfm3j30m801m40t.jpg [4]: https://wx4.sinaimg.cn/large/005TbzGMgy1fuqpuzlbbkj30dw01rt9v.jpg [5]: https://ws1.sinaimg.cn/large/005TbzGMgy1fuqpvdilm2j30jf02htbb.jpg [6]: https://ws1.sinaimg.cn/large/005TbzGMgy1fuqpvsug68j30d304875q.jpg [7]: https://wx3.sinaimg.cn/large/005TbzGMgy1fuqpw4jmu7j30l3036n0g.jpg [8]: https://wx4.sinaimg.cn/large/005TbzGMgy1fuqpwjavrvj30ir0dmjw8.jpg [9]: https://ws2.sinaimg.cn/large/005TbzGMgy1fuqpwpnj1sj30bn04zab6.jpg [10]: https://ws4.sinaimg.cn/large/005TbzGMgy1fuqpx49iy1j30m807ln05.jpg [11]: https://wx1.sinaimg.cn/large/005TbzGMgy1fuqpxo19i9j30fq09bgnk.jpg [12]: https://ws2.sinaimg.cn/large/005TbzGMgy1fuqpxzk37xj30bg059q3s.jpg [13]: https://wx2.sinaimg.cn/large/005TbzGMgy1fuqpyetyv6j30i708sgnr.jpg [14]: https://wx3.sinaimg.cn/large/005TbzGMgy1fuqpyqpvmvj30gk0ihwis.jpg [15]: https://ws2.sinaimg.cn/large/005TbzGMgy1fuqpz3h8ybj30li06xjta.jpg [16]: https://ws4.sinaimg.cn/large/005TbzGMgy1fuqpzcuoy5j30bl0akjtt.jpg [17]: https://ws2.sinaimg.cn/large/005TbzGMgy1fuqpzl389tj30gm07cjts.jpg [18]: https://ws1.sinaimg.cn/large/005TbzGMgy1fuqpztjvulj30fb0fc0x0.jpg [19]: https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000 [20]: http://www.atguigu.com/download.shtml#git '},{title:"Markdown语法要点",path:"/posts/Markdown%E8%AF%AD%E6%B3%95%E8%A6%81%E7%82%B9.html",strippedContent:" ## Markdown 与 HTML 的关联  - Markdown 兼容 HTML，可以用 HTML 的许多样式标签来设计修饰 Markdown 的文本。  - HTML 的区段标签如 span、cite、del 可以在 Markdown 的段落、列表或是标题里随意使用。甚至可以不用 Markdown 格式，而直接采用 HTML 标签来格式化。  - HTML 区块内不兼容 Markdown 格式语法。 - 只有一些 HTML 区块元素,比如 div,table,pre,p 等标签，必须在前后加上空行与其它内容区隔开,还要求它们的开始标签与结尾标签不能用制表符或空格来缩进。  ## 特殊字符自动转换  - markdwon 中 html 的<,&都是直接写。  ## 标题  - 使用=来表示最高阶标题，-表示第二阶标题。符号在标题的下方，个数是大于一个。 - 使用 1 到 6 个#来不同的标题阶数。数量越多，字体越小。  ## 段落和换行  - 如果想强制换行,插入空行，换行符`<br>`或一行结束时输入两个空格。  ## 引用  - 在行首使用>即可。只在每个段落的第一行加上>也可以。 - 如果想要在引用中继续嵌套使用，继续使用>就可以了。 - 引用中的 markdown 语法可以正常使用。  ## 列表  - 可以用 \\*、+、-，也可以用数字加.的方式来作列表。 - 数字不一定要按照顺序来，只要符合上述规则，markdown 的最终显示会从 1 开始自动逐个显示。 - 列表如果想分级，规则是下一级比上一级多一个 Tab 键。  - 如果在显示列表的时候，使用了数字加.和上面 3 种的混合形式。那么最终的显示效果，以第一行的列表为准。  ## 链接  - 行内式语法: [here](http://www.baidu.com/) - 参考式语法: [JavaScript][1] , [jQuery][2] , [.net][3]    [1]: http://www.baidu.com   [2]: http://www.baidu.com   [3]: http://www.baidu.com  - 参考式语法的链接定义，要与链接文字分开，除此以外，你可以把它放到文章其他的任意 位置。 - <http://www.baidu.com>  ## 加粗  - **Bold**  ## 斜体  - _Italics_  ## 加粗加斜体  - **_sdfj_**  ## 删除线  - ~~text~~  ## 高亮  - ==text==  ## 脚注  - [^1]：  ## 水平线  - 在一行之内使用三个或以上的 \\* 或-来建立分隔线，需要单独占一行。  ## 公式  - 用$包围公式可以在行内生成公式,用两个$包围并且自成一个段落的公式会自动居中。  ## 代码  - 如果要行内引用反引号，要用两个反引号前后包裹起来. - 如果要在代码区块内单独一行写反引号，那么区块外的反引号要比里面的多，不单独一行写就不用。  ## 图片  - 行内式:`![]()`,参考式:`![][1] [1]:...`想给图片添加一个标题,你需要做的是将标题文本插图中的方括号。 - 到目前为止， Markdown 还没有办法指定图片的宽高，如果你需要的话，你可以使用 html 的标签。  ## 绘制表格  - | 项目   |  价格  | 数量 |   | :----- | :----: | ---: |   | 计算机 | \\$1600 |    5 |   | 手机   |  \\$12  |   12 |   | 管线   |  \\$1   |  234 |  - 第二行的意思分别表示左对齐、居中、右对齐。  ## 转义字符  - 用反斜杠\\来插入一些在 Markdown 语法中有其他意义的符号。  ## 生成目录  - [TOC]，中间不要有空格。 "}]}}]);