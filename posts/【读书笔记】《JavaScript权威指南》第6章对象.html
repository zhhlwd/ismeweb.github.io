<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, minimal-ui"
    />
    <title>【读书笔记】《JavaScript权威指南》第6章对象 | zhhlwd</title>
    <meta name="description" content="三人行，必有我师焉，择其善者而从之，其不善者而改之。" />
    <meta property="og:type" content="website" />
    <meta property="og:title" content="【读书笔记】《JavaScript权威指南》第6章对象 | zhhlwd" />
    <meta property="og:site_name" content="【读书笔记】《JavaScript权威指南》第6章对象 | zhhlwd" />
    <meta property="og:locale" content="zh-CN" />
    <meta name="twitter:card" content="summary" />
    <meta name="twitter:title" content="【读书笔记】《JavaScript权威指南》第6章对象 | zhhlwd" />
    <link rel="shortcut icon" href="/favicon.ico">
    
    <link rel="preload" href="/assets/css/0.styles.068dd2cd.css" as="style"><link rel="preload" href="/assets/js/app.39e00e98.js" as="script"><link rel="preload" href="/assets/js/1.c0224360.js" as="script"><link rel="preload" href="/assets/js/15.f0ca96b2.js" as="script"><link rel="preload" href="/assets/js/5.b07737de.js" as="script"><link rel="preload" href="/assets/js/7.9893d61a.js" as="script"><link rel="preload" href="/assets/js/10.9c509957.js" as="script"><link rel="preload" href="/assets/js/6.57699fa9.js" as="script"><link rel="preload" href="/assets/js/59.5f3be402.js" as="script"><link rel="preload" href="/assets/js/14.0e97f0ce.js" as="script"><link rel="preload" href="/assets/js/16.9fb85302.js" as="script"><link rel="prefetch" href="/assets/js/11.4d3e3171.js"><link rel="prefetch" href="/assets/js/12.00842133.js"><link rel="prefetch" href="/assets/js/13.3ac04011.js"><link rel="prefetch" href="/assets/js/17.427877de.js"><link rel="prefetch" href="/assets/js/18.9fb398fc.js"><link rel="prefetch" href="/assets/js/19.feb0126e.js"><link rel="prefetch" href="/assets/js/20.13a93009.js"><link rel="prefetch" href="/assets/js/21.58f50a10.js"><link rel="prefetch" href="/assets/js/22.c63d4380.js"><link rel="prefetch" href="/assets/js/23.18289c78.js"><link rel="prefetch" href="/assets/js/24.c1a9de78.js"><link rel="prefetch" href="/assets/js/25.0bd81385.js"><link rel="prefetch" href="/assets/js/26.16680b9b.js"><link rel="prefetch" href="/assets/js/27.6cffb597.js"><link rel="prefetch" href="/assets/js/28.6322d617.js"><link rel="prefetch" href="/assets/js/29.988d048b.js"><link rel="prefetch" href="/assets/js/30.86340671.js"><link rel="prefetch" href="/assets/js/31.3920b019.js"><link rel="prefetch" href="/assets/js/32.043d59c3.js"><link rel="prefetch" href="/assets/js/33.179b9e0e.js"><link rel="prefetch" href="/assets/js/34.d62c08ea.js"><link rel="prefetch" href="/assets/js/35.5d1effb7.js"><link rel="prefetch" href="/assets/js/36.8f937390.js"><link rel="prefetch" href="/assets/js/37.d4c78315.js"><link rel="prefetch" href="/assets/js/38.6d9e9af7.js"><link rel="prefetch" href="/assets/js/39.c0d6b845.js"><link rel="prefetch" href="/assets/js/4.852cc3fd.js"><link rel="prefetch" href="/assets/js/40.0dd1da3d.js"><link rel="prefetch" href="/assets/js/41.a53d9e1e.js"><link rel="prefetch" href="/assets/js/42.ef67bdbc.js"><link rel="prefetch" href="/assets/js/43.8015aa78.js"><link rel="prefetch" href="/assets/js/44.3d19ff22.js"><link rel="prefetch" href="/assets/js/45.c4ec1046.js"><link rel="prefetch" href="/assets/js/46.b66c6c6a.js"><link rel="prefetch" href="/assets/js/47.792fbb9b.js"><link rel="prefetch" href="/assets/js/48.fff9e461.js"><link rel="prefetch" href="/assets/js/49.927540c7.js"><link rel="prefetch" href="/assets/js/50.7328b358.js"><link rel="prefetch" href="/assets/js/51.edf5a6f6.js"><link rel="prefetch" href="/assets/js/52.554531c8.js"><link rel="prefetch" href="/assets/js/53.cff155eb.js"><link rel="prefetch" href="/assets/js/54.79017acb.js"><link rel="prefetch" href="/assets/js/55.3f832b4e.js"><link rel="prefetch" href="/assets/js/56.fc46ef96.js"><link rel="prefetch" href="/assets/js/57.01d4bca6.js"><link rel="prefetch" href="/assets/js/58.af6eeeff.js"><link rel="prefetch" href="/assets/js/60.0babdfb8.js"><link rel="prefetch" href="/assets/js/61.acc49c38.js"><link rel="prefetch" href="/assets/js/62.3bbe5a99.js"><link rel="prefetch" href="/assets/js/63.4c1ad2b7.js"><link rel="prefetch" href="/assets/js/64.660d1af7.js"><link rel="prefetch" href="/assets/js/65.d8475e70.js"><link rel="prefetch" href="/assets/js/66.fe8f81dc.js"><link rel="prefetch" href="/assets/js/67.bc970a69.js"><link rel="prefetch" href="/assets/js/68.5b401715.js"><link rel="prefetch" href="/assets/js/69.60a017c7.js"><link rel="prefetch" href="/assets/js/70.d0fe42fc.js"><link rel="prefetch" href="/assets/js/71.34114315.js"><link rel="prefetch" href="/assets/js/72.962129e8.js"><link rel="prefetch" href="/assets/js/73.a2267a94.js"><link rel="prefetch" href="/assets/js/74.2401111b.js"><link rel="prefetch" href="/assets/js/75.361c8ec8.js"><link rel="prefetch" href="/assets/js/76.323e94c6.js"><link rel="prefetch" href="/assets/js/77.b3c2a687.js"><link rel="prefetch" href="/assets/js/8.001cad53.js"><link rel="prefetch" href="/assets/js/9.d5c24b06.js"><link rel="prefetch" href="/assets/js/search.de4016ee.js">
    <link rel="stylesheet" href="/assets/css/0.styles.068dd2cd.css">
  </head>
  <body>
    <div id="loader-wrapper" style="display: none;opacity:0">
      <div id="loader"></div>
      <div class="loader-section section-left"></div>
      <div class="loader-section section-right"></div>
    </div>
    <div id="app" data-server-rendered="true"><div style="height:100%;" data-v-3431ceb9><section class="el-container main-container" data-v-3431ceb9><aside class="el-aside menu" style="width:auto;" data-v-7a66351a data-v-3431ceb9><ul role="menubar" class="menu-wrap el-menu" style="background-color:;" data-v-7a66351a><li data-v-7a66351a><div class="brand-wrap" style="background-image:url(/brand.jpg);" data-v-7a66351a><div class="brand" data-v-7a66351a><a href="/" class="avatar waves-effect waves-circle waves-light router-link-active" data-v-7a66351a><img src="/avatar.jpg" data-v-7a66351a></a> <hgroup class="introduce" data-v-7a66351a><div class="nickname" data-v-7a66351a>zhhlwd</div> <a title="zhhlwd@qq.com" class="mail" data-v-7a66351a>zhhlwd@qq.com</a></hgroup></div></div></li> <li role="menuitem" tabindex="-1" class="el-menu-item" style="padding-left:20px;color:;background-color:;" data-v-7a66351a><i class="iconfont icon-home" data-v-7a66351a></i> <span class="item-title" data-v-7a66351a>主页</span></li> <li role="menuitem" tabindex="-1" class="el-menu-item" style="padding-left:20px;color:;background-color:;" data-v-7a66351a><i class="iconfont icon-biaoqian" data-v-7a66351a></i> <span class="item-title" data-v-7a66351a>标签分类</span></li> <li role="menuitem" tabindex="-1" class="el-menu-item" style="padding-left:20px;color:;background-color:;" data-v-7a66351a><i class="iconfont icon-wenzhang" data-v-7a66351a></i> <span class="item-title" data-v-7a66351a>时间归档</span></li> <li role="menuitem" tabindex="-1" class="el-menu-item" style="padding-left:20px;color:;background-color:;" data-v-7a66351a><i class="iconfont icon-github" data-v-7a66351a></i> <span class="item-title" data-v-7a66351a>Github</span></li> <li role="menuitem" tabindex="-1" class="el-menu-item" style="padding-left:20px;color:;background-color:;" data-v-7a66351a><i class="iconfont icon-aboutme" data-v-7a66351a></i> <span class="item-title" data-v-7a66351a>自我介绍</span></li></ul></aside> <section class="el-container container-warp" data-v-3431ceb9><header id="topHeader" class="el-header top-header" style="height:60px;padding-left:260px;" data-v-15c2c99c data-v-3431ceb9><div class="header-warp el-row is-align-middle el-row--flex" data-v-15c2c99c><div class="el-col el-col-12 el-col-xs-7" data-v-15c2c99c><div class="el-row is-align-middle el-row--flex" data-v-15c2c99c><div class="el-col el-col-2" data-v-15c2c99c><button type="button" class="el-button el-button--primary is-circle" data-v-15c2c99c><!----><!----><span><i class="iconfont icon-caidan" data-v-15c2c99c></i></span></button></div></div></div> <div class="el-col el-col-20 el-col-xs-24" data-v-15c2c99c><div class="grid-content bg-purple-light" data-v-15c2c99c><div class="el-row is-justify-end is-align-middle el-row--flex" data-v-15c2c99c><div class="el-col el-col-13 el-col-xs-24 el-col-sm-21 el-col-md-17 el-col-lg-13" data-v-15c2c99c><div aria-haspopup="listbox" role="combobox" aria-owns="el-autocomplete-3561" class="el-autocomplete search-input" data-v-15c2c99c><div class="el-input el-input--small el-input--suffix"><!----><input type="text" autocomplete="off" valueKey="value" popperClass="search-popper" placeholder="搜搜看" fetchSuggestions="function () { [native code] }" debounce="300" placement="bottom-start" popperAppendToBody="true" value="" class="el-input__inner"><!----><span class="el-input__suffix"><span class="el-input__suffix-inner"><i class="el-input__icon el-icon-search search-ico" data-v-15c2c99c></i><!----></span><!----></span><!----></div><div role="region" class="el-autocomplete-suggestion el-popper search-popper" style="width:;display:none;"><div class="el-scrollbar"><div class="el-autocomplete-suggestion__wrap el-scrollbar__wrap el-scrollbar__wrap--hidden-default"><ul class="el-scrollbar__view el-autocomplete-suggestion__list"></ul></div><div class="el-scrollbar__bar is-horizontal"><div class="el-scrollbar__thumb" style="width:0;transform:translateX(0%);ms-transform:translateX(0%);webkit-transform:translateX(0%);"></div></div><div class="el-scrollbar__bar is-vertical"><div class="el-scrollbar__thumb" style="height:0;transform:translateY(0%);ms-transform:translateY(0%);webkit-transform:translateY(0%);"></div></div></div></div></div></div></div></div></div></div></header> <main class="el-main my-main" style="margin-left:240px;" data-v-c4863568 data-v-3431ceb9><div class="content-header index-header" data-v-61dd99b6 data-v-c4863568><div class="container fade-scale in" data-v-61dd99b6><h1 id="conentHeader" class="title" data-v-61dd99b6>【读书笔记】《JavaScript权威指南》第6章对象</h1> <h5 class="subtitle" data-v-61dd99b6>最后更新时间：2019-02-23 00:09:45</h5></div></div> <div data-v-aa2eb952 data-v-c4863568 data-v-c4863568><div class="post-content el-row is-justify-center el-row--flex" data-v-aa2eb952><div id="post-card" class="post-card post-sign el-col el-col-16 el-col-xs-24 el-col-sm-23 el-col-md-23 el-col-lg-16" data-v-aa2eb952><div class="content__default" data-v-aa2eb952><h2 id="对象简述（了解）"><a href="#对象简述（了解）" aria-hidden="true" class="header-anchor">#</a> 对象简述（了解）</h2> <p>  对象是 JavaScript 的基本数据类型。对象是一种复合值：它将很多值（原始值或者其他对象）聚合在一起，可通过名字访问这些值。对象也可看做是属性的无序集合，每个属性都是一个名/值对。属性名是字符串，因此我们可以把对象看成是从字符串到值的映射。这种基本数据结构还有很多种叫法，有些我们已然非常熟悉，比如“散列”（hash）、
“散列表”（hashtable）、“字典”（dictionary）、“关联数组”（associative array）。<br>
  然而对象不仅仅是字符串到值的映射，除了可以保持自有的属性，JavaScript 对象还可以从一个称为原型的对象继承属性。对象的方法通常是继承的属性。这种“原型式继承”（prototypal inheritance）是 JavaScript 的核心特征。<br>
  属性包括名字和值。属性名可以是包含空字符串在内的任意字符串，但对象中不能存在两个同名的属性。值可以是任意 JavaScript 值，或者（在 ECMAScript5 中）可以是一个 getter 或 setter 函数（或两者都有）。<br>
  除了名字和值之外，每个属性还有一些与之相关的值，称为“属性特性”（property attribute）:</p> <ul><li>可写（writable attribute），表明是否可以设置该属性的值。</li> <li>可枚举（enumerable attribute），表明是否可以通过 for/in 循环返回该属性。</li> <li>可配置（configurable attribute），表明是否可以删除或修改该属性。</li></ul> <p>  在 ECMAScript5 之前，通过代码给对象创建的所有属性都是可写的、可枚举的和可配置的。在 ECMAScript5 中则可以对这些特性加以配置。<br>
  除了包含属性之外，每个对象还拥有三个相关的对象特性（object attribute）：</p> <ul><li>对象的原型（prototype）指向另外一个对象，本对象的属性继承自它的原型对象。</li> <li>对象的类（class）是一个标识对象类型的字符串。</li> <li>对象的扩展标记（extensible flag）指明了（在 ECMAScript5 中）是否可以向该对象添加新属性。</li></ul> <p>  最后，我们用下面这些术语来对三类 JavaScript 对象和两类属性作区分：</p> <ul><li>内置对象（native object）是由 ECMAScript 规范定义的对象或类。例如，数组、函数、日期和正则表达式都是内置对象。</li> <li>宿主对象（host object）是由 JavaScript 解释器所嵌入的宿主环境（比如 Web 浏览器）定义的。客户端 JavaScript 中表示网页结构的 HTMLElement 对象均是宿主对象。既然宿主环境定义的方法可以当成普通的 JavaScript 函数对象，那么宿主对象也可以当成内置对象。</li> <li>自定义对象（user-defined object）是由运行中的 JavaScript 代码创建的对象。</li> <li>自有属性（own property）是直接在对象中定义的属性。</li> <li>继承属性（inherited property）是在对象的原型对象中定义的属性。</li></ul> <h2 id="创建对象（掌握）"><a href="#创建对象（掌握）" aria-hidden="true" class="header-anchor">#</a> 创建对象（掌握）</h2> <h3 id="对象直接量"><a href="#对象直接量" aria-hidden="true" class="header-anchor">#</a> 对象直接量</h3> <p>  对象直接量是由若干名/值对组成的映射表，名/值对中间用冒号分隔，名/值对之间用逗号分隔，整个映射表用花括号括起来。属性名可以是 JavaScript 标识符也可以是字符串直接量（包括空字符串）。属性的值可以是任意类型的 JavaScript 表达式。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> empty<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">}</span>；<span class="token comment">//没有任何属性的对象</span>
<span class="token keyword">var</span> point<span class="token operator">=</span><span class="token punctuation">{</span>x：<span class="token number">0</span>，y：<span class="token number">0</span><span class="token punctuation">}</span>；<span class="token comment">//两个属性</span>
<span class="token keyword">var</span> pointz<span class="token operator">=</span><span class="token punctuation">{</span>x<span class="token punctuation">:</span>point<span class="token punctuation">.</span>x，y<span class="token punctuation">:</span>point<span class="token punctuation">.</span>y<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">}</span>；<span class="token comment">//更复杂的值</span>
<span class="token keyword">var</span> book<span class="token operator">=</span><span class="token punctuation">{</span>
    <span class="token string">&quot;main title&quot;</span>：<span class="token string">&quot;Javascript&quot;</span>，<span class="token comment">//属性名字里有空格，必须用字符串表示</span>
    <span class="token string">'sub-title'</span>：<span class="token string">&quot;The Definitive Guide&quot;</span>，<span class="token comment">//属性名字里有连字符，必须用字符串表示</span>
    <span class="token string">&quot;for&quot;</span>：<span class="token string">&quot;all audiences&quot;</span>，<span class="token comment">//&quot;for&quot;是保留字，因此必须用引号</span>
    author<span class="token punctuation">:</span><span class="token punctuation">{</span>
        firstname<span class="token punctuation">:</span><span class="token string">&quot;David&quot;</span>，<span class="token comment">//注意，这里的属性名都没有引号</span>
        surname<span class="token punctuation">:</span><span class="token string">&quot;Flanagan&quot;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>；
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>  在 ECMAScript5（以及 ECMAScript3 的一些实现）中，保留字可以用做不带引号的属性名。然而对于 ECMAScript3 来说，使用保留字作为属性名必须使用引号引起来。<br>
  在 ECMAScript5 中，对象直接量中的最后一个属性后的逗号将忽略，且在 ECMAScript3 的大部分实现中也可以忽略这个逗号，但在 IE 中则报错。<br>
  对象直接量是一个表达式，这个表达式的每次运算都创建并初始化一个新的对象。每次计算对象直接量的时候，也都会计算它的每个属性的值。也就是说，如果在一个重复调用的函数中的循环体内使用了对象直接量，它将创建很多新对象，并且每次创建的对象的属性值也有可能不同。</p> <h3 id="通过-new-创建对象"><a href="#通过-new-创建对象" aria-hidden="true" class="header-anchor">#</a> 通过 new 创建对象</h3> <p>  new 运算符创建并初始化一个新对象。关键字 new 后跟随一个函数调用。这里的函数称做构造函数（constructor），构造函数用以初始化一个新创建的对象。JavaScript 语言核心中的原始类型都包含内置构造函数。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> o<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Object</span>（）；<span class="token comment">//创建一个空对象，和{}一样</span>
<span class="token keyword">var</span> a<span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span>（）；<span class="token comment">//创建一个空数组，和[]一样</span>
<span class="token keyword">var</span> d<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Date</span>（）；<span class="token comment">//创建一个表示当前时间的Date对象</span>
<span class="token keyword">var</span> r<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">RegExp</span>（<span class="token string">&quot;js&quot;</span>）；<span class="token comment">//创建一个可以进行模式匹配的EegExp对象</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h3 id="object-create"><a href="#object-create" aria-hidden="true" class="header-anchor">#</a> Object.create()</h3> <h4 id="原型"><a href="#原型" aria-hidden="true" class="header-anchor">#</a> 原型</h4> <p>  在讲述第三种对象创建技术之前，我们应当首先解释一下原型。每一个 JavaScript 对象（nu11 除外）都和另一个对象相关联。“另一个”对象就是我们熟知的原型，每一个对象都从原型继承属性。<br>
  所有通过对象直接量创建的对象都具有同一个原型对象，并可以通过 JavaScript 代码 object.prototype 获得对原型对象的引用。<br>
  通过关键字 new 和构造函数调用创建的对象的原型就是构造函数的 prototype 属性的值。因此，同使用{}创建对象一样，通过 new Object（）创建的对象也继承自 object.prototype。同样，通过 new Array（）创建的对象的原型就是 Array.prototype，通过 new Date（）创建的对象的原型就是 Date.prototype。<br>
  没有原型的对象为数不多，Object.prototype 就是其中之一。它不继承任何属性。其他原型对象都是普通对象，普通对象都具有原型。<br>
  所有的内置构造函数（以及大部分自定义的构造函数）都具有一个继承自 object.prototype 的原型。例如，Date.prototype 的属性继承自 Object.prototype，因此由 new Date（）创建的 Date 对象的属性同时继承自 Date.prototype 和 Object.prototype。这一系列链接的原型对象就是所谓的“原型链”（prototype chain）。</p> <h4 id="object-create（）"><a href="#object-create（）" aria-hidden="true" class="header-anchor">#</a> Object.create（）</h4> <p>  ECMAScript 5 定义了一个名为 Object.create（）的方法，它创建一个新对象，其中第一个参数是这个对象的原型。Object.create（）提供第二个可选参数，用以对对象的属性进行进一步描述。后面会详细讲述第二个参数。<br>
  Object.create（）是一个静态函数，而不是提供给某个对象调用的方法。使用它的方法很简单，只须传入所需的原型对象即可：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> o1<span class="token operator">=</span>Object<span class="token punctuation">.</span>create（<span class="token punctuation">{</span>x：<span class="token number">1</span>，y：<span class="token number">2</span><span class="token punctuation">}</span>）；<span class="token comment">//o1继承了属性x和y</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>  可以通过传入参数 nu11 来创建一个没有原型的新对象，但通过这种方式创建的对象不会继承任何东西，甚至不包括基础方法，比如 toString（），也就是说，它将不能和“+”
运算符一起正常工作。<br>
  如果想创建一个普通的空对象（比如通过{}或 new 0bject（）创建的对象），需要传入 Object.prototype：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> o3<span class="token operator">=</span>Object<span class="token punctuation">.</span>create（Object<span class="token punctuation">.</span>prototype）；<span class="token comment">//o3和{}和new Object（）一样</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>  通过原型继承创建一个新对象</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">//1inherit（）返回了一个继承自原型对象p的属性的新对象</span>
<span class="token comment">//这里使用ECMAScript 5中的Object.create（）函数（如果存在的话）</span>
<span class="token comment">//如果不存在Object.create（），则退化使用其他方法</span>
<span class="token keyword">function</span> inherit（p）<span class="token punctuation">{</span>
    <span class="token keyword">if</span>（p<span class="token operator">==</span><span class="token keyword">null</span>）<span class="token keyword">throw</span> TypeError（）；<span class="token comment">//p是一个对象，但不能是null</span>
    <span class="token keyword">if</span>（Object<span class="token punctuation">.</span>create）<span class="token comment">//如果0bject.create（）存在</span>
        <span class="token keyword">return</span> Object<span class="token punctuation">.</span>create（p）；<span class="token comment">//直接使用它</span>
    <span class="token keyword">var</span> t<span class="token operator">=</span><span class="token keyword">typeof</span> p；<span class="token comment">//否则进行进一步检测</span>
    <span class="token keyword">if</span>（t l<span class="token operator">==</span><span class="token string">&quot;object&quot;</span><span class="token operator">&amp;&amp;</span>t！<span class="token operator">==</span><span class="token string">&quot;function&quot;</span>）<span class="token keyword">throw</span> TypeError（）；
    <span class="token keyword">function</span> f（）<span class="token punctuation">{</span><span class="token punctuation">}</span>；<span class="token comment">//定义一个空构造函数</span>
    f<span class="token punctuation">.</span>prototype<span class="token operator">=</span>p；<span class="token comment">//将其原型属性设置为p</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">f</span>（）；<span class="token operator">/</span>使用f（）创建p的继承对象
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>  注意，inherit（）并不能完全代替 0bject.create（），它不能通过传入 nul1 原型来创建对象，而且不能接收可选的第二个参数。<br>
  inherit（）函数的其中一个用途就是防止库函数无意间（非恶意地）修改那些不受你控制的对象。当函数读取继承对象的属性时，实际上读取的是继承来的值。如果给继承对象的属性赋值，则这些属性只会影响这个继承对象自身，而不是原始对象：</p> <h2 id="属性的查询和设置（掌握）"><a href="#属性的查询和设置（掌握）" aria-hidden="true" class="header-anchor">#</a> 属性的查询和设置（掌握）</h2> <p>  可以通过点（.）或方括号（[]）运算符来获取属性的值,当使用方括号时，我们说方括号内的表达式必须返回字符串。其实更严格地讲，表达式必须返回字符串或返回一个可以转换为字符串的值。</p> <h3 id="作为关联数组的对象"><a href="#作为关联数组的对象" aria-hidden="true" class="header-anchor">#</a> 作为关联数组的对象.</h3> <div class="language-js line-numbers-mode"><pre class="language-js"><code>object<span class="token punctuation">.</span>property<span class="token punctuation">;</span>
object<span class="token punctuation">[</span><span class="token string">'property'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>  使用方括号和一个字符串，看起来更像数组，只是这个数组元素是通过字符串索引而不是数字索引。这种数组就是我们所说的关联数组（associative array），也称做散列、映射或字典（dictionary）。JavaScript 对象都是关联数组。</p> <h3 id="继承"><a href="#继承" aria-hidden="true" class="header-anchor">#</a> 继承</h3> <p>  JavaScript 对象具有“自有属性”（own property），也有一些属性是从原型对象继承而来的。假设要查询对象 o 的属性 x，如果 o 中不存在 x，那么将会继续在 o 的原型对象中查询属性 x。如果原型对象中也没有 x，但这个原型对象也有原型，那么继续在这个原型对象的原型上执行查询，直到找到 x 或者查找到一个原型是 nul1 的对象为止。可以看到，对象的原型属性构成了一个“链”，通过这个“链”可以实现属性的继承。<br>
  在 JavaScript 中，只有在查询属性时才会体会到继承的存在，而设置属性则和继承无关，这是 JavaScript 的一个重要特性，该特性让程序员可以有选择地覆盖（override）继承的属性。<br>
  属性赋值要么失败，要么创建一个属性，要么在原始对象中设置属性，但有一个例外，如果 o 继承自属性 x，而这个属性是一个具有 setter 方法的 accessor 属性，那么这时将调用 setter 方法而不是给 o 创建一个属性 x。需要注意的是，setter 方法是由对象 o 调用的，而不是定义这个属性的原型对象调用的。因此如果 setter 方法定义任意属性，这个操作只是针对 o 本身，并不会修改原型链。</p> <h3 id="属性访问错误"><a href="#属性访问错误" aria-hidden="true" class="header-anchor">#</a> 属性访问错误</h3> <p>  查询一个不存在的属性并不会报错，如果在对象 0 自身的属性或继承的属性中均未找到属性 x，属性访问表达式 o.x 返回 undefined。但是，如果对象不存在，那么试图查询这个不存在的对象的属性就会报错。nu11 和 undefined 值都没有属性，因此查询这些值的属性会报错。<br>
  当然，给 nu11 和 undefined 设置属性也会报类型错误。给其他值设置属性也不总是成功，有一些属性是只读的，不能重新赋值，有一些对象不允许新增属性，但让人颇感意外的是，这些设置属性的失败操作不会报错：这是一个历史遗留问题，这个 bug 在 ECMAScript5 的严格模式中已经修复。在严格模式中，任何失败的属性设置操作都会抛出一个类型错误异常。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">//内置构造函数的原型是只读的</span>
<span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token operator">=</span>o；<span class="token comment">//赋值失败，但没报错，Object.prototype没有修改</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h2 id="删除属性（掌握）"><a href="#删除属性（掌握）" aria-hidden="true" class="header-anchor">#</a> 删除属性（掌握）</h2> <p>  delete 运算符可以删除对象的属性。它的操作数应当是一个属性访问表达式。让人感到意外的是，delete 只是断开属性和宿主对象的联系，而不会去操作属性中的属性：<br>
  a={p:{x：1}}；b=a.p；delete a.p；执行这段代码之后 b.x 的值依然是 1。由于已经删除的属性的引用依然存在，因此在 JavaScript 的某些实现中，可能因为这种不严谨的代码而造成内存泄漏。所以在销毁对象的时候，要遍历属性中的属性，依次删除。<br>
  delete 运算符只能删除自有属性，不能删除继承属性（要删除继承属性必须从定义这个属性的原型对象上删除它，而且这会影响到所有继承自这个原型的对象）。<br>
  当 delete 表达式删除成功或没有任何副作用（比如删除不存在的属性）时，它返回 true。如果 delete 后不是一个属性访问表达式，delete 同样返回 true：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token number">0</span><span class="token operator">=</span><span class="token punctuation">{</span>x：<span class="token number">1</span><span class="token punctuation">}</span>；<span class="token comment">//o有一个属性x，并继承属性tostring</span>
<span class="token keyword">delete</span> o<span class="token punctuation">.</span>x；<span class="token comment">//删除x，返回true</span>
<span class="token keyword">delete</span> o<span class="token punctuation">.</span>x；<span class="token comment">//什么都没做（x已经不存在了），返回true</span>
<span class="token keyword">delete</span> o<span class="token punctuation">.</span>toString；<span class="token comment">//什么也没做（tostring是继承来的），返回true</span>
<span class="token keyword">delete</span> <span class="token number">1</span>；<span class="token comment">//无意义，返回true</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>  delete 不能删除那些可配置性为 fa1se 的属性（尽管可以删除不可扩展对象的可配置属性）。某些内置对象的属性是不可配置的，比如通过变量声明和函数声明创建的全局对象的属性。在严格模式中，删除一个不可配置属性会报一个类型错误。在非严格模式中（以及 ECMAScript3 中），在这些情况下的 delete 操作会返回 false：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">delete</span> object<span class="token punctuation">.</span>prototype；<span class="token comment">//不能删除，属性是不可配置的</span>
Var x<span class="token operator">=</span><span class="token number">1</span>；<span class="token comment">//声明一个全局变量</span>
<span class="token keyword">delete</span> <span class="token keyword">this</span><span class="token punctuation">.</span>x；<span class="token comment">//不能删除这个属性</span>
<span class="token keyword">function</span> f（）<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment">//声明一个全局函数</span>
<span class="token keyword">delete</span> <span class="token keyword">this</span><span class="token punctuation">.</span>f；<span class="token comment">//也不能删除全局函数</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>  在严格模式中，delete 后跟随一个非法的操作数（比如 x），则会报一个语法错误，因此必须显式指定对象及其属性。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">this</span><span class="token punctuation">.</span>x<span class="token operator">=</span><span class="token number">1</span>；<span class="token comment">//创建一个可配置的全局属性（没有用var）</span>
<span class="token keyword">delete</span> x；<span class="token comment">//将它删除，在严格模式下报错</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h2 id="检测属性（掌握）"><a href="#检测属性（掌握）" aria-hidden="true" class="header-anchor">#</a> 检测属性（掌握）</h2> <p>  JavaScript 对象可以看做属性的集合，我们经常会检测集合中成员的所属关系——判断某个属性是否存在于某个对象中。可以通过 in 运算符、hasOwnPreperty（）和 propertyIsEnumerable（）方法来完成这个工作，甚至仅通过属性查询也可以做到这一点。</p> <h3 id="in-运算符"><a href="#in-运算符" aria-hidden="true" class="header-anchor">#</a> in 运算符</h3> <p>  in 运算符的左侧是属性名（字符串），右侧是对象。如果对象的自有属性或继承属性中包含这个属性则返回 true。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> o<span class="token operator">=</span><span class="token punctuation">{</span>x：<span class="token number">1</span><span class="token punctuation">}</span>
<span class="token string">&quot;x&quot;</span> <span class="token keyword">in</span> o；<span class="token comment">//true:&quot;x“是o的属性</span>
<span class="token string">&quot;y&quot;</span> <span class="token keyword">in</span> o；<span class="token comment">//false:&quot;y&quot;不是o的属性</span>
<span class="token string">&quot;tostring&quot;</span> <span class="token keyword">in</span> o；<span class="token comment">//true:o继承toString属性</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h3 id="hasownpreperty（）"><a href="#hasownpreperty（）" aria-hidden="true" class="header-anchor">#</a> hasOwnPreperty（）</h3> <p>  对象的 hasownProperty（）方法用来检测给定的名字是否是对象的自有属性。对于继承属性它将返回 false：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> o<span class="token operator">=</span><span class="token punctuation">{</span>x：<span class="token number">1</span><span class="token punctuation">}</span>
o<span class="token punctuation">.</span>hasownProperty（“x&quot;）；<span class="token comment">//true:o有一个自有属性x</span>
o<span class="token punctuation">.</span>hasownProperty（<span class="token string">&quot;y&quot;</span>）；<span class="token comment">//false:o中不存在属性y</span>
o<span class="token punctuation">.</span>hasownProperty（<span class="token string">&quot;tostring&quot;</span>）；<span class="token comment">//false:toString是继承属性</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h3 id="propertyisenumerable"><a href="#propertyisenumerable" aria-hidden="true" class="header-anchor">#</a> propertyIsEnumerable()</h3> <p>  propertyIsEnumerable（）是 hasOwnProperty（）的增强版，只有检测到是自有属性且这个属性的可枚举性（enumerable attribute）为 true 时它才返回 true。某些内置属性是不可枚举的。通常由 JavaScript 代码创建的属性都是可枚举的，除非在 ECMAScript5 中使用一个特殊的方法来改变属性的可枚举性，随后会提到：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> o<span class="token operator">=</span>inherit（<span class="token punctuation">{</span>y：<span class="token number">2</span><span class="token punctuation">}</span>）；
o<span class="token punctuation">.</span>x<span class="token operator">=</span><span class="token number">1</span>；
o<span class="token punctuation">.</span>propertyIsEnumerable（<span class="token string">&quot;x&quot;</span>）；<span class="token comment">//true:o有一个可枚举的自有属性x</span>
o<span class="token punctuation">.</span>propertyIsEnumerable（<span class="token string">&quot;y&quot;</span>）；<span class="token comment">//false:y是继承来的</span>
object<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>propertyIsEnumerable（<span class="token string">&quot;toString&quot;</span>）；<span class="token comment">//false：不可枚举</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>  除了使用 in 运算符之外，另一种更简便的方法是使用“l==”判断一个属性是否是 undefined：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> o<span class="token operator">=</span><span class="token punctuation">{</span>x：<span class="token number">1</span><span class="token punctuation">}</span>
o<span class="token punctuation">.</span>x <span class="token operator">!==</span><span class="token keyword">undefined</span>；<span class="token comment">//true:o中有属性x</span>
o<span class="token punctuation">.</span>y <span class="token operator">!==</span>a <span class="token keyword">undefined</span>；<span class="token comment">//false:o中没有属性y</span>
o<span class="token punctuation">.</span>toString <span class="token operator">!==</span><span class="token keyword">undefined</span>；<span class="token comment">//true:o继承了toString属性</span>
<span class="token template-string"><span class="token string">``</span></span><span class="token template-string"><span class="token string">`js
&amp;emsp;&amp;emsp;然而有一种场景只能使用in运算符而不能使用上述属性访问的方式。in可以区分不存在的属性和存在但值为undefined的属性。
`</span></span><span class="token template-string"><span class="token string">``</span></span>js
<span class="token keyword">var</span> o<span class="token operator">=</span><span class="token punctuation">{</span>x<span class="token punctuation">:</span><span class="token keyword">undefined</span><span class="token punctuation">}</span><span class="token comment">//属性被显式赋值为undefined</span>
o<span class="token punctuation">.</span>x！<span class="token operator">==</span><span class="token keyword">undefined</span><span class="token comment">//false：属性存在，但值为undefined o.</span>
y <span class="token operator">!==</span> <span class="token keyword">undefined</span><span class="token comment">//false：属性不存在</span>
&quot;x” <span class="token keyword">in</span> o<span class="token comment">//true：属性存在</span>
<span class="token string">&quot;y&quot;</span> <span class="token keyword">in</span> o<span class="token comment">//false：属性不存在</span>
<span class="token keyword">delete</span> o<span class="token punctuation">.</span>x；<span class="token comment">//删除了属性x</span>
“x” <span class="token keyword">in</span> o<span class="token comment">//false：属性不再存在</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><h2 id="枚举属性（掌握）"><a href="#枚举属性（掌握）" aria-hidden="true" class="header-anchor">#</a> 枚举属性（掌握）</h2> <h3 id="for-in-循环"><a href="#for-in-循环" aria-hidden="true" class="header-anchor">#</a> for/in 循环</h3> <p>  for/in 循环可以在循环体中遍历对象中所有可枚举的属性（包括自有属性和继承的属性），把属性名称赋值给循环变量。对象继承的内置方法不可枚举的，但在代码中给对象添加的属性都是可枚举的（除非用下文中提到的一个方法将它们转换为不可枚举的）。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> o<span class="token operator">=</span><span class="token punctuation">{</span>x：<span class="token number">1</span>，y：<span class="token number">2</span>，z：<span class="token number">3</span><span class="token punctuation">}</span>；<span class="token comment">//三个可枚举的自有属性</span>
o<span class="token punctuation">.</span>propertyIsEnumerable（<span class="token string">&quot;toString&quot;</span>）<span class="token comment">//=&gt;false，不可枚举</span>
<span class="token keyword">for</span>（p <span class="token keyword">in</span> o）<span class="token comment">//遍历属性</span>
console<span class="token punctuation">.</span>log（p）；<span class="token comment">//输出x、y和z，不会输出tostring</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>  有许多实用工具库给 0bject.prototype 添加了新的方法或属性，这些方法和属性可以被所有对象继承并使用。然而在 ECMAScript 5 标准之前，这些新添加的方法是不能定义为不可枚举的，因此它们都可以在 for/in 循环中枚举出来。为了避免这种情况，需要过滤 for/in 循环返回的属性，下面两种方式是最常见的：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">for</span>（p <span class="token keyword">in</span> o）<span class="token punctuation">{</span>
    <span class="token keyword">if</span>（lo<span class="token punctuation">.</span>hasownProperty（p））<span class="token keyword">continue</span>；<span class="token comment">//跳过继承的属性</span>
<span class="token punctuation">}</span>
<span class="token keyword">for</span>（p <span class="token keyword">in</span> o）<span class="token punctuation">{</span>
    <span class="token keyword">if</span>（<span class="token keyword">typeof</span> o<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token operator">===</span><span class="token string">&quot;function&quot;</span>）<span class="token keyword">continue</span>；<span class="token comment">//跳过方法</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h3 id="object-keys"><a href="#object-keys" aria-hidden="true" class="header-anchor">#</a> Object.keys()</h3> <p>  除了 for/in 循环之外，ECMAScript5 定义了两个用以枚举属性名称的函数。第一个是 0bject.keys（），它返回一个数组，这个数组由对象中可枚举的自有属性的名称组成。</p> <h3 id="object-getownpropertynames"><a href="#object-getownpropertynames" aria-hidden="true" class="header-anchor">#</a> Object.getownPropertyNames()</h3> <p>  ECMAScript 5 中第二个枚举属性的函数是 0bject.getownPropertyNames（），它和 0jbect.keys（）类似，只是它返回对象的所有自有属性的名称，而不仅仅是可枚举的属性。在 ECMAScript3 中是无法实现的类似的函数的，因为 ECMAScript3 中没有提供任何方法来获取对象不可枚举的属性。</p> <h2 id="属性-getter-和-setter（掌握）"><a href="#属性-getter-和-setter（掌握）" aria-hidden="true" class="header-anchor">#</a> 属性 getter 和 setter（掌握）</h2> <p>  在 ECMAScript 5 中，属性值可以用一个或两个方法替代，这两个方法就是 getter 和 setter。由 getter 和 setter 定义的属性称做“存取器属性”（accessor property），它不同于“数据属性”（data property），数据属性只有一个简单的值。<br>
  当程序查询存取器属性的值时，JavaScript 调用 getter 方法（无参数）。这个方法的返回值就是属性存取表达式的值。<br>
  当程序设置一个存取器属性的值时，JavaScript 调用 setter 方法，将赋值表达式右侧的值当做参数传入 setter。从某种意义上讲，这个方法负责“设置”属性值。可以忽略 setter 方法的返回值。<br>
  和数据属性不同，存取器属性不具有可写性（writable attribute）。如果属性同时具有 getter 和 setter 方法，那么它是一个读/写属性。如果它只有 getter 方法，那么它是一个只读属性。如果它只有 setter 方法，那么它是一个只写属性（数据属性中有一些例外），读取只写属性总是返回 undefined。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> o<span class="token operator">=</span><span class="token punctuation">{</span>
    <span class="token comment">//普通的数据属性</span>
    data_prop<span class="token punctuation">:</span>value，<span class="token comment">//存取器属性都是成对定义的函数</span>
    <span class="token keyword">get</span> accessor_prop（）<span class="token punctuation">{</span><span class="token comment">/*这里是函数体*/</span><span class="token punctuation">}</span>，
    <span class="token keyword">set</span> accessor_prop（value）<span class="token punctuation">{</span><span class="token comment">/*这里是函数体*/</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>；
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>  存取器属性定义为一个或两个和属性同名的函数，这个函数定义没有使用 function 关键字，而是使用 get 和（或）set。注意，这里没有使用冒号将属性名和函数体分隔开，但在函数体的结束和下一个方法或数据属性之间有逗号分隔。和数据属性一样，存取器属性是可以继承的。</p> <h2 id="属性的特性（掌握）"><a href="#属性的特性（掌握）" aria-hidden="true" class="header-anchor">#</a> 属性的特性（掌握）</h2> <p>  除了包含名字和值之外，属性还包含一些标识它们可写、可枚举和可配置的特性。在 ECMAScript3 中无法设置这些特性，所有通过 ECMAScript3 的程序创建的属性都是可写的、可枚举的和可配置的，且无法对这些特性做修改。<br>
  可以认为一个属性包含一个名字和 4 个特性。<br>
  数据属性的 4 个特性分别是它的值（value）、可写性（writable）、可枚举性（enumerable）和可配置性（configurable）。<br>
  存取器属性不具有值（value）特性和可写性，它们的可写性是由 setter 方法存在与否决定的。因此存取器属性的 4 个特性是读取（get）、写入（set）、可枚举性和可配置性。
  为了实现属性特性的查询和设置操作，ECMAScript5 中定义了一个名为“属性描述符”（property descriptor）的对象，这个对象代表那 4 个特性。<br>
  数据属性的描述符对象的属性有 value、writable、enumerable 和 configurable。存取器属性的描述符对象则用 get 属性和 set 属性代替 value 和 writable。<br>
  其中 writable、enumerable 和 configurable 都是布尔值，当然，get 属性和 set 属性是函数值。</p> <h3 id="object-getownpropertydescriptor"><a href="#object-getownpropertydescriptor" aria-hidden="true" class="header-anchor">#</a> Object.getOwnPropertyDescriptor()</h3> <h4 id="读取"><a href="#读取" aria-hidden="true" class="header-anchor">#</a> 读取</h4> <p>  通过调用 0bject.getownPropertyDescriptor（）可以获得某个对象特定属性的属性描述符：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">//返回{value：1，writable:true，enumerable:true，configurable:true}</span>
Object<span class="token punctuation">.</span>getownPropertyDescriptor（<span class="token punctuation">{</span>x：<span class="token number">1</span><span class="token punctuation">}</span>，<span class="token string">&quot;x&quot;</span>）；
<span class="token comment">//返回{get:/*func*/，set:undefned，enumerable:true，configurable:true}</span>
Object<span class="token punctuation">.</span>getownPropertyDescriptor（random，<span class="token string">&quot;octet&quot;</span>）；
<span class="token comment">//对于继承属性和不存在的属性，返回undefined</span>
Object<span class="token punctuation">.</span>getownPropertyDescriptor（<span class="token punctuation">{</span><span class="token punctuation">}</span>，<span class="token string">&quot;x&quot;</span>）；<span class="token comment">//undefined，没有这个属性</span>
Object<span class="token punctuation">.</span>getownPropertyDescriptor（<span class="token punctuation">{</span><span class="token punctuation">}</span>，<span class="token string">&quot;tostring&quot;</span>）；<span class="token comment">//undefined，继承属性</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>  从函数名字就可以看出，Object.getownPropertyDescriptor（）只能得到自有属性的描述符。要想获得继承属性的特性，需要遍历原型链（Object.getPrototypeof（））。</p> <h4 id="设置"><a href="#设置" aria-hidden="true" class="header-anchor">#</a> 设置</h4> <h5 id="object-defineproperty"><a href="#object-defineproperty" aria-hidden="true" class="header-anchor">#</a> Object.defineProperty()</h5> <p>  要想设置属性的特性，或者想让新建属性具有某种特性，则需要调用 Object.definePeoperty（），传入要修改的对象、要创建或修改的属性的名称以及属性描述符对象：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> o<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">}</span>；<span class="token comment">//创建一个空对象</span>
<span class="token comment">//添加一个不可枚举的数据属性x，并赋值为1</span>
Object<span class="token punctuation">.</span>defineProperty（o，<span class="token string">&quot;x&quot;</span>，<span class="token punctuation">{</span>value：<span class="token number">1</span>，writable<span class="token punctuation">:</span><span class="token boolean">true</span>，enumerable<span class="token punctuation">:</span><span class="token boolean">false</span>，configurable<span class="token punctuation">:</span><span class="token boolean">true</span><span class="token punctuation">}</span>）；
<span class="token comment">//属性是存在的，但不可枚举</span>
o<span class="token punctuation">.</span>x；<span class="token comment">//=&gt;1</span>
Object<span class="token punctuation">.</span>keys（o）<span class="token comment">//=&gt;[]</span>
<span class="token comment">//现在对属性x做修改，让它变为只读</span>
Object<span class="token punctuation">.</span>defineproperty（o，<span class="token string">&quot;x&quot;</span>，<span class="token punctuation">{</span>writable<span class="token punctuation">:</span><span class="token boolean">false</span><span class="token punctuation">}</span>）；
<span class="token comment">//试图更改这个属性的值</span>
o<span class="token punctuation">.</span>x<span class="token operator">=</span><span class="token number">2</span>；<span class="token comment">//操作失败但不报错，而在严格模式中抛出类型错误异常</span>
o<span class="token punctuation">.</span>x<span class="token comment">//=&gt;1</span>
<span class="token comment">//属性依然是可配置的，因此可以通过这种方式对它进行修改：</span>
Object<span class="token punctuation">.</span>defineproperty（o，<span class="token string">&quot;x&quot;</span>，<span class="token punctuation">{</span>value：<span class="token number">2</span><span class="token punctuation">}</span>）；
o<span class="token punctuation">.</span>x<span class="token comment">//=&gt;2</span>
<span class="token comment">//现在将x从数据属性修改为存取器属性</span>
Object<span class="token punctuation">.</span>defneProperty（o，<span class="token string">&quot;x&quot;</span>，<span class="token punctuation">{</span><span class="token function-variable function">get</span><span class="token punctuation">:</span><span class="token keyword">function</span>（）<span class="token punctuation">{</span><span class="token keyword">return</span> o；<span class="token punctuation">}</span><span class="token punctuation">}</span>）；o<span class="token punctuation">.</span>x<span class="token comment">//=&gt;0</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>  传入 object.defineProperty（）的属性描述符对象不必包含所有 4 个特性。对于新创建的属性来说，默认的特性值是 false 或 undefined。对于修改的已有属性来说，默认的特性值没有做任何修改。注意，这个方法要么修改已有属性要么新建自有属性，但不能修改继承属性。</p> <h5 id="object-defineproperties"><a href="#object-defineproperties" aria-hidden="true" class="header-anchor">#</a> Object.defineProperties()</h5> <p>  如果要同时修改或创建多个属性，则需要使用 0bject.defineProperties（）。第一个参数是要修改的对象，第二个参数是一个映射表，它包含要新建或修改的属性的名称，以及它们的属性描述符，例如：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> p<span class="token operator">=</span>Object<span class="token punctuation">.</span> <span class="token function">defineProperties</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">{</span>
    x<span class="token punctuation">:</span><span class="token punctuation">{</span> value<span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">,</span> writable<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> enumerable<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> configurable<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    y<span class="token punctuation">:</span><span class="token punctuation">{</span> value<span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">,</span> writable<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> enumerable<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> configurable<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">}</span><span class="token punctuation">,</span> r<span class="token punctuation">:</span><span class="token punctuation">{</span>
    <span class="token function-variable function">get</span><span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">return</span> Math<span class="token punctuation">.</span> <span class="token function">sqrt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>x<span class="token operator">*</span> <span class="token keyword">this</span><span class="token punctuation">.</span>x<span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>y<span class="token operator">*</span> <span class="token keyword">this</span><span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    enumerable<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    configurable<span class="token punctuation">:</span> <span class="token boolean">true</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>  对于那些不允许创建或修改的属性来说，如果用 Object.defineProperty（）和 Object.defineProperties（）对其操作（新建或修改）就会抛出类型错误异常，比如，给一个不可扩展的对象新增属性就会抛出类型错误异常。<br>
  下面是完整的规则，任何对 0bject.defineProperty（）或 Object.defineProperties（）违反规则的使用都会抛出类型错误异常：</p> <ul><li>如果对象是不可扩展的，则可以编辑已有的自有属性，但不能给它添加新属性。</li> <li>如果属性是不可配置的，则不能修改它的可配置性和可枚举性。</li> <li>如果存取器属性是不可配置的，则不能修改其 getter 和 setter 方法，也不能将它转换为数据属性。</li> <li>如果数据属性是不可配置的，则不能将它转换为存取器属性。</li> <li>如果数据属性是不可配置的，则不能将它的可写性从 false 修改为 true，但可以从 true 修改为 false。</li> <li>如果数据属性是不可配置且不可写的，则不能修改它的值。然而可配置但不可写属性的值是可以修改的（实际上是先将它标记为可写的，然后修改它的值，最后转换为不可写的）。</li></ul> <p>  复制属性的特性</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">/*
*给Object.prototype添加一个不可枚举的extend（）方法
*这个方法继承自调用它的对象，将作为参数传入的对象的属性一一复制
*除了值之外，也复制属性的所有特性，除非在目标对象中存在同名的属性，
*参数对象的所有自有对象（包括不可枚举的属性）也会一一复制。
*/</span>
Object<span class="token punctuation">.</span>defineProperty（object<span class="token punctuation">.</span>prototype，
    “extend&quot;<span class="token class-name">，定义Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>extend
    <span class="token punctuation">{</span>
        writable<span class="token punctuation">:</span><span class="token boolean">true</span>，enumerable<span class="token punctuation">:</span><span class="token boolean">false</span>，<span class="token comment">//将其定义为不可枚举的</span>
        configurable<span class="token punctuation">:</span><span class="token boolean">true</span>，
        <span class="token function-variable function">value</span><span class="token punctuation">:</span><span class="token keyword">function</span>（o）<span class="token punctuation">{</span><span class="token comment">//值就是这个函数</span>
            <span class="token comment">//得到所有的自有属性，包括不可枚举属性</span>
            <span class="token keyword">var</span> names<span class="token operator">=</span>Object<span class="token punctuation">.</span>getownPropertyNames（o）；
            <span class="token comment">//遍历它们</span>
            <span class="token keyword">for</span>（<span class="token keyword">var</span> i<span class="token operator">=</span>o；i<span class="token operator">&lt;</span>names<span class="token punctuation">.</span>length；i<span class="token operator">++</span>）<span class="token punctuation">{</span>
            <span class="token comment">//如果属性已经存在，则跳过</span>
                <span class="token keyword">if</span>（names<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token keyword">in</span> <span class="token keyword">this</span>）<span class="token keyword">continue</span>；
                <span class="token comment">//获得0中的属性的描述符</span>
                <span class="token keyword">var</span> desc<span class="token operator">=</span>Object<span class="token punctuation">.</span>getOwnPropertyDescriptor（o，names<span class="token punctuation">[</span>i<span class="token punctuation">]</span>）；
                <span class="token comment">//用它给this创建一个属性</span>
                Object<span class="token punctuation">.</span>defineProperty（<span class="token keyword">this</span>，names<span class="token punctuation">[</span>i<span class="token punctuation">]</span>，desc）；
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>）；
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br></div></div><h3 id="getter-和-setter-的老式-api"><a href="#getter-和-setter-的老式-api" aria-hidden="true" class="header-anchor">#</a> getter 和 setter 的老式 API</h3> <p>  可以通过对象直接量语法给新对象定义存取器属性，但不能查询属性的 getter 和 setter 方法或给已有的对象添加新的存取器属性。在 ECMAScript5 中，可以通过 Object.getOwnPropertyDescriptor（）和 0bject.defineproperty（）来完成这些工作。<br>
  在 ECMAScript5 标准被采纳之前，大多数 JavaScript 的实现（IE 浏览器除外）已经可以支持对象直接量语法中的 get 和 set 写法。这些实现提供了非标准的老式 API 用来查询和设置 getter 和 setter。这些 API 由 4 个方法组成，所有对象都拥有这些方法。
_lookupGetter_（）和_lookupSetter_（）用以返回一个命名属性的 getter 和 setter 方法。defineGetter（）和 defineSetter（）用以定义 getter 和 setter，这两个函数的第一个参数是属性名字，第二个参数是 getter 和 setter 方法。这 4 个方法都是以两条下划线作前缀，两条下划线作后缀，以表明它们是非标准的方法。</p> <h2 id="对象的三个属性-掌握"><a href="#对象的三个属性-掌握" aria-hidden="true" class="header-anchor">#</a> 对象的三个属性(掌握)</h2> <h3 id="原型属性"><a href="#原型属性" aria-hidden="true" class="header-anchor">#</a> 原型属性</h3> <p>  对象的原型属性是用来继承属性的，这个属性如此重要，以至于我们经常把“o 的原型属性”直接叫做“o 的原型”。<br>
  原型属性是在实例对象创建之初就设置好的，通过对象直接量创建的对象使用 Object.prototype 作为它们的原型。通过 new 创建的对象使用构造函数的 prototype 属性作为它们的原型。通过 Object.create（）创建的对象使用第一个参数（也可以是 nul1）作为它们的原型。<br>
  在 ECMAScript5 中，将对象作为参数传入 Object.getPrototypeOf（）可以查询它的原型。在 ECMAScript3 中，则没有与之等价的函数，但经常使用表达式 o.constructor.prototype 来检测一个对象的原型。通过 new 表达式创建的对象，通常继承一个 constructor 属性，这个属性指代创建这个对象的构造函数。<br>
  后面还解释了使用这种方法来检测对象原型的方式并不可靠的原因。注意，通过对象直接量或 Object.create（）创建的对象包含一个名为 constructor 的属性，这个属性指代 Object（）构造函数。因此，constructor.prototype 才是对象直接量的真正的原型，但对于通过 Object.create（）创建的对象则往往不是这样。<br>
  要想检测一个对象是否是另一个对象的原型（或处于原型链中），请使用 isPrototypeof（）方法。例如，可以通过 p.isPrototypeOf（o）来检测 p 是否是 o 的原型,isPrototypeOf（）函数实现的功能和 instanceof 运算符非常类似：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> p<span class="token operator">=</span><span class="token punctuation">{</span>x：<span class="token number">1</span><span class="token punctuation">}</span>；<span class="token operator">/</span>定义一个原型对象
<span class="token keyword">var</span> o<span class="token operator">=</span>Object<span class="token punctuation">.</span>create（p）；<span class="token comment">//使用这个原型创建一个对象</span>
p<span class="token punctuation">.</span>isPrototype0f（o）<span class="token comment">//=&gt;true:o继承自p</span>
<span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>isPrototypeOf（o）<span class="token comment">//=&gt;true:p继承自object.prototype</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>  Mozilla 实现的 JavaScript（包括早些年的 Netscape）对外暴露了一个专门命名为<em>proto</em>的属性，用以直接查询/设置对象的原型。但并不推荐使用<em>proto</em>，因为尽管 Safari 和 Chrome 的当前版本都支持它，但 IE 和 Opera 还未实现它（可能以后也不会实现）。实现了 ECMAScript 5 的 Firefox 版本依然支持_proto，但对修改不可扩展对象的原型做了限制。</p> <h3 id="类属性"><a href="#类属性" aria-hidden="true" class="header-anchor">#</a> 类属性</h3> <p>  对象的类属性（class attribute）是一个字符串，用以表示对象的类型信息。ECMAScript
3 和 ECMAScript5 都未提供设置这个属性的方法，并只有一种间接的方法可以查询它。
默认的 toString（）方法（继承自 Object.prototype）返回了如下这种格式的字符串：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token punctuation">[</span>object <span class="token keyword">class</span><span class="token punctuation">]</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>  因此，要想获得对象的类，可以调用对象的 tostring（）方法，然后提取已返回字符串的第 8 个到倒数第二个位置之间的字符。不过让人感觉棘手的是，很多对象继承的 tostring（）方法重写了，为了能调用正确的 tostring（）版本，必须间接地调用 Function.ca11（）方法。<br>
  classof（）函数可以返回传递给它的任意对象的类：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">classof</span><span class="token punctuation">(</span><span class="token parameter">o</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token string">'Null'</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token operator">===</span> <span class="token keyword">undefined</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token string">'Undefined'</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>toString<span class="token punctuation">.</span><span class="token function">cal1</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>  通过内置构造函数（比如 Array 和 Date）创建的对象包含“类属性”（class atribute），它与构造函数名称相匹配。宿主对象也包含有意义的“类属性”，但这和具体的 JavaScript 实现有关。通过对象直接量和 Object.create 创建的对象的类属性是“Object”，那些自定义构造函数创建的对象也是一样，类属性也是“Object”，因此对于自定义的类来说，没办法通过类属性来区分对象的类：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>classof（nul1）<span class="token comment">//=&gt;&quot;Null&quot;</span>
classof（<span class="token number">1</span>）<span class="token comment">//=&gt;&quot;Number&quot;</span>
c1assof（<span class="token string">&quot;&quot;</span>）<span class="token comment">//=&gt;&quot;String&quot;</span>
classof（<span class="token boolean">false</span>）<span class="token comment">//=&gt;&quot;Boolean&quot;</span>
classof（<span class="token punctuation">{</span><span class="token punctuation">}</span>）<span class="token comment">//=&gt;&quot;Object&quot;</span>
classof（<span class="token punctuation">[</span><span class="token punctuation">]</span>）<span class="token comment">//=&gt;&quot;Array&quot;</span>
classof（<span class="token operator">/</span><span class="token punctuation">.</span><span class="token operator">/</span>）<span class="token comment">//=&gt;&quot;Regexp&quot;</span>
classof（<span class="token keyword">new</span> <span class="token class-name">Date</span>（））<span class="token comment">//=&gt;&quot;Date&quot;.</span>
classof（window）<span class="token comment">//=&gt;&quot;Window”（这是客户端宿主对象）</span>
<span class="token keyword">function</span> f（）<span class="token punctuation">{</span><span class="token punctuation">}</span>；<span class="token comment">//定义一个自定义构造函数</span>
classof（<span class="token keyword">new</span> <span class="token class-name">f</span>（））；<span class="token comment">//=&gt;&quot;Object&quot;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h3 id="可扩展性"><a href="#可扩展性" aria-hidden="true" class="header-anchor">#</a> 可扩展性</h3> <p>  对象的可扩展性用以表示是否可以给对象添加新属性。所有内置对象和自定义对象都是显式可扩展的，宿主对象的可扩展性是由 JavaScript 引擎定义的。除非将它们转换为不可扩展的。<br>
  ECMAScript5 定义了用来查询和设置对象可扩展性的函数。通过将对象传入 Object.esExtensible（），来判断该对象是否是可扩展的。如果想将对象转换为不可扩展的，需要调用 Object.preventExtensions（），将待转换的对象作为参数传进去。注意，一旦将对象转换为不可扩展的，就无法再将其转换回可扩展的了。同样需要注意的是，preventExtensions（）只影响到对象本身的可扩展性。如果给一个不可扩展的对象的原型添加属性，这个不可扩展的对象同样会继承这些新属性。<br>
  可扩展属性的目的是将对象“锁定”，以避免外界的干扰。对象的可扩展性通常和属性的可配值性与可写性配合使用。<br>
  Object.seal（）和 Object.preventExtensions（）类似，除了能够将对象设置为不可扩展的，还可以将对象的所有自有属性都设置为不可配置的。也就是说，不能给这个对象添加新属性，而且它已有的属性也不能删除或配置，不过它已有的可写属性依然可以设置。对于那些已经封闭（sealed）起来的对象是不能解封的。可以使用 Object.isSealed（）来检测对象是否封闭。<br>
  Object.freeze（）将更严格地锁定对象——“冻结”（frozen）。除了将对象设置为不可扩展的和将其属性设置为不可配置的之外，还可以将它自有的所有数据属性设置为只读（如果对象的存取器属性具有 setter 方法，存取器属性将不受影响，仍可以通过给属性赋值调用它们）。使用 Object.isFrozen（）来检测对象是否冻结。<br>
  Object.preventExtensions（）、Object.seal（）和 Object.freeze（）都返回传入的对象，也就是说，可以通过函数嵌套的方式调用它们：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">//创建一个封闭对象，包括一个冻结的原型和一个不可枚举的属性</span>
<span class="token keyword">var</span> o<span class="token operator">=</span>object<span class="token punctuation">.</span>seal（Object<span class="token punctuation">.</span>create（Object<span class="token punctuation">.</span>freeze（<span class="token punctuation">{</span>x：<span class="token number">1</span><span class="token punctuation">}</span>），
                        <span class="token punctuation">{</span>y<span class="token punctuation">:</span><span class="token punctuation">{</span>value：<span class="token number">2</span>，writable<span class="token punctuation">:</span><span class="token boolean">true</span><span class="token punctuation">}</span><span class="token punctuation">}</span>））；
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h2 id="序列化对象-掌握"><a href="#序列化对象-掌握" aria-hidden="true" class="header-anchor">#</a> 序列化对象(掌握)</h2> <p>  对象序列化（serialization）是指将对象的状态转换为字符串，也可将字符串还原为对象。ECMAScript 5 提供了内置函数]S0N.stringify（）和]S0N.parse（）用来序列化和还原 JavaScript 对象。这些方法都使用 JSON 作为数据交换格式，JSON 的全称是“JavaScript Object Notation”——JavaScript 对象表示法，它的语法和 JavaScript 对象与数组直接量的语法非常相近：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>o<span class="token operator">=</span><span class="token punctuation">{</span>x：<span class="token number">1</span>，y<span class="token punctuation">:</span><span class="token punctuation">{</span>z<span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token boolean">false</span>，<span class="token keyword">null</span>，“<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">}</span>；<span class="token comment">//定义一个测试对象</span>
s<span class="token operator">=</span><span class="token constant">JS0N</span><span class="token punctuation">.</span>stringify（o）；<span class="token comment">//s是{&quot;x&quot;：1，&quot;y&quot;：{&quot;z&quot;：[false，mull，&quot;&quot;]}}</span>
p<span class="token operator">=</span><span class="token constant">JS0N</span><span class="token punctuation">.</span>parse（s）；<span class="token comment">//p是o的深拷贝</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>  NaN、Infinity 和-Infinity 序列化的结果是 null，日期对象序列化的结果是 ISO 格式的日期字符串（参照 Date.toJSON（）函数），但 JSON.parse（）依然保留它们的字符串形态，而不会将它们还原为原始日期对象。函数、RegExp、Error 对象和 undefined 值不能序列化和还原。JSON.stringify（）只能序列化对象可枚举的自有属性。对于一个不能序列化的属性来说，在序列化后的输出字符串中会将这个属性省略掉。<br>
  JSON.stringify（）和 JSON.parse（）都可以接收第二个可选参数，通过传入需要序列化或还原的属性列表来定制自定义的序列化或还原操作。</p> <h2 id="对象方法（掌握）"><a href="#对象方法（掌握）" aria-hidden="true" class="header-anchor">#</a> 对象方法（掌握）</h2> <h3 id="tostring（）方法"><a href="#tostring（）方法" aria-hidden="true" class="header-anchor">#</a> toString（）方法</h3> <p>  toString（）方法没有参数，它将返回一个表示调用这个方法的对象值的字符串。默认的 toString（）方法的返回值带有的信息量很少，例如，下面这行代码的计算结果为字符串“[object Object]”：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> s<span class="token operator">=</span><span class="token punctuation">{</span>x：<span class="token number">1</span>，y：<span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">.</span>tostring（）；
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>  由于默认的 toString（）方法并不会输出很多有用的信息，因此很多类都带有自定义的 toString（）。例如，当数组转换为字符串的时候，结果是一个数组元素列表，只是每个元素都转换成了字符串，再比如，当函数转换为字符串的时候，得到函数的源代码。</p> <h3 id="tolocalestring（）方法"><a href="#tolocalestring（）方法" aria-hidden="true" class="header-anchor">#</a> toLocaleString（）方法</h3> <p>  除了基本的 toString（）方法之外，对象都包含 tolocaleString（）方法，这个方法返回一个表示这个对象的本地化字符串。0bject 中默认的 toLocaleString（）方法并不做任何本地化自身的操作，它仅调用 toString（）方法并返回对应值。Date 和 Number 类对 toLocaleString（）方法做了定制，可以用它对数字、日期和时间做本地化的转换。Array 类的 toLocalestring（）方法和 toString（）方法很像，唯一的不同是每个数组元素会调用 tolocalestring（）方法转换为字符串，而不是调用各自的 toString（）方法。</p> <h3 id="tojson（）方法"><a href="#tojson（）方法" aria-hidden="true" class="header-anchor">#</a> toJSON（）方法</h3> <p>  Object.prototype 实际上没有定义 toJSON（）方法，但对于需要执行序列化的对象来说，JSON.stringify（）方法会调用 toJSON（）方法。如果在待序列化的对象中存在这个方法，则调用它，返回值即是序列化的结果，而不是原始的对象。具体示例参见 Date.toJSON（）。</p> <h3 id="valueof（）方法"><a href="#valueof（）方法" aria-hidden="true" class="header-anchor">#</a> valueOf（）方法</h3> <p>  valueOf（）方法和 toString（）方法非常类似，但往往当 JavaScript 需要将对象转换为某种原始值而非字符串的时候才会调用它，尤其是转换为数字的时候。如果在需要使用原始值的上下文中使用了对象，JavaScript 就会自动调用这个方法。默认的 valueOf（）方法不足为奇，但有些内置类自定义了 valueOf（）方法（比如 Date.valueOf（））。</p></div> <span id="footerPost" data-v-aa2eb952></span></div> <div id="post-toc" class="post-toc el-col el-col-6" data-v-aa2eb952><h4 class="catalog-title" data-v-aa2eb952>TOC</h4> <div class="catalog-body" data-v-aa2eb952><ul id="catalog-list" class="catalog-list" data-v-aa2eb952></ul></div></div></div> <div class="post-nav el-row is-justify-space-around el-row--flex" data-v-aa2eb952><div class="post-prev el-col el-col-7" data-v-aa2eb952><div data-v-aa2eb952><a href="/posts/%E3%80%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%91%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B%E7%AC%AC7%E7%AB%A0%E6%95%B0%E7%BB%84.html" data-v-aa2eb952><i class="el-icon-arrow-left" data-v-aa2eb952></i> Prev
        </a> <p class="nav-title" data-v-aa2eb952>【读书笔记】《JavaScript权威指南》第7章数组</p></div></div> <div class="post-next el-col el-col-7 el-col-lg-pull-5" data-v-aa2eb952><div data-v-aa2eb952><a href="/posts/%E3%80%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%91%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B%E7%AC%AC5%E7%AB%A0%E8%AF%AD%E5%8F%A5.html" data-v-aa2eb952>
          Next
          <i class="el-icon-arrow-right" data-v-aa2eb952></i></a> <p class="nav-title" data-v-aa2eb952>【读书笔记】《JavaScript权威指南》第5章语句</p></div></div></div> <div class="el-row is-justify-center el-row--flex" data-v-aa2eb952><div class="el-col el-col-23" data-v-aa2eb952></div></div> <span data-v-1ba756dd data-v-aa2eb952><button type="button" class="el-button toc-btn el-button--primary is-circle" data-v-1ba756dd><!----><!----><span><i class="iconfont icon-service-directory" data-v-1ba756dd></i></span></button> <button type="button" class="el-button gotop-btn el-button--primary is-circle" data-v-1ba756dd><!----><!----><span><i class="el-icon-arrow-up" data-v-1ba756dd></i></span></button></span></div></main></section> <button type="button" class="el-button gotop-btn el-button--primary is-circle" style="display:none;" data-v-db63bc4e data-v-3431ceb9><!----><!----><span><i class="el-icon-arrow-up" data-v-db63bc4e></i></span></button></section> <footer class="el-footer container-footer" style="height:60px;" data-v-6660fccd data-v-3431ceb9><div class="footer-warp el-row is-justify-center is-align-center el-row--flex footerMargin" data-v-6660fccd><div class="footer-top el-col el-col-24" data-v-6660fccd><p class="ellipsis" data-v-6660fccd><span data-v-6660fccd>
          博客内容遵循
          <a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" data-v-6660fccd>知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议</a></span></p></div> <div class="footer-bottom el-col el-col-24" data-v-6660fccd><p class="ellipsis" data-v-6660fccd><span data-v-6660fccd><span data-v-6660fccd>
            zhhlwd的个人博客 © 2018-08 ~ 2019-06
          </span></span> <span data-v-6660fccd>
          Power by
          <a href="https://vuepress.vuejs.org/zh/" target="_blank" data-v-6660fccd>VuePress</a> Theme
          <a href="https://github.com/zhhlwd/vuepress-theme-indigo-material" target="_blank" data-v-6660fccd>indigo material</a></span></p></div></div></footer> <div class="overlay" data-v-3431ceb9></div></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.39e00e98.js" defer></script><script src="/assets/js/1.c0224360.js" defer></script><script src="/assets/js/15.f0ca96b2.js" defer></script><script src="/assets/js/5.b07737de.js" defer></script><script src="/assets/js/7.9893d61a.js" defer></script><script src="/assets/js/10.9c509957.js" defer></script><script src="/assets/js/6.57699fa9.js" defer></script><script src="/assets/js/59.5f3be402.js" defer></script><script src="/assets/js/14.0e97f0ce.js" defer></script><script src="/assets/js/16.9fb85302.js" defer></script>
  </body>
</html>
