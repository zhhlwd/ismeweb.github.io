<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, minimal-ui"
    />
    <title>【读书笔记】《JavaScript权威指南》第8章函数 | zhhlwd</title>
    <meta name="description" content="三人行，必有我师焉，择其善者而从之，其不善者而改之。" />
    <meta property="og:type" content="website" />
    <meta property="og:title" content="【读书笔记】《JavaScript权威指南》第8章函数 | zhhlwd" />
    <meta property="og:site_name" content="【读书笔记】《JavaScript权威指南》第8章函数 | zhhlwd" />
    <meta property="og:locale" content="zh-CN" />
    <meta name="twitter:card" content="summary" />
    <meta name="twitter:title" content="【读书笔记】《JavaScript权威指南》第8章函数 | zhhlwd" />
    <link rel="shortcut icon" href="/favicon.ico">
    
    <link rel="preload" href="/assets/css/0.styles.068dd2cd.css" as="style"><link rel="preload" href="/assets/js/app.39e00e98.js" as="script"><link rel="preload" href="/assets/js/1.c0224360.js" as="script"><link rel="preload" href="/assets/js/15.f0ca96b2.js" as="script"><link rel="preload" href="/assets/js/5.b07737de.js" as="script"><link rel="preload" href="/assets/js/7.9893d61a.js" as="script"><link rel="preload" href="/assets/js/10.9c509957.js" as="script"><link rel="preload" href="/assets/js/6.57699fa9.js" as="script"><link rel="preload" href="/assets/js/61.acc49c38.js" as="script"><link rel="preload" href="/assets/js/14.0e97f0ce.js" as="script"><link rel="preload" href="/assets/js/16.9fb85302.js" as="script"><link rel="prefetch" href="/assets/js/11.4d3e3171.js"><link rel="prefetch" href="/assets/js/12.00842133.js"><link rel="prefetch" href="/assets/js/13.3ac04011.js"><link rel="prefetch" href="/assets/js/17.427877de.js"><link rel="prefetch" href="/assets/js/18.9fb398fc.js"><link rel="prefetch" href="/assets/js/19.feb0126e.js"><link rel="prefetch" href="/assets/js/20.13a93009.js"><link rel="prefetch" href="/assets/js/21.58f50a10.js"><link rel="prefetch" href="/assets/js/22.c63d4380.js"><link rel="prefetch" href="/assets/js/23.18289c78.js"><link rel="prefetch" href="/assets/js/24.c1a9de78.js"><link rel="prefetch" href="/assets/js/25.0bd81385.js"><link rel="prefetch" href="/assets/js/26.16680b9b.js"><link rel="prefetch" href="/assets/js/27.6cffb597.js"><link rel="prefetch" href="/assets/js/28.6322d617.js"><link rel="prefetch" href="/assets/js/29.988d048b.js"><link rel="prefetch" href="/assets/js/30.86340671.js"><link rel="prefetch" href="/assets/js/31.3920b019.js"><link rel="prefetch" href="/assets/js/32.043d59c3.js"><link rel="prefetch" href="/assets/js/33.179b9e0e.js"><link rel="prefetch" href="/assets/js/34.d62c08ea.js"><link rel="prefetch" href="/assets/js/35.5d1effb7.js"><link rel="prefetch" href="/assets/js/36.8f937390.js"><link rel="prefetch" href="/assets/js/37.d4c78315.js"><link rel="prefetch" href="/assets/js/38.6d9e9af7.js"><link rel="prefetch" href="/assets/js/39.c0d6b845.js"><link rel="prefetch" href="/assets/js/4.852cc3fd.js"><link rel="prefetch" href="/assets/js/40.0dd1da3d.js"><link rel="prefetch" href="/assets/js/41.a53d9e1e.js"><link rel="prefetch" href="/assets/js/42.ef67bdbc.js"><link rel="prefetch" href="/assets/js/43.8015aa78.js"><link rel="prefetch" href="/assets/js/44.3d19ff22.js"><link rel="prefetch" href="/assets/js/45.c4ec1046.js"><link rel="prefetch" href="/assets/js/46.b66c6c6a.js"><link rel="prefetch" href="/assets/js/47.792fbb9b.js"><link rel="prefetch" href="/assets/js/48.fff9e461.js"><link rel="prefetch" href="/assets/js/49.927540c7.js"><link rel="prefetch" href="/assets/js/50.7328b358.js"><link rel="prefetch" href="/assets/js/51.edf5a6f6.js"><link rel="prefetch" href="/assets/js/52.554531c8.js"><link rel="prefetch" href="/assets/js/53.cff155eb.js"><link rel="prefetch" href="/assets/js/54.79017acb.js"><link rel="prefetch" href="/assets/js/55.3f832b4e.js"><link rel="prefetch" href="/assets/js/56.fc46ef96.js"><link rel="prefetch" href="/assets/js/57.01d4bca6.js"><link rel="prefetch" href="/assets/js/58.af6eeeff.js"><link rel="prefetch" href="/assets/js/59.5f3be402.js"><link rel="prefetch" href="/assets/js/60.0babdfb8.js"><link rel="prefetch" href="/assets/js/62.3bbe5a99.js"><link rel="prefetch" href="/assets/js/63.4c1ad2b7.js"><link rel="prefetch" href="/assets/js/64.660d1af7.js"><link rel="prefetch" href="/assets/js/65.d8475e70.js"><link rel="prefetch" href="/assets/js/66.fe8f81dc.js"><link rel="prefetch" href="/assets/js/67.bc970a69.js"><link rel="prefetch" href="/assets/js/68.5b401715.js"><link rel="prefetch" href="/assets/js/69.60a017c7.js"><link rel="prefetch" href="/assets/js/70.d0fe42fc.js"><link rel="prefetch" href="/assets/js/71.34114315.js"><link rel="prefetch" href="/assets/js/72.962129e8.js"><link rel="prefetch" href="/assets/js/73.a2267a94.js"><link rel="prefetch" href="/assets/js/74.2401111b.js"><link rel="prefetch" href="/assets/js/75.361c8ec8.js"><link rel="prefetch" href="/assets/js/76.323e94c6.js"><link rel="prefetch" href="/assets/js/77.b3c2a687.js"><link rel="prefetch" href="/assets/js/8.001cad53.js"><link rel="prefetch" href="/assets/js/9.d5c24b06.js"><link rel="prefetch" href="/assets/js/search.de4016ee.js">
    <link rel="stylesheet" href="/assets/css/0.styles.068dd2cd.css">
  </head>
  <body>
    <div id="loader-wrapper" style="display: none;opacity:0">
      <div id="loader"></div>
      <div class="loader-section section-left"></div>
      <div class="loader-section section-right"></div>
    </div>
    <div id="app" data-server-rendered="true"><div style="height:100%;" data-v-3431ceb9><section class="el-container main-container" data-v-3431ceb9><aside class="el-aside menu" style="width:auto;" data-v-7a66351a data-v-3431ceb9><ul role="menubar" class="menu-wrap el-menu" style="background-color:;" data-v-7a66351a><li data-v-7a66351a><div class="brand-wrap" style="background-image:url(/brand.jpg);" data-v-7a66351a><div class="brand" data-v-7a66351a><a href="/" class="avatar waves-effect waves-circle waves-light router-link-active" data-v-7a66351a><img src="/avatar.jpg" data-v-7a66351a></a> <hgroup class="introduce" data-v-7a66351a><div class="nickname" data-v-7a66351a>zhhlwd</div> <a title="zhhlwd@qq.com" class="mail" data-v-7a66351a>zhhlwd@qq.com</a></hgroup></div></div></li> <li role="menuitem" tabindex="-1" class="el-menu-item" style="padding-left:20px;color:;background-color:;" data-v-7a66351a><i class="iconfont icon-home" data-v-7a66351a></i> <span class="item-title" data-v-7a66351a>主页</span></li> <li role="menuitem" tabindex="-1" class="el-menu-item" style="padding-left:20px;color:;background-color:;" data-v-7a66351a><i class="iconfont icon-biaoqian" data-v-7a66351a></i> <span class="item-title" data-v-7a66351a>标签分类</span></li> <li role="menuitem" tabindex="-1" class="el-menu-item" style="padding-left:20px;color:;background-color:;" data-v-7a66351a><i class="iconfont icon-wenzhang" data-v-7a66351a></i> <span class="item-title" data-v-7a66351a>时间归档</span></li> <li role="menuitem" tabindex="-1" class="el-menu-item" style="padding-left:20px;color:;background-color:;" data-v-7a66351a><i class="iconfont icon-github" data-v-7a66351a></i> <span class="item-title" data-v-7a66351a>Github</span></li> <li role="menuitem" tabindex="-1" class="el-menu-item" style="padding-left:20px;color:;background-color:;" data-v-7a66351a><i class="iconfont icon-aboutme" data-v-7a66351a></i> <span class="item-title" data-v-7a66351a>自我介绍</span></li></ul></aside> <section class="el-container container-warp" data-v-3431ceb9><header id="topHeader" class="el-header top-header" style="height:60px;padding-left:260px;" data-v-15c2c99c data-v-3431ceb9><div class="header-warp el-row is-align-middle el-row--flex" data-v-15c2c99c><div class="el-col el-col-12 el-col-xs-7" data-v-15c2c99c><div class="el-row is-align-middle el-row--flex" data-v-15c2c99c><div class="el-col el-col-2" data-v-15c2c99c><button type="button" class="el-button el-button--primary is-circle" data-v-15c2c99c><!----><!----><span><i class="iconfont icon-caidan" data-v-15c2c99c></i></span></button></div></div></div> <div class="el-col el-col-20 el-col-xs-24" data-v-15c2c99c><div class="grid-content bg-purple-light" data-v-15c2c99c><div class="el-row is-justify-end is-align-middle el-row--flex" data-v-15c2c99c><div class="el-col el-col-13 el-col-xs-24 el-col-sm-21 el-col-md-17 el-col-lg-13" data-v-15c2c99c><div aria-haspopup="listbox" role="combobox" aria-owns="el-autocomplete-8826" class="el-autocomplete search-input" data-v-15c2c99c><div class="el-input el-input--small el-input--suffix"><!----><input type="text" autocomplete="off" valueKey="value" popperClass="search-popper" placeholder="搜搜看" fetchSuggestions="function () { [native code] }" debounce="300" placement="bottom-start" popperAppendToBody="true" value="" class="el-input__inner"><!----><span class="el-input__suffix"><span class="el-input__suffix-inner"><i class="el-input__icon el-icon-search search-ico" data-v-15c2c99c></i><!----></span><!----></span><!----></div><div role="region" class="el-autocomplete-suggestion el-popper search-popper" style="width:;display:none;"><div class="el-scrollbar"><div class="el-autocomplete-suggestion__wrap el-scrollbar__wrap el-scrollbar__wrap--hidden-default"><ul class="el-scrollbar__view el-autocomplete-suggestion__list"></ul></div><div class="el-scrollbar__bar is-horizontal"><div class="el-scrollbar__thumb" style="width:0;transform:translateX(0%);ms-transform:translateX(0%);webkit-transform:translateX(0%);"></div></div><div class="el-scrollbar__bar is-vertical"><div class="el-scrollbar__thumb" style="height:0;transform:translateY(0%);ms-transform:translateY(0%);webkit-transform:translateY(0%);"></div></div></div></div></div></div></div></div></div></div></header> <main class="el-main my-main" style="margin-left:240px;" data-v-c4863568 data-v-3431ceb9><div class="content-header index-header" data-v-61dd99b6 data-v-c4863568><div class="container fade-scale in" data-v-61dd99b6><h1 id="conentHeader" class="title" data-v-61dd99b6>【读书笔记】《JavaScript权威指南》第8章函数</h1> <h5 class="subtitle" data-v-61dd99b6>最后更新时间：2019-02-23 00:09:45</h5></div></div> <div data-v-aa2eb952 data-v-c4863568 data-v-c4863568><div class="post-content el-row is-justify-center el-row--flex" data-v-aa2eb952><div id="post-card" class="post-card post-sign el-col el-col-16 el-col-xs-24 el-col-sm-23 el-col-md-23 el-col-lg-16" data-v-aa2eb952><div class="content__default" data-v-aa2eb952><h2 id="函数定义（掌握）"><a href="#函数定义（掌握）" aria-hidden="true" class="header-anchor">#</a> 函数定义（掌握）</h2> <p>  函数使用 function 关键字来定义，它可以用在函数定义表达式或者函数声明语句里。在两种形式中，函数定义都从 function 关键字开始，其后跟随这些组成部分：</p> <ul><li>函数名称标识符。函数名称是函数声明语句必需的部分。它的用途就像变量的名字，新定义的函数对象会赋值给这个变量。对函数定义表达式来说，这个名字是可选的：如果存在，该名字只存在于函数体中，并指代该函数对象本身。</li> <li>一对圆括号，其中包含由 0 个或者多个用逗号隔开的标识符组成的列表。这些标识符是函数的参数名称，它们就像函数体中的局部变量一样。</li> <li>一对花括号，其中包含 0 条或多条 JavaScript 语句。这些语句构成了函数体：一旦调用函数，就会执行这些语句。</li></ul> <p>  函数声明语句“被提前”到外部脚本或外部函数作用域的顶部，所以以这种方式声明的函数，可以被在它定义之前出现的代码所调用。<br>
  不过，以表达式定义的函数就另当别论了，为了调用一个函数，必须要能引用它，而要使用一个以表达式方式定义的函数之前，必须把它赋值给一个变量。变量的声明提前了，但给变量赋值是不会提前的，所以，以表达式方式定义的函数在定义之前无法调用。</p> <h2 id="函数调用（掌握）"><a href="#函数调用（掌握）" aria-hidden="true" class="header-anchor">#</a> 函数调用（掌握）</h2> <p>  构成函数主体的 JavaScript 代码在定义之时并不会执行，只有调用该函数时，它们才会执行。有 4 种方式来调用 JavaScript 函数：</p> <ul><li>作为函数</li> <li>作为方法</li> <li>作为构造函数</li> <li>通过它们的 cal1（）和 apply（）方法间接调用</li></ul> <h3 id="函数调用"><a href="#函数调用" aria-hidden="true" class="header-anchor">#</a> 函数调用</h3> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token function">printprops</span><span class="token punctuation">(</span><span class="token punctuation">{</span> x<span class="token punctuation">:</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> total <span class="token operator">=</span> <span class="token function">distance</span><span class="token punctuation">(</span>o<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">distance</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> probability <span class="token operator">=</span> <span class="token function">factorial</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token function">factorial</span><span class="token punctuation">(</span><span class="token number">13</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>  对于普通的函数调用，函数的返回值成为调用表达式的值。如果该函数返回是因为解释器到达结尾，返回值就是 undefined。如果函数返回是因为解释器执行到一条 return 语句，返回值就是 return 之后的表达式的值，如果 return 语句没有值，则返回 undefined。<br>
  根据 ECMAScript3 和非严格的 ECMAScript5 对函数调用的规定，调用上下文（this 的值）是全局对象。然而，在严格模式下，调用上下文则是 undefined。<br>
  以函数形式调用的函数通常不使用 this 关键字。不过，“this”可以用来判断当前是否是严格模式。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token operator">/</span>定义并调用一个函数来确定当前脚本运行时是否为严格模式
<span class="token keyword">var</span> strict<span class="token operator">=</span>（<span class="token keyword">function</span>（）<span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token operator">!</span><span class="token keyword">this</span>；<span class="token punctuation">}</span>（））；
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h3 id="方法调用"><a href="#方法调用" aria-hidden="true" class="header-anchor">#</a> 方法调用</h3> <p>  对方法调用的参数和返回值的处理，和上面所描述的普通函数调用完全一致。但是，方法调用和函数调用有一个重要的区别，即：调用上下文。下面是一个具体的例子：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> calculator<span class="token operator">=</span><span class="token punctuation">{</span><span class="token comment">//对象直接量</span>
operand1：<span class="token number">1</span>，
operand2：<span class="token number">1</span>，
<span class="token function-variable function">add</span><span class="token punctuation">:</span><span class="token keyword">function</span>（）<span class="token punctuation">{</span>
<span class="token comment">//注意this关键字的用法，this指代当前对象</span>
<span class="token keyword">this</span><span class="token punctuation">.</span>result<span class="token operator">=</span><span class="token keyword">this</span><span class="token punctuation">.</span>operand1<span class="token operator">+</span><span class="token keyword">this</span><span class="token punctuation">.</span>operandz；
<span class="token punctuation">}</span>；
calculator<span class="token punctuation">.</span>add（）；<span class="token comment">//这个方法调用计算1+1的结果</span>
calculator<span class="token punctuation">.</span>result <span class="token comment">//=&gt;2</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>  需要注意的是，this 是一个关键字，不是变量，也不是属性名。JavaScript 的语法不允许给 this 赋值。<br>
  和变量不同，关键字 this 没有作用域的限制，嵌套的函数不会从调用它的函数中继承 this。如果嵌套函数作为方法调用，其 this 的值指向调用它的对象。如果嵌套函数作为函数调用，其 this 值不是全局对象（非严格模式下）就是 undefined（严格模式下）。很多人误以为调用嵌套函数时 this 会指向调用外层函数的上下文。如果你想访问这个外部函数的 this 值，需要将 this 的值保存在一个变量里，这个变量和内部函数都同在一个作用域内。通常使用变量 self 来保存 this。</p> <h3 id="构造函数调用"><a href="#构造函数调用" aria-hidden="true" class="header-anchor">#</a> 构造函数调用</h3> <p>  如果函数或者方法调用之前带有关键宇 new，构造函数调用和普通的函数调用以及方法调用在实参处理、调用上下文和返回值方面都有不同。<br>
  构造函数调用创建一个新的空对象，这个对象继承自构造函数的 prototype 属性。构造函数试图初始化这个新创建的对象，并将这个对象用做其调用上下文，因此构造函数可以使用 this 关键字来引用这个新创建的对象。注意，尽管构造函数看起来像一个方法调用，它依然会使用这个新对象作为调用上下文。也就是说，在表达式 new o.m（）中，调用上下文并不是 o。<br>
  构造函数通常不使用 return 关键宇，它们通常初始化新对象，当构造函数的函数体执行完毕时，它会显式返回。在这种情况下，构造函数调用表达式的计算结果就是这个新对象的值。然而如果构造函数显式地使用 return 语句返回一个对象，那么调用表达式的值就是这个对象。如果构造函数使用 return 语句但没有指定返回值，或者返回一个原始值，那么这时将忽略返回值，同时使用这个新对象作为调用结果。</p> <h3 id="间接调用"><a href="#间接调用" aria-hidden="true" class="header-anchor">#</a> 间接调用</h3> <p>  JavaScript 中的函数也是对象，和其他 JavaScript 对象没什么两样，函数对象也可以包含方法。其中的两个方法 ca11（）和 apply（）可以用来间接地调用函数。两个方法都允许显式指定调用所需的 this 值，也就是说，任何函数可以作为任何对象的方法来调用，哪怕这个函数不是那个对象的方法。两个方法都可以指定调用的实参。ca11（）方法使用它自有的实参列表作为函数的实参，apply（）方法则要求以数组的形式传入参数。</p> <h2 id="函数的实参和形参（掌握）"><a href="#函数的实参和形参（掌握）" aria-hidden="true" class="header-anchor">#</a> 函数的实参和形参（掌握）</h2> <h3 id="可选形参"><a href="#可选形参" aria-hidden="true" class="header-anchor">#</a> 可选形参</h3> <p>  当调用函数的时候传入的实参比函数声明时指定的形参个数要少，剩下的形参都将设置为 undefined 值。因此在调用函数时形参是否可选以及是否可以省略应当保持较好的适应性。为了做到这一点，应当给省略的参数赋一个合理的默认值。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>a <span class="token operator">=</span> a <span class="token operator">||</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>  需要注意的是，当用这种可选实参来实现函数时，需要将可选实参放在实参列表的最后。那些调用你的函数的程序员是没办法省略第一个实参并传入第二个实参的，它必须将 undefined 作为第一个实参显式传入。同样注意在函数定义中使用注释/*optional*/来强调形参是可选的。</p> <h3 id="可变长的实参列表：实参对象"><a href="#可变长的实参列表：实参对象" aria-hidden="true" class="header-anchor">#</a> 可变长的实参列表：实参对象</h3> <p>  当调用函数的时候传入的实参个数超过函数定义时的形参个数时，没有办法直接获得未命名值的引用。参数对象解决了这个问题。在函数体内，标识符 arguments 是指向实参对象的引用，实参对象是一个类数组对象，这样可以通过数字下标就能访问传入函数的实参值，而不用非要通过名字来得到实参。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> max（<span class="token comment">/*...*/</span>）<span class="token punctuation">{</span>
    <span class="token keyword">var</span> max<span class="token operator">=</span>Number<span class="token punctuation">.</span><span class="token constant">NEGATIVE_INFINITY</span>；
<span class="token comment">//遍历实参，查找并记住最天值</span>
    <span class="token keyword">for</span>（<span class="token keyword">var</span> i<span class="token operator">=</span><span class="token number">0</span>；i<span class="token operator">&lt;</span> arguments<span class="token punctuation">.</span>length；i<span class="token operator">++</span>）
        <span class="token keyword">if</span>（arguments<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&gt;</span>max）max <span class="token operator">=</span>arguments<span class="token punctuation">[</span>i<span class="token punctuation">]</span>；
        <span class="token comment">//返回最大值</span>
        <span class="token keyword">return</span> max；
<span class="token punctuation">}</span>
<span class="token keyword">var</span> largest <span class="token operator">=</span>max（<span class="token number">1</span>，<span class="token number">10</span>，<span class="token number">100</span>，<span class="token number">2</span>，<span class="token number">3</span>，<span class="token number">1000</span>，<span class="token number">4</span>，<span class="token number">5</span>，<span class="token number">10000</span>，<span class="token number">6</span>）；<span class="token comment">//=&gt;10000</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>  通过实参名字来修改实参值的话，通过 arguments[]数组也可以获取到更改后的值,在 ECMAScript 5 中移除了实参对象的这个特殊特性。在严格模式下还有一点（和非严格模式下相比的）不同，在非严格模式中，函数里的 arguments 仅仅是一个标识符，在严格模式中，它变成了一个保留字。严格模式中的函数无法使用 arguments 作为形参名或局部变量名，也不能给 arguments 赋值。</p> <h3 id="callee-和-caller-属性"><a href="#callee-和-caller-属性" aria-hidden="true" class="header-anchor">#</a> callee 和 caller 属性</h3> <p>  除了数组元素，实参对象还定义了 callee 和 caller 属性。在 ECMAScript 5 严格模式中，对这两个属性的读写操作都会产生一个类型错误。而在非严格模式下，ECMAScript 标准规范规定 callee 属性指代当前正在执行的函数。caller 是非标准的，但大多数浏览器都实现了这个属性，它指代调用当前正在执行的函数的函数。通过 caller 属性可以访问调用栈。callee 属性在某些时候会非常有用，比如在匿名函数中通过 callee 来递归地调用自身。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">factorial</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> x <span class="token operator">*</span> arguments<span class="token punctuation">.</span><span class="token function">callee</span><span class="token punctuation">(</span>x <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h3 id="将对象属性用做实参"><a href="#将对象属性用做实参" aria-hidden="true" class="header-anchor">#</a> 将对象属性用做实参</h3> <p>  当一个函数包含超过三个形参时，对于程序员来说，要记住调用函数中实参的正确顺序实在让人头疼。最好通过名/值对的形式来传入参数，这样参数的顺序就无关紧要了。定义函数的时候，传入的实参都写入一个单独的对象之中，在调用的时候传入一个对象，对象中的名/值对是真正需要的实参数据。</p> <h2 id="作为值的函数"><a href="#作为值的函数" aria-hidden="true" class="header-anchor">#</a> 作为值的函数</h2> <p>  在 JavaScript 中，函数不仅是一种语法，也是值，也就是说，可以将函数赋值给变量，存储在对象的属性或数组的元素中，作为参数传人另外一个函数等。</p> <h3 id="自定义函数属性"><a href="#自定义函数属性" aria-hidden="true" class="header-anchor">#</a> 自定义函数属性</h3> <p>  JavaScript 中的函数并不是原始值，而是一种特殊的对象，也就是说，函数可以拥有属性。当函数需要一个“静态”变量来在调用时保持某个值不变，最方便的方式就是给函数定义属性，而不是定义全局变量，显然定义全局变量会让命名空间变得更加杂乱无章。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">//计算阶乘，并将结果缓存至函数的属性中</span>
<span class="token keyword">function</span> factorial（n）<span class="token punctuation">{</span>
    <span class="token keyword">if</span>（isFinite（n）<span class="token number">8</span><span class="token operator">&amp;</span> n<span class="token operator">&gt;</span>o <span class="token number">8</span><span class="token operator">&amp;</span> n<span class="token operator">==</span>Math<span class="token punctuation">.</span>round（n））<span class="token punctuation">{</span><span class="token comment">//有限的正整数</span>
        <span class="token keyword">if</span>（！（n <span class="token keyword">in</span> factorial））<span class="token comment">//如果没有缓存结果</span>
            factorial<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token operator">=</span>n<span class="token operator">*</span> factorial（n<span class="token operator">-</span><span class="token number">1</span>）；<span class="token comment">//计算结果并缓存之</span>
            <span class="token keyword">return</span> factorial<span class="token punctuation">[</span>n<span class="token punctuation">]</span>；<span class="token comment">//返回缓存结果</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">else</span> <span class="token keyword">return</span> <span class="token number">NaN</span>；<span class="token comment">//如果输入有误</span>
<span class="token punctuation">}</span>
factorial<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span>；<span class="token comment">//初始化缓存以保存这种基本情况</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><h2 id="作为命名空间的函数-掌握"><a href="#作为命名空间的函数-掌握" aria-hidden="true" class="header-anchor">#</a> 作为命名空间的函数(掌握)</h2> <p>  比如，假设你写了一段 JavaScript 模块代码，假定这段代码定义了一个用以存储中间计算结果的变量。这样问题就来了，当模块代码放到不同的程序中运行时，你无法得知这个变量是否已经创建了，如果已经存在这个变量，那么将会和代码发生冲突。解决办法当然是将代码放入一个函数内，然后调用这个函数。这样全局变量就变成了函数内的局部变量。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>（<span class="token keyword">function</span>（）<span class="token punctuation">{</span><span class="token comment">//mymodule（）匿名的函数表达式</span>
<span class="token comment">//模块代码</span>
    <span class="token punctuation">}</span>（））；<span class="token comment">//结束函数定义并立即调用它</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h2 id="闭包（掌握）"><a href="#闭包（掌握）" aria-hidden="true" class="header-anchor">#</a> 闭包（掌握）</h2> <p>  和其他大多数现代编程语言一样，JavaScript 也采用词法作用域（lexical scoping），也就是说，函数的执行依赖于变量作用域，这个作用域是在函数定义时决定的，而不是函数调用时决定的。<br>
  为了实现这种词法作用域，JavaScript 函数对象的内部状态不仅包含函数的代码逻辑，还必须引用当前的作用域链。函数对象可以通过作用域链相互关联起来，函数体内部的变量都可以保存在函数作用域内，这种特性在计算机科学文献中称为“闭包”。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> scope<span class="token operator">=</span><span class="token string">&quot;global scope&quot;</span>；<span class="token comment">//全局变量</span>
<span class="token keyword">function</span> checkscope（）<span class="token punctuation">{</span>
    <span class="token keyword">var</span> scope<span class="token operator">=</span><span class="token string">&quot;local scope&quot;</span>；<span class="token comment">//局部变量</span>
    <span class="token keyword">function</span> f（）<span class="token punctuation">{</span> <span class="token keyword">return</span> scope；<span class="token punctuation">}</span><span class="token comment">//在作用域中返回这个值</span>
    <span class="token keyword">return</span> f（）；
<span class="token punctuation">}</span>
checkscope（）<span class="token comment">//=&gt;&quot;local scope&quot;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>回想一下词法作用域的基本规则：JavaScript 函数的执行用到了作用域链，这个作用域链是函数定义的时候创建的。嵌套的函数 f（）定义在这个作用域链里，其中的变量 scope 一定是局部变量，不管在何时何地执行函数 f（），这种绑定在执行 f（）时依然有效。因此最后一行代码返回“local scope”，而不是“global scope”。</p> <h3 id="实现闭包"><a href="#实现闭包" aria-hidden="true" class="header-anchor">#</a> 实现闭包</h3> <p>  我们将作用域链描述为一个对象列表，不是绑定的栈。每次调用 JavaScript 函数的时候，都会为之创建一个新的对象用来保存局部变量，把这个对象添加至作用域链中。<br>
  当函数返回的时候，就从作用域链中将这个绑定变量的对象删除。如果不存在嵌套的函数，也没有其他引用指向这个绑定对象，它就会被当做垃圾回收掉。<br>
  如果定义了嵌套的函数，每个嵌套的函数都各自对应一个作用域链，并且这个作用域链指向一个变量绑定对象。但如果这些嵌套的函数对象在外部函数中保存下来，那么它们也会和所指向的变量绑定对象一样当做垃圾回收。<br>
  但是如果这个函数定义了嵌套的函数，并将它作为返回值返回或者存储在某处的属性里，这时就会有一个外部引用指向这个嵌套的函数。它就不会被当做垃圾回收，并且它所指向的变量绑定对象也不会被当做垃圾回收。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> uniqueInteger<span class="token operator">=</span>（<span class="token keyword">function</span>（）<span class="token punctuation">{</span><span class="token comment">//定义函数并立即调用</span>
    <span class="token keyword">var</span> counter<span class="token operator">=</span><span class="token number">0</span>；<span class="token comment">//函数的私有状态</span>
    <span class="token keyword">return</span> <span class="token keyword">function</span>（）<span class="token punctuation">{</span> <span class="token keyword">return</span> counter<span class="token operator">++</span>；<span class="token punctuation">}</span>；
<span class="token punctuation">}</span>（））；
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> counter（）<span class="token punctuation">{</span>
    <span class="token keyword">var</span> n<span class="token operator">=</span><span class="token number">0</span>；
    <span class="token keyword">return</span><span class="token punctuation">{</span>
        <span class="token function-variable function">count</span><span class="token punctuation">:</span><span class="token keyword">function</span>（）<span class="token punctuation">{</span><span class="token keyword">return</span> n<span class="token operator">++</span>；<span class="token punctuation">}</span>，
        <span class="token function-variable function">reset</span><span class="token punctuation">:</span><span class="token keyword">function</span>（）<span class="token punctuation">{</span>n<span class="token operator">=</span>o；<span class="token punctuation">}</span>
    <span class="token punctuation">}</span>；
<span class="token punctuation">}</span>
<span class="token keyword">var</span> c<span class="token operator">=</span><span class="token function">counter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>d<span class="token operator">=</span><span class="token function">counter</span><span class="token punctuation">(</span><span class="token punctuation">)</span>；<span class="token comment">//创建两个计数器</span>
d<span class="token punctuation">.</span>count（）<span class="token comment">//l=&gt;0：它们互不干扰</span>
c<span class="token punctuation">.</span>reset（）<span class="token comment">//reset（）和count（）方法共享状态</span>
<span class="token constant">C</span><span class="token punctuation">.</span>count（）<span class="token comment">//=&gt;0：因为我们重置了c</span>
d<span class="token punctuation">.</span>count（）<span class="token comment">//=&gt;1：而没有重置d</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>  每次调用 counter（）都会创建一个新的作用域链和一个新的私有变量。因此，如果调用 counter（）两次，则会得到两个计数器对象，而且彼此包含不同的私有变量，调用其中一个计数器对象的 count（）或 reset（）不会影响到另外一个对象。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> counter（n）<span class="token punctuation">{</span><span class="token comment">//函数参数n是一个私有变量</span>
    <span class="token keyword">return</span><span class="token punctuation">{</span>
        <span class="token comment">//属性getter方法返回并给私有计数器var递增1</span>
        <span class="token keyword">get</span> count（）<span class="token punctuation">{</span><span class="token keyword">return</span> n<span class="token operator">++</span>；<span class="token punctuation">}</span>，
        <span class="token comment">//属性setter不允许n递减</span>
        <span class="token keyword">set</span> count（m）<span class="token punctuation">{</span>
        <span class="token keyword">if</span>（m<span class="token operator">&gt;=</span>n）n<span class="token operator">=</span>m；
        <span class="token keyword">else</span> <span class="token keyword">throw</span> Error（<span class="token string">&quot;count can only be set to a larger value&quot;</span>）；
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>；
<span class="token punctuation">}</span>
<span class="token keyword">var</span> c<span class="token operator">=</span>counter（<span class="token number">1000</span>）；
c<span class="token punctuation">.</span>count<span class="token comment">//=&gt;1000</span>
c<span class="token punctuation">.</span>count<span class="token comment">//=&gt;1001</span>
c<span class="token punctuation">.</span>count<span class="token operator">=</span><span class="token number">2000</span>
c<span class="token punctuation">.</span>count<span class="token comment">//=&gt;2000</span>
c<span class="token punctuation">.</span>count<span class="token operator">=</span><span class="token number">2000</span><span class="token comment">//=&gt;Error！</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p>  需要注意的是，这个版本的 counter（）函数并未声明局部变量，而只是使用参数 n 来保存私有状态，属性存取器方法可以访问 n。这样的话，调用 counter（）的函数就可以指定私有变量的初始值了。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>//这个函数返回一个总是返回v的函数
function constfunc（v）{return function（）{return v；}；}
//创建一个数组用来存储常数函数
var funcs=[]；
for（var i=o；i&lt;10；i++）funcs[i]=constfunc（i）；
//在第5个位置的元素所表示的函数返回值为5
funcs[5]（）//=&gt;5
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>  这段代码利用循环创建了很多个闭包，当写类似这种代码的时候往往会犯一个错误：那就是试图将循环代码移入定义这个闭包的函数之内，看一下这段代码：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>//返回一个函数组成的数组，它们的返回值是0～9
function constfuncs（）{
    var funcs=[]；
    for（vari=0；i&lt;10；i++）
        funcs[i]=function（）{ return i；}；
    return funcs；
}
var funcs=constfuncs（）；
funcs[5]（）//返回值是10
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>  书写闭包的时候还需注意一件事情，this 是 JavaScript 的关键字，而不是变量。正如之前讨论的，每个函数调用都包含一个 this 值，如果闭包在外部函数里是无法访问 this 的，除非外部函数将 this 转存为一个变量：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> self<span class="token operator">=</span><span class="token keyword">this</span>；<span class="token comment">//将this保存至一个变量中，以便嵌套的函数能够访问它</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="函数属性、方法和构造函数（掌握）"><a href="#函数属性、方法和构造函数（掌握）" aria-hidden="true" class="header-anchor">#</a> 函数属性、方法和构造函数（掌握）</h2> <h3 id="length-属性"><a href="#length-属性" aria-hidden="true" class="header-anchor">#</a> length 属性</h3> <p>  在函数体里，arguments.length 表示传入函数的实参的个数。而函数本身的 1ength 属性则有着不同含义。函数的 1ength 属性是只读属性，它代表函数实参的数量，这里的参数指的是“形参”而非“实参”，也就是在函数定义时给出的实参个数，通常也是在函数调用时期望传入函数的实参个数。</p> <h3 id="prototype-属性"><a href="#prototype-属性" aria-hidden="true" class="header-anchor">#</a> prototype 属性</h3> <p>  每一个函数都包含一个 prototype 属性，这个属性是指向一个对象的引用，这个对象称做“原型对象”（prototype object）。每一个函数都包含不同的原型对象。当将函数用做构造函数的时候，新创建的对象会从原型对象上继承属性。</p> <h3 id="call（）方法和-apply（）方法"><a href="#call（）方法和-apply（）方法" aria-hidden="true" class="header-anchor">#</a> call（）方法和 apply（）方法</h3> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">classof</span><span class="token punctuation">(</span><span class="token parameter">o</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token string">'Null'</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>o <span class="token operator">=</span> a <span class="token operator">=</span> <span class="token keyword">undefined</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token string">'Undefined'</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">tostring</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>  在 ECMAScript5 的严格模式中，ca11（）和 apply（）的第一个实参都会变为 this 的值，哪怕传入的实参是原始值甚至是 null 或 undefined。在 ECMAScript3 和非严格模式中，传入的 null 和 undefined 都会被全局对象代替，而其他原始值则会被相应的包装对象（wrapper object）所替代。apply（）方法和 cal1（）类似，但传入实参的形式和 cal1（）有所不同，它的实参都放入一个数组当中：需要注意的是，传入 apply（）的参数数组可以是类数组对象也可以是真实数组。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token function">f</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>o<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h3 id="bind（）方法"><a href="#bind（）方法" aria-hidden="true" class="header-anchor">#</a> bind（）方法</h3> <p>  bind（）是在 ECMAScript5 中新增的方法，但在 ECMAScript3 中可以轻易模拟 bind（）。从名字就可以看出，这个方法的主要作用就是将函数绑定至某个对象。当在函数 f（）上调用 bind（）方法并传入一个对象 0 作为参数，这个方法将返回一个新的函数。（以函数调用的方式）调用新的函数将会把原始的函数 f（）当做。的方法来调用。传入新函数的任何实参都将传入原始函数，比如：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> f（y）<span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>x<span class="token operator">+</span>y；<span class="token punctuation">}</span><span class="token comment">//这个是待绑定的函数</span>
<span class="token keyword">var</span> o<span class="token operator">=</span><span class="token punctuation">{</span>x：<span class="token number">1</span><span class="token punctuation">}</span>；<span class="token operator">/</span>将要绑定的对象
<span class="token keyword">var</span> g<span class="token operator">=</span>f<span class="token punctuation">.</span>bind（o）；<span class="token comment">//通过调用g（x）来调用o.f（x）</span>
g（<span class="token number">2</span>）<span class="token comment">//=&gt;3</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>  ECMAScript 5 中的 bind（）方法不仅仅是将函数绑定至一个对象，它还附带一些其他应用：除了第一个实参之外，传入 bind（）的实参也会绑定至 this，这个附带的应用是一种常见的函数式编程技术，有时也被称为“柯里化”（currying）。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">sum</span><span class="token operator">=</span><span class="token keyword">function</span>（x，y）<span class="token punctuation">{</span> <span class="token keyword">return</span> x<span class="token operator">+</span>y<span class="token punctuation">}</span>；<span class="token comment">//返回两个实参的和值</span>
<span class="token comment">//创建一个类似sum的新函数，但this的值绑定到nu11</span>
<span class="token comment">//并且第一个参数绑定到1，这个新的函数期望只传入一个实参</span>
<span class="token keyword">var</span> succ<span class="token operator">=</span>sum<span class="token punctuation">.</span>bind（<span class="token keyword">null</span>，<span class="token number">1</span>）；
succ（<span class="token number">2</span>）<span class="token comment">//=&gt;3：x绑定到1，并传入2作为实参y</span>
<span class="token keyword">function</span> f（y，z）<span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>x<span class="token operator">+</span>y<span class="token operator">+</span>z<span class="token punctuation">}</span>；<span class="token comment">//另外一个做累加计算的函数</span>
<span class="token keyword">var</span> g<span class="token operator">=</span>f<span class="token punctuation">.</span>bind（<span class="token punctuation">{</span>x：<span class="token number">1</span><span class="token punctuation">}</span>，<span class="token number">2</span>）；<span class="token comment">//绑定this和y</span>
g（<span class="token number">3</span>）<span class="token comment">//=&gt;6：this.x绑定到1，y绑定到2，z绑定到3</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>  ECMAScript3 版本的 Function.bind（）方法</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">if</span>（<span class="token operator">!</span><span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>bind）<span class="token punctuation">{</span>
<span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">bind</span><span class="token operator">=</span><span class="token keyword">function</span>（o<span class="token comment">/*，args*/</span>）<span class="token punctuation">{</span>
    <span class="token comment">//将this和arguments的值保存至变量中</span>
    <span class="token comment">//以便在后面嵌套的函数中可以使用它们</span>
    <span class="token keyword">var</span> self<span class="token operator">=</span><span class="token keyword">this</span>，boundArgs<span class="token operator">=</span>arguments；
    <span class="token comment">//bind（）方法的返回值是一个函数</span>
    <span class="token keyword">return</span> <span class="token keyword">function</span>（）<span class="token punctuation">{</span>
        <span class="token comment">//创建一个实参列表，将传入bind（）的第二个及后续的实参都传入这个函数</span>
        <span class="token keyword">var</span> args<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>，i；
        <span class="token keyword">for</span>（i<span class="token operator">=</span><span class="token number">1</span>；i<span class="token operator">&lt;</span> boundArgs<span class="token punctuation">.</span>length；i<span class="token operator">++</span>）args<span class="token punctuation">.</span>push（boundArgs<span class="token punctuation">[</span>i<span class="token punctuation">]</span>）；
        <span class="token keyword">for</span>（i<span class="token operator">=</span>o；i<span class="token operator">&lt;</span>arguments<span class="token punctuation">.</span>length；i<span class="token operator">++</span>）args<span class="token punctuation">.</span>push（arguments<span class="token punctuation">[</span>i<span class="token punctuation">]</span>）；
        <span class="token comment">//现在将self作为o的方法来调用，传入这些实参</span>
        <span class="token keyword">return</span> self<span class="token punctuation">.</span>apply（o，args）；
        <span class="token punctuation">}</span>；
    <span class="token punctuation">}</span>；
<span class="token punctuation">}</span>；
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>  ECMAScript5 定义的 bind（）方法也有一些特性是上述 ECMAScript3 代码无法模拟的。首先，真正的 bind（）方法返回一个函数对象，这个函数对象的 length 属性是绑定函数的形参个数减去绑定实参的个数（1ength 的值不能小于零）。<br>
  再者，ECMAScript5 的 bind（）方法可以顺带用做构造函数。如果 bind（）返回的函数用做构造函数，将忽略传入 bind（）的 this，原始函数就会以构造函数的形式调用，其实参也已经绑定。<br>
  由 bind（）方法所返回的函数并不包含 prototype 属性（普通函数固有的 prot otype 属性是不能删除的），并且将这些绑定的函数用做构造函数时所创建的对象从原始的未绑定的构造函数中继承 prototype。同样，在使用 instanceof 运算符时，绑定构造函数和未绑定构造函数并无两样。</p> <h3 id="tostring（）方法"><a href="#tostring（）方法" aria-hidden="true" class="header-anchor">#</a> toString（）方法</h3> <p>  和所有的 JavaScript 对象一样，函数也有 toString（）方法，ECMAScript 规范规定这个方法返回一个字符串，这个字符串和函数声明语句的语法相关。实际上，大多数（非全部）的 toString（）方法的实现都返回函数的完整源码。内置函数往往返回一个类似
“[native code]”的字符串作为函数体。</p> <h3 id="function（）构造函数"><a href="#function（）构造函数" aria-hidden="true" class="header-anchor">#</a> Function（）构造函数</h3> <p>  不管是通过函数定义语句还是函数直接量表达式，函数的定义都要使用 function 关字。但函数还可以通过 Function（）构造函数来定义，比如：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> f <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Function</span><span class="token punctuation">(</span><span class="token string">'x'</span><span class="token punctuation">,</span> <span class="token string">'y'</span><span class="token punctuation">,</span> <span class="token string">'return x*y;'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>  Function（）构造函数可以传入任意数量的字符串实参，最后一个实参所表示的文本就是函数体；它可以包含任意的 JavaScript 语句，每两条语句之间用分号分隔。传入构造函数的其他所有的实参字符串是指定函数的形参名字的字符串。如果定义的函数不包含任何参数，只须给构造函数简单地传入一个字符串——函数体即可。<br>
  关于 Function（）构造函数有几点需要特别注意：</p> <ul><li>Function（）构造函数允许 JavaScript 在运行时动态地创建并编译函数。</li> <li>每次调用 Function（）构造函数都会解析函数体，并创建新的函数对象。如果是在一个循环或者多次调用的函数中执行这个构造函数，执行效率会受影响。相比之下，循环中的嵌套函数和函数定义表达式则不会每次执行时都重新编译。</li> <li>最后一点，也是关于 Function（）构造函数非常重要的一点，就是它所创建的函数并不是使用词法作用域，相反，函数体代码的编译总是会在顶层函数执行，正如下面代码所示：</li></ul> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> scope<span class="token operator">=</span><span class="token string">&quot;global&quot;</span>；<span class="token keyword">function</span> constructFunction（）<span class="token punctuation">{</span>
    <span class="token keyword">var</span> scope<span class="token operator">=</span><span class="token string">&quot;local&quot;</span>；
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Function</span>（<span class="token string">&quot;return scope&quot;</span>）；<span class="token comment">//无法捕获局部作用域</span>
    <span class="token punctuation">}</span>
<span class="token comment">//这一行代码返回global，因为通过Function（）构造函数</span>
<span class="token comment">//所返回的函数使用的不是局部作用域</span>
constructFunction（）（）；<span class="token comment">//=&gt;&quot;global&quot;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>  Function（）构造函数在实际编程过程中很少会用到。</p> <h2 id="函数式编程-掌握"><a href="#函数式编程-掌握" aria-hidden="true" class="header-anchor">#</a> 函数式编程(掌握)</h2> <h3 id="使用函数处理数组"><a href="#使用函数处理数组" aria-hidden="true" class="header-anchor">#</a> 使用函数处理数组</h3> <p>  自定义 map（）和 reduce（）函数</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">//对于每个数组元素调用函数f（），并返回一个结果数组</span>
<span class="token comment">//如果Array.prototype.map定义了的话，就使用这个方法</span>
<span class="token keyword">var</span> map<span class="token operator">=</span><span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>map
？<span class="token keyword">function</span>（a，f）<span class="token punctuation">{</span> <span class="token keyword">return</span> a<span class="token punctuation">.</span>map（f）；<span class="token punctuation">}</span><span class="token comment">//如果已经存在map（）方法，就直接使用它</span>
：<span class="token keyword">function</span>（a，f）<span class="token punctuation">{</span><span class="token comment">//否则，自己实现一个</span>
<span class="token keyword">var</span> results<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>；
<span class="token keyword">for</span>（<span class="token keyword">var</span> i<span class="token operator">=</span><span class="token number">0</span>，len<span class="token operator">=</span>a<span class="token punctuation">.</span>length；i<span class="token operator">&lt;</span> len；i<span class="token operator">++</span>）<span class="token punctuation">{</span>
    <span class="token keyword">if</span>（i <span class="token keyword">in</span> a）results<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>f<span class="token punctuation">.</span>call（<span class="token keyword">null</span>，a<span class="token punctuation">[</span>i<span class="token punctuation">]</span>，i，a）；
<span class="token keyword">return</span> results；
<span class="token punctuation">}</span>；
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">//使用函数f（）和可选的初始值将数组a减至一个值</span>
<span class="token comment">//如果Array.prototype.reduce存在的话，就使用这个方法</span>
<span class="token keyword">var</span> reduce<span class="token operator">=</span><span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>reduce
    ？<span class="token keyword">function</span>（a，f，initial）<span class="token punctuation">{</span><span class="token comment">//如果reduce（）方法存在的话</span>
    <span class="token keyword">if</span>（arguments<span class="token punctuation">.</span><span class="token number">1</span>ength<span class="token operator">&gt;</span><span class="token number">2</span>）
        <span class="token keyword">return</span> a<span class="token punctuation">.</span>reduce（f，initial）；<span class="token comment">//如果传人了一个初始值</span>
        <span class="token keyword">else</span> <span class="token keyword">return</span> a<span class="token punctuation">.</span>reduce（f）；<span class="token comment">//否则没有初始值</span>
    <span class="token punctuation">}</span>
    ：<span class="token keyword">function</span>（a，f，initial）<span class="token punctuation">{</span><span class="token comment">//这个算法来自ES5规范</span>
        <span class="token keyword">var</span> i<span class="token operator">=</span><span class="token number">0</span>，len<span class="token operator">=</span>a<span class="token punctuation">.</span>length，accumulator；
    <span class="token comment">//以特定的初始值开始，否则第一个值取自a</span>
    <span class="token keyword">if</span>（arguments<span class="token punctuation">.</span><span class="token number">1</span>ength<span class="token operator">&gt;</span><span class="token number">2</span>）accumulator<span class="token operator">=</span>initial；
    <span class="token keyword">else</span><span class="token punctuation">{</span><span class="token comment">//找到数组中第一个已定义的索引</span>
        <span class="token keyword">if</span>（len<span class="token operator">==</span>o）<span class="token keyword">throw</span> TypeError（）；
        <span class="token keyword">while</span>（i<span class="token operator">&lt;</span>len）<span class="token punctuation">{</span>
            <span class="token keyword">if</span>（i <span class="token keyword">in</span> a）<span class="token punctuation">{</span>
                accumulator <span class="token operator">=</span>a<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span>；
                <span class="token keyword">break</span>；
            <span class="token punctuation">}</span>
            <span class="token keyword">else</span> i<span class="token operator">++</span>；
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span>（i<span class="token operator">==</span><span class="token number">1</span>en）<span class="token keyword">throw</span> TypeError（）；
    <span class="token punctuation">}</span>
    <span class="token comment">//对于数组中剩下的元素依次调用f（）</span>
    <span class="token keyword">while</span>（i<span class="token operator">&lt;</span><span class="token number">1</span>en）<span class="token punctuation">{</span>
        <span class="token keyword">if</span>（i <span class="token keyword">in</span> a）
            accumulator<span class="token operator">=</span>f<span class="token punctuation">.</span>call（<span class="token keyword">undefined</span>，accumulator，a<span class="token punctuation">[</span>i<span class="token punctuation">]</span>，i，a）；
        i<span class="token operator">++</span>；
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> accumulator；
    <span class="token punctuation">}</span>；
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br></div></div><h3 id="高阶函数"><a href="#高阶函数" aria-hidden="true" class="header-anchor">#</a> 高阶函数</h3> <p>  所谓高阶函数（higher-order function）就是操作函数的函数，它接收一个或多个函数作为参数，并返回一个新函数，这里是一个更常见的例子，它接收两个函数 f（）和 g（），并返回一个新的函数用以计算 f（g（））：：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">//返回一个新的可以计算f（g（...））的函数</span>
<span class="token comment">//返回的函数h（）将它所有的实参传入g（），然后将g（）的返回值传入f（）</span>
<span class="token comment">//调用f（）和g（）时的this值和调用h（）时的this值是同一个this</span>
<span class="token keyword">function</span> compose（f，g）<span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">function</span>（）<span class="token punctuation">{</span>
        <span class="token comment">//需要给f（）传人一个参数，所以使用f（）的cal1（）方法</span>
        <span class="token comment">//需要给g（）传入很多参数，所以使用g（）的apply（）方法</span>
        <span class="token keyword">return</span> f<span class="token punctuation">.</span>call（<span class="token keyword">this</span>，g<span class="token punctuation">.</span>apply（<span class="token keyword">this</span>，arguments））；
    <span class="token punctuation">}</span>；
<span class="token punctuation">}</span>
<span class="token keyword">var</span> <span class="token function-variable function">square</span><span class="token operator">=</span><span class="token keyword">function</span>（x）<span class="token punctuation">{</span> <span class="token keyword">return</span> x<span class="token operator">*</span>x；<span class="token punctuation">}</span>；
<span class="token keyword">var</span> <span class="token function-variable function">sum</span><span class="token operator">=</span><span class="token keyword">function</span>（x，y）<span class="token punctuation">{</span> <span class="token keyword">return</span> x<span class="token operator">+</span>y；<span class="token punctuation">}</span>；
<span class="token keyword">var</span> squareofsum<span class="token operator">=</span>compose（square，sum）；
squareofsum（<span class="token number">2</span>，<span class="token number">3</span>）<span class="token comment">//=&gt;25</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">//这个高阶函数返回一个新的函数，这个新函数将它的实参传入f（）</span>
<span class="token comment">//并返回f的返回值的逻辑非</span>
<span class="token keyword">function</span> not（f）<span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">function</span>（）<span class="token punctuation">{</span><span class="token operator">/</span>返回一个新的函数
        <span class="token keyword">var</span> result<span class="token operator">=</span>f<span class="token punctuation">.</span>apply（<span class="token keyword">this</span>，arguments）；<span class="token comment">//调用f（）</span>
        <span class="token keyword">return</span> ！result；<span class="token comment">//对结果求反</span>
    <span class="token punctuation">}</span>；
<span class="token keyword">var</span> <span class="token function-variable function">even</span><span class="token operator">=</span><span class="token keyword">function</span>（x）<span class="token punctuation">{</span><span class="token comment">//判断a是否为偶数的函数</span>
    <span class="token keyword">return</span> x<span class="token operator">%</span><span class="token number">2</span><span class="token operator">===</span><span class="token number">0</span>；
<span class="token punctuation">}</span>；
<span class="token keyword">var</span> odd <span class="token operator">=</span>not（even）；<span class="token comment">//一个新函数，所做的事情和even（）相反</span>
<span class="token punctuation">[</span><span class="token number">1</span>，<span class="token number">1</span>，<span class="token number">3</span>，<span class="token number">5</span>，<span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">.</span>every（odd）；<span class="token comment">//=&gt;true：每个元素都是奇数</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><h3 id="不完全函数"><a href="#不完全函数" aria-hidden="true" class="header-anchor">#</a> 不完全函数</h3> <p>  作者在本节讨论的是一种函数变换技巧，即把一次完整的函数调用拆成多次函数调用，每次传入的实参都是完整实参的一部分，每个拆分开的函数叫做不完全函数（partial function），每次函数调用叫做不完全调用（partial application），这种函数变换的特点是每次调用都返回一个函数，直到得到最终运行结果为止，举一个简单的例子，将对函数 f（1，2，3，4，5，6）的调用修改为等价的 f（1，2）（3，4）（5，6），后者包含三次调用，和每次调用相关的函数就是“不完全函数”。</p> <h3 id="记忆"><a href="#记忆" aria-hidden="true" class="header-anchor">#</a> 记忆</h3> <p>  定义了一个阶乘函数，它可以将上次的计算结果缓存起来。在函数式编程当中，这种缓存技巧叫做“记忆”（memorization）。下面的代码展示了一个高阶函数，memorize（）接收一个函数作为实参，并返回带有记忆能力的函数。<br>
  需要注意的是，记忆只是一种编程技巧，本质上是牺牲算法的空间复杂度以换取更优的时间复杂度，在客户端 JavaScript 中代码的执行时间复杂度往往成为瓶颈，因此在大多数场景下，这种牺牲空间换取时间的做法以提升程序执行效率的做法是非常可取的。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">//返回f（）的带有记忆功能的版本</span>
<span class="token comment">//只有当f（）的实参的字符串表示都不相同时它才会工作</span>
<span class="token keyword">function</span> memorize（f）<span class="token punctuation">{</span>
    <span class="token keyword">var</span> cache<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">}</span>；<span class="token comment">//将值保存在闭包内</span>
    <span class="token keyword">return</span> <span class="token keyword">function</span>（）<span class="token punctuation">{</span>
    <span class="token comment">//将实参转换为字符串形式，并将其用做缓存的键</span>
        <span class="token keyword">var</span> key<span class="token operator">=</span>arguments<span class="token punctuation">.</span>length <span class="token operator">+</span><span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>join<span class="token punctuation">.</span>call（arguments，<span class="token string">&quot;，&quot;</span>）；
        <span class="token keyword">if</span>（key <span class="token keyword">in</span> cache） <span class="token keyword">return</span> cache<span class="token punctuation">[</span>key<span class="token punctuation">]</span>；
        <span class="token keyword">else</span> <span class="token keyword">return</span> cache<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token operator">=</span>f<span class="token punctuation">.</span>apply（<span class="token keyword">this</span>，arguments）；
        <span class="token punctuation">}</span>；
    <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>  memorize（）函数创建一个新的对象，这个对象被当做缓存（的宿主）并赋值给一个局部变量，因此对于返回的函数来说它是私有的（在闭包中）。所返回的函数将它的实参数组转换成字符串，并将字符串用做缓存对象的属性名。如果在缓存中存在这个值，则直接返回它。<br>
  否则，就调用既定的函数对实参进行计算，将计算结果缓存起来并返回，下面的代码展示了如何使用 memorize（）：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">//返回两个整数的最大公约数</span>
<span class="token comment">//使用欧几里德算法：http://en.wikipedia.org/wiki/Euclidean_algorithm</span>
<span class="token keyword">function</span> gcd（a，b）<span class="token punctuation">{</span><span class="token comment">//这里省略对ab的类型检查</span>
    <span class="token keyword">var</span> t；<span class="token comment">//临时变量用来存储交换数值</span>
    <span class="token keyword">if</span>（a<span class="token operator">&lt;</span>b）t<span class="token operator">=</span>b，b<span class="token operator">=</span>a，a<span class="token operator">=</span>t；<span class="token comment">//确保a&gt;=b</span>
    <span class="token keyword">while</span>（bl<span class="token operator">=</span><span class="token number">0</span>）t<span class="token operator">=</span>b，b<span class="token operator">=</span>ab，a<span class="token operator">=</span>t；<span class="token comment">//这是求最大公约数的欧几里德算法</span>
    <span class="token keyword">return</span> a；
    <span class="token punctuation">}</span>
<span class="token keyword">var</span> gcdmemo<span class="token operator">=</span>memorize（gcd）；
gcdmemo（<span class="token number">85</span>，<span class="token number">187</span>）<span class="token comment">//=&gt;17</span>
<span class="token comment">//注意，当我们写一个递归函数时，往往需要实现记忆功能</span>
<span class="token comment">//我们更希望调用实现了记忆功能的递归函数，而不是原递归函数</span>
<span class="token keyword">var</span> factorial<span class="token operator">=</span>memorize（<span class="token keyword">function</span>（n）<span class="token punctuation">{</span>
    <span class="token keyword">return</span>（n<span class="token operator">&lt;=</span><span class="token number">1</span>）？<span class="token number">1</span>：n<span class="token operator">*</span>factorial（n<span class="token operator">-</span><span class="token number">1</span>）；
<span class="token punctuation">}</span>）；
factorial（<span class="token number">5</span>）<span class="token comment">//=&gt;120.对于4~1的值也有缓存</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div></div> <span id="footerPost" data-v-aa2eb952></span></div> <div id="post-toc" class="post-toc el-col el-col-6" data-v-aa2eb952><h4 class="catalog-title" data-v-aa2eb952>TOC</h4> <div class="catalog-body" data-v-aa2eb952><ul id="catalog-list" class="catalog-list" data-v-aa2eb952></ul></div></div></div> <div class="post-nav el-row is-justify-space-around el-row--flex" data-v-aa2eb952><div class="post-prev el-col el-col-7" data-v-aa2eb952><div data-v-aa2eb952><a href="/posts/%E3%80%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%91ES6%E4%B9%8B%E7%94%A8let-const%E5%92%8C%E7%94%A8var%E6%9D%A5%E5%A3%B0%E6%98%8E%E5%8F%98%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB.html" data-v-aa2eb952><i class="el-icon-arrow-left" data-v-aa2eb952></i> Prev
        </a> <p class="nav-title" data-v-aa2eb952>【读书笔记】ES6之用let,const和用var来声明变量的区别</p></div></div> <div class="post-next el-col el-col-7 el-col-lg-pull-5" data-v-aa2eb952><div data-v-aa2eb952><a href="/posts/%E3%80%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%91%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B%E7%AC%AC7%E7%AB%A0%E6%95%B0%E7%BB%84.html" data-v-aa2eb952>
          Next
          <i class="el-icon-arrow-right" data-v-aa2eb952></i></a> <p class="nav-title" data-v-aa2eb952>【读书笔记】《JavaScript权威指南》第7章数组</p></div></div></div> <div class="el-row is-justify-center el-row--flex" data-v-aa2eb952><div class="el-col el-col-23" data-v-aa2eb952></div></div> <span data-v-1ba756dd data-v-aa2eb952><button type="button" class="el-button toc-btn el-button--primary is-circle" data-v-1ba756dd><!----><!----><span><i class="iconfont icon-service-directory" data-v-1ba756dd></i></span></button> <button type="button" class="el-button gotop-btn el-button--primary is-circle" data-v-1ba756dd><!----><!----><span><i class="el-icon-arrow-up" data-v-1ba756dd></i></span></button></span></div></main></section> <button type="button" class="el-button gotop-btn el-button--primary is-circle" style="display:none;" data-v-db63bc4e data-v-3431ceb9><!----><!----><span><i class="el-icon-arrow-up" data-v-db63bc4e></i></span></button></section> <footer class="el-footer container-footer" style="height:60px;" data-v-6660fccd data-v-3431ceb9><div class="footer-warp el-row is-justify-center is-align-center el-row--flex footerMargin" data-v-6660fccd><div class="footer-top el-col el-col-24" data-v-6660fccd><p class="ellipsis" data-v-6660fccd><span data-v-6660fccd>
          博客内容遵循
          <a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" data-v-6660fccd>知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议</a></span></p></div> <div class="footer-bottom el-col el-col-24" data-v-6660fccd><p class="ellipsis" data-v-6660fccd><span data-v-6660fccd><span data-v-6660fccd>
            zhhlwd的个人博客 © 2018-08 ~ 2019-06
          </span></span> <span data-v-6660fccd>
          Power by
          <a href="https://vuepress.vuejs.org/zh/" target="_blank" data-v-6660fccd>VuePress</a> Theme
          <a href="https://github.com/zhhlwd/vuepress-theme-indigo-material" target="_blank" data-v-6660fccd>indigo material</a></span></p></div></div></footer> <div class="overlay" data-v-3431ceb9></div></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.39e00e98.js" defer></script><script src="/assets/js/1.c0224360.js" defer></script><script src="/assets/js/15.f0ca96b2.js" defer></script><script src="/assets/js/5.b07737de.js" defer></script><script src="/assets/js/7.9893d61a.js" defer></script><script src="/assets/js/10.9c509957.js" defer></script><script src="/assets/js/6.57699fa9.js" defer></script><script src="/assets/js/61.acc49c38.js" defer></script><script src="/assets/js/14.0e97f0ce.js" defer></script><script src="/assets/js/16.9fb85302.js" defer></script>
  </body>
</html>
